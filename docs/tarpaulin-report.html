<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","cli.rs"],"content":"use clap::Parser;\n\n#[derive(Parser, Debug)]\n#[command(version, about, long_about = None)]\npub struct Args {\n    #[arg(short, long, help = \"paritydb or rocksdb\")]\n    pub database: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","common-backend","parity_backend.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! An SMT backend based on Actix and Swagger-UI, providing RPC for external service calls.\n//! A single database can create multiple Merkle trees.\n\n#![allow(dead_code)]\n#![allow(unused_imports)]\n#![allow(unused_mut)]\n\nuse actix_web::middleware::Logger as ALogger;\n// use serde_json;\nuse actix_web::{\n    cookie::time::util::weeks_in_year, get, post, web, App, HttpResponse, HttpServer, Responder,\n    ResponseError,\n};\nuse clap::Parser;\nuse codec::{Decode, Encode};\nuse dotenv::dotenv;\nuse ethers::utils::keccak256;\nuse flexi_logger::{Age, Cleanup, Criterion, Logger, Naming, WriteMode};\nuse http::status::{InvalidStatusCode, StatusCode};\nuse log::{error, info};\nuse serde::{Deserialize, Serialize};\nuse serde_with::serde_as;\nuse smt_backend_lib::cli::Args;\nuse smt_backend_lib::{\n    error::Error,\n    parity_apis::MultiSMTParityStore,\n    parity_req::{KVPair, ReqByKVs, ReqByKey, ReqByPrefix, ReqUpdate},\n};\nuse smt_primitives::{\n    keccak_hasher::Keccak256Hasher,\n    kv::*,\n    verify::{verify as smt_verify, Proof},\n};\nuse sparse_merkle_tree::{traits::Value, H256};\nuse std::env;\nuse std::{future, path::Path, result::Result, sync::Mutex};\nuse thiserror::Error as ThisError;\nuse tokio::signal::ctrl_c;\nuse utoipa::{IntoParams, OpenApi, ToSchema};\nuse utoipa_actix_web::AppExt;\nuse utoipa_redoc::Redoc;\nuse utoipa_swagger_ui::SwaggerUi;\n\nconst SMT_API: \u0026str = \"SMT API (ParityDb)\";\n\n#[derive(OpenApi)]\n#[openapi(\n        tags(\n            (name = \"SMT API\", description = \"Provides sparse Merkel tree related APIs\")\n        ),\n    )]\nstruct ApiDoc;\n\n/// Insert a value into a specific Merkle tree.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Insert a value into a specific Merkle tree.\", body = [H256])\n    )\n)]\n#[post(\"/update\")]\nasync fn update_value(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTParityStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqUpdate\u003cSMTKey, SMTValue\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let mut multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let root = multi_tree\n        .update(info.prefix, info.key.clone(), info.value.clone())\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:#?}\",\n        format!(\"[Update] info: {:#?}, root: {:?}\", info, root)\n    );\n    Ok(HttpResponse::Ok().json(root))\n}\n\n/// Remove a value by key\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Remove a value by key\", body = [H256])\n    )\n)]\n#[post(\"/remove\")]\nasync fn remove_value(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTParityStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByKey\u003cSMTKey\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let mut multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let root = multi_tree\n        .update(info.prefix, info.key.clone(), Default::default())\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:#?}\",\n        format!(\"[Remove] info: {:#?}, root: {:?}\", info, root)\n    );\n    Ok(HttpResponse::Ok().json(root))\n}\n\n/// Get the Merkle proof.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Get the Merkle proof.\", body = [Proof\u003cSMTKey, SMTValue\u003e])\n    )\n)]\n#[post(\"/merkle_proof\")]\nasync fn get_merkle_proof(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTParityStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByKey\u003cSMTKey\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let proof = multi_tree\n        .get_merkle_proof(info.prefix, info.key.clone())\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:?}\",\n        format!(\"[Get Merkle Proof] info: {:?}, proof: {:?}\", info, proof)\n    );\n    Ok(HttpResponse::Ok().json(proof))\n}\n\n/// Before data is updated, the future value of the root hash can be calculated in advance.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Before data is updated, the future value of the root hash can be calculated in advance.\", body = [H256])\n    )\n)]\n#[post(\"/next_root\")]\nasync fn get_next_root(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTParityStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByKVs\u003cKVPair\u003cSMTKey, SMTValue\u003e\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let old_proof = multi_tree\n        .get_merkle_proof_old(info.prefix, vec![info.kv.key.clone()])\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let next_root = multi_tree\n        .get_next_root(\n            old_proof,\n            vec![(info.kv.key.clone(), info.kv.value.clone())],\n        )\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:?}\",\n        format!(\n            \"[Get Next Root] info: {:?}, next root: {:?}\",\n            info, next_root\n        )\n    );\n    Ok(HttpResponse::Ok().json(next_root))\n}\n\n/// Get the root hash.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Get the root hash.\", body = [H256])\n    )\n)]\n#[post(\"/root\")]\nasync fn get_root(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTParityStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByPrefix\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let root = multi_tree\n        .get_root(info.prefix)\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:?}\",\n        format!(\n            \"[Get Root] info: {:?}, root: {:?}\",\n            info,\n            serde_json::to_string(\u0026root)\n        )\n    );\n    Ok(HttpResponse::Ok().json(root))\n}\n\n/// Get the value of a specific key in a particular tree.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Get the value of a specific key in a particular tree.\", body = [SMTValue])\n    )\n)]\n#[post(\"/value\")]\nasync fn get_value(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTParityStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByKey\u003cSMTKey\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let value = multi_tree\n        .get_value(info.prefix, info.key.clone())\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:?}\",\n        format!(\"[Get Value] info: {:?}, value: {:?}\", info, value)\n    );\n    Ok(HttpResponse::Ok().json(value))\n}\n\n/// Verify the Merkle proof.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Verify the Merkle proof.\", body = [bool])\n    )\n)]\n#[post(\"/verify\")]\nasync fn verify(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTParityStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cProof\u003cSMTKey, SMTValue\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let res = multi_tree.verify(Proof {\n        key: info.key.clone(),\n        value: info.value.clone(),\n        path: info.key.to_h256(),\n        value_hash: info.value.to_h256(),\n        leave_bitmap: info.leave_bitmap,\n        siblings: info.siblings.clone(),\n        root: info.root,\n    });\n    log::info!(\"{:?}\", format!(\"[Verify] info: {:?}, res: {:?}\", info, res));\n    Ok(HttpResponse::Ok().json(res))\n}\n\n/// Delete a specific Merkle tree.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Delete a specific Merkle tree.\", body = [H256])\n    )\n)]\n#[post(\"/clear\")]\nasync fn clear(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTParityStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByPrefix\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n\n    multi_tree.clear(info.prefix).unwrap();\n    let root = multi_tree\n        .get_root(info.prefix)\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\"{:?}\", format!(\"[Clear] info: {:?}, res: {:?}\", info, root));\n    Ok(HttpResponse::Ok().json(root))\n}\n\n#[actix_web::main]\nasync fn main() -\u003e std::io::Result\u003c()\u003e {\n    // fixme\n    // let args = Args::parse();\n    // let database: String = args.database;\n    dotenv().ok();\n    let base_path = env::var(\"DB_PATH\").unwrap();\n    let log_path = env::var(\"LOG_PATH\").unwrap();\n    let multi_tree = web::Data::new(Mutex::new(\n        MultiSMTParityStore::\u003cSMTKey, SMTValue, Keccak256Hasher\u003e::open(\n            Path::new(\u0026format!(\"{}/paritydb\", base_path)),\n            20,\n        )\n        .unwrap(),\n    ));\n    print!(\"log path: {:?}\", log_path);\n\n    // let l = async {\n    Logger::try_with_str(\"info\")\n        .unwrap()\n        .log_to_file(flexi_logger::FileSpec::default().directory(log_path))\n        // .write_mode(WriteMode::BufferAndFlush)\n        .rotate(\n            flexi_logger::Criterion::Age(Age::Day),\n            Naming::TimestampsDirect,\n            Cleanup::Never,\n        )\n        .append()\n        .log_to_stdout()\n        .start()\n        .unwrap();\n    // std::future::pending::\u003c()\u003e().await;\n    // };\n\n    let app = HttpServer::new(move || {\n        App::new()\n            .into_utoipa_app()\n            .openapi(ApiDoc::openapi())\n            .service(update_value)\n            .service(get_value)\n            .service(get_merkle_proof)\n            .service(get_next_root)\n            .service(get_root)\n            .service(verify)\n            .service(remove_value)\n            .service(clear)\n            .app_data(multi_tree.clone())\n            .openapi_service(|api| {\n                SwaggerUi::new(\"/swagger-ui/{_:.*}\").url(\"/api-docs/openapi.json\", api)\n            })\n            .into_app()\n    })\n    .shutdown_timeout(30)\n    .bind((\"0.0.0.0\", 8081))?\n    .run();\n\n    let graceful_shutdown = async {\n        ctrl_c().await.expect(\"Failed to listen for event\");\n        println!(\"Received CTRL-C, shutting down gracefully...\");\n    };\n\n    let graceful_shutdown_task = tokio::spawn(graceful_shutdown);\n\n    let result = tokio::select! {\n        _ = app =\u003e Ok(()),\n        _ = graceful_shutdown_task =\u003e Ok(()),\n        // _ = l =\u003e Ok(()),\n    };\n\n    result\n}\n","traces":[{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":86},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","common-backend","rocks_backend.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! An SMT backend based on Actix and Swagger-UI, providing RPC for external service calls.\n//! A single database can create multiple Merkle trees.\n\n#![allow(dead_code)]\n#![allow(unused_imports)]\n#![allow(unused_mut)]\n\nuse actix_web::middleware::Logger as ALogger;\n// use serde_json;\nuse actix_web::{\n    cookie::time::util::weeks_in_year, get, post, web, App, HttpResponse, HttpServer, Responder,\n    ResponseError,\n};\nuse clap::Parser;\nuse codec::{Decode, Encode};\nuse dotenv::dotenv;\nuse ethers::utils::keccak256;\nuse flexi_logger::{Age, Cleanup, Criterion, Logger, Naming, WriteMode};\nuse http::status::{InvalidStatusCode, StatusCode};\nuse log::{error, info};\nuse serde::{Deserialize, Serialize};\nuse serde_with::serde_as;\nuse smt_backend_lib::cli::Args;\nuse smt_backend_lib::{\n    apis::MultiSMTStore,\n    error::Error,\n    req::{KVPair, ReqByKVs, ReqByKey, ReqByPrefix, ReqUpdate},\n};\nuse smt_primitives::{\n    keccak_hasher::Keccak256Hasher,\n    kv::*,\n    verify::{verify as smt_verify, Proof},\n};\nuse sparse_merkle_tree::{traits::Value, H256};\nuse std::env;\nuse std::{future, path::Path, result::Result, sync::Mutex};\nuse thiserror::Error as ThisError;\nuse tokio::signal::ctrl_c;\nuse utoipa::{IntoParams, OpenApi, ToSchema};\nuse utoipa_actix_web::AppExt;\nuse utoipa_redoc::Redoc;\nuse utoipa_swagger_ui::SwaggerUi;\n\nconst SMT_API: \u0026str = \"SMT API (RocksDB)\";\n\n#[derive(OpenApi)]\n#[openapi(\n        tags(\n            (name = \"SMT API\", description = \"Provides sparse Merkel tree related APIs\")\n        ),\n    )]\nstruct ApiDoc;\n\n/// Insert a value into a specific Merkle tree.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Insert a value into a specific Merkle tree.\", body = [H256])\n    )\n)]\n#[post(\"/update\")]\nasync fn update_value(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqUpdate\u003cSMTKey, SMTValue\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let mut multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let root = multi_tree\n        .update(info.prefix.clone(), info.key.clone(), info.value.clone())\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:#?}\",\n        format!(\"[Update] info: {:#?}, root: {:?}\", info, root)\n    );\n    Ok(HttpResponse::Ok().json(root))\n}\n\n/// Remove a value by key\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Remove a value by key\", body = [H256])\n    )\n)]\n#[post(\"/remove\")]\nasync fn remove_value(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByKey\u003cSMTKey\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let mut multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let root = multi_tree\n        .update(\n            info.prefix.to_string(),\n            info.key.clone(),\n            Default::default(),\n        )\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:#?}\",\n        format!(\"[Remove] info: {:#?}, root: {:?}\", info, root)\n    );\n    Ok(HttpResponse::Ok().json(root))\n}\n\n/// Get the Merkle proof.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Get the Merkle proof.\", body = [Proof\u003cSMTKey, SMTValue\u003e])\n    )\n)]\n#[post(\"/merkle_proof\")]\nasync fn get_merkle_proof(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByKey\u003cSMTKey\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let proof = multi_tree\n        .get_merkle_proof(info.prefix.to_string(), info.key.clone())\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:?}\",\n        format!(\"[Get Merkle Proof] info: {:?}, proof: {:?}\", info, proof)\n    );\n    Ok(HttpResponse::Ok().json(proof))\n}\n\n/// Before data is updated, the future value of the root hash can be calculated in advance.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Before data is updated, the future value of the root hash can be calculated in advance.\", body = [H256])\n    )\n)]\n#[post(\"/next_root\")]\nasync fn get_next_root(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByKVs\u003cKVPair\u003cSMTKey, SMTValue\u003e\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let old_proof = multi_tree\n        .get_merkle_proof_old(info.prefix.to_string(), vec![info.kv.key.clone()])\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let next_root = multi_tree\n        .get_next_root(\n            old_proof,\n            vec![(info.kv.key.clone(), info.kv.value.clone())],\n        )\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:?}\",\n        format!(\n            \"[Get Next Root] info: {:?}, next root: {:?}\",\n            info, next_root\n        )\n    );\n    Ok(HttpResponse::Ok().json(next_root))\n}\n\n/// Get the root hash.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Get the root hash.\", body = [H256])\n    )\n)]\n#[post(\"/root\")]\nasync fn get_root(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByPrefix\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let root = multi_tree\n        .get_root(info.prefix.to_string())\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:?}\",\n        format!(\n            \"[Get Root] info: {:?}, root: {:?}\",\n            info,\n            serde_json::to_string(\u0026root)\n        )\n    );\n    Ok(HttpResponse::Ok().json(root))\n}\n\n/// Get the value of a specific key in a particular tree.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Get the value of a specific key in a particular tree.\", body = [SMTValue])\n    )\n)]\n#[post(\"/value\")]\nasync fn get_value(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByKey\u003cSMTKey\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let value = multi_tree\n        .get_value(info.prefix.to_string(), info.key.clone())\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:?}\",\n        format!(\"[Get Value] info: {:?}, value: {:?}\", info, value)\n    );\n    Ok(HttpResponse::Ok().json(value))\n}\n\n/// Verify the Merkle proof.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Verify the Merkle proof.\", body = [bool])\n    )\n)]\n#[post(\"/verify\")]\nasync fn verify(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cProof\u003cSMTKey, SMTValue\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let res = multi_tree.verify(Proof {\n        key: info.key.clone(),\n        value: info.value.clone(),\n        path: info.key.to_h256(),\n        value_hash: info.value.to_h256(),\n        leave_bitmap: info.leave_bitmap,\n        siblings: info.siblings.clone(),\n        root: info.root,\n    });\n    log::info!(\"{:?}\", format!(\"[Verify] info: {:?}, res: {:?}\", info, res));\n    Ok(HttpResponse::Ok().json(res))\n}\n\n/// Delete a specific Merkle tree.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Delete a specific Merkle tree.\", body = [H256])\n    )\n)]\n#[post(\"/clear\")]\nasync fn clear(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByPrefix\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n\n    multi_tree.clear(info.prefix.to_string());\n    let root = multi_tree\n        .get_root(info.prefix.to_string())\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\"{:?}\", format!(\"[Clear] info: {:?}, res: {:?}\", info, root));\n    Ok(HttpResponse::Ok().json(root))\n}\n\n#[actix_web::main]\nasync fn main() -\u003e std::io::Result\u003c()\u003e {\n    // fixme\n    // let args = Args::parse();\n    // let database: String = args.database;\n    dotenv().ok();\n    let base_path = env::var(\"DB_PATH\").unwrap();\n    let log_path = env::var(\"LOG_PATH\").unwrap();\n    let multi_tree = web::Data::new(Mutex::new(\n        MultiSMTStore::\u003cSMTKey, SMTValue, Keccak256Hasher\u003e::open(Path::new(\u0026format!(\n            \"{}/rocksdb\",\n            base_path\n        )))\n        .unwrap(),\n    ));\n    print!(\"log path: {:?}\", log_path);\n\n    // let l = async {\n    Logger::try_with_str(\"info\")\n        .unwrap()\n        .log_to_file(flexi_logger::FileSpec::default().directory(log_path))\n        // .write_mode(WriteMode::BufferAndFlush)\n        .rotate(\n            flexi_logger::Criterion::Age(Age::Day),\n            Naming::TimestampsDirect,\n            Cleanup::Never,\n        )\n        .append()\n        .log_to_stdout()\n        .start()\n        .unwrap();\n    // std::future::pending::\u003c()\u003e().await;\n    // };\n\n    let app = HttpServer::new(move || {\n        App::new()\n            .into_utoipa_app()\n            .openapi(ApiDoc::openapi())\n            .service(update_value)\n            .service(get_value)\n            .service(get_merkle_proof)\n            .service(get_next_root)\n            .service(get_root)\n            .service(verify)\n            .service(remove_value)\n            .service(clear)\n            .app_data(multi_tree.clone())\n            .openapi_service(|api| {\n                SwaggerUi::new(\"/swagger-ui/{_:.*}\").url(\"/api-docs/openapi.json\", api)\n            })\n            .into_app()\n    })\n    .shutdown_timeout(30)\n    .bind((\"0.0.0.0\", 8080))?\n    .run();\n\n    let graceful_shutdown = async {\n        ctrl_c().await.expect(\"Failed to listen for event\");\n        println!(\"Received CTRL-C, shutting down gracefully...\");\n    };\n\n    let graceful_shutdown_task = tokio::spawn(graceful_shutdown);\n\n    let result = tokio::select! {\n        _ = app =\u003e Ok(()),\n        _ = graceful_shutdown_task =\u003e Ok(()),\n        // _ = l =\u003e Ok(()),\n    };\n\n    result\n}\n","traces":[{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":86},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","error.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#![allow(unused_imports)]\nuse actix_web::{\n    cookie::time::util::weeks_in_year, get, post, web, App, HttpResponse, HttpServer, Responder,\n    ResponseError,\n};\nuse thiserror::Error as ThisError;\n#[derive(Debug, ThisError)]\npub enum Error {\n    #[error(\"Internal server error: {0}\")]\n    InternalError(String),\n\n    #[error(\"Unexpected error occurred\")]\n    UnexpectedError,\n}\n\nimpl ResponseError for Error {\n    fn error_response(\u0026self) -\u003e HttpResponse\u003cactix_web::body::BoxBody\u003e {\n        match self {\n            Error::InternalError(e) =\u003e HttpResponse::BadRequest().body(e.to_string()),\n            _ =\u003e HttpResponse::BadRequest().body(\"Unexpected error occurred\"),\n        }\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","lib.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Provide APIs related to SMT (Sparse Merkle Tree).  \n//! Implement persistent storage for SMT.  \n//! A single database can store multiple Merkle trees, and they do not interfere with each other.\n\npub mod cli;\npub mod error;\npub mod parity;\npub mod rocks;\npub use parity::*;\npub use rocks::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","parity","mod.rs"],"content":"pub mod parity_apis;\npub mod parity_db;\npub mod parity_req;\npub mod parity_store;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","parity","parity_apis.rs"],"content":"use crate::parity_db::ParityDb;\nuse crate::parity_store::SMTParityStore;\nuse scale_info::TypeInfo;\nuse serde::{Deserialize, Serialize};\nuse smt_primitives::{\n    // keccak_hasher::Keccak256Hasher,\n    verify::{verify as smt_verify, Proof},\n};\nuse sparse_merkle_tree::{\n    error::{Error, Result as SMTResult},\n    // merge::MergeValue,\n    traits::{Hasher, Value},\n    CompiledMerkleProof,\n    SparseMerkleTree,\n    H256,\n};\nuse std::{fmt::Debug, marker::PhantomData, path::Path, sync::Arc};\nuse utoipa::{ToSchema, __dev::ComposeSchema};\n\ntype MultiSMT\u003cV, H\u003e = SparseMerkleTree\u003cH, V, SMTParityStore\u003e;\n\n/// Multiple Merkle trees are stored in a ParityDb database\npub struct MultiSMTParityStore\u003cK, V, H\u003e {\n    store: Arc\u003cParityDb\u003e,\n    v: PhantomData\u003c(K, V, H)\u003e,\n}\n\nimpl\u003c\n        K: Value\n            + Clone\n            + Serialize\n            + ToSchema\n            + Deserialize\u003c'static\u003e\n            + ComposeSchema\n            + Debug\n            + TypeInfo,\n        V: Default\n            + Value\n            + Into\u003cVec\u003cu8\u003e\u003e\n            + From\u003cVec\u003cu8\u003e\u003e\n            + ToSchema\n            + Serialize\n            + Deserialize\u003c'static\u003e\n            + ComposeSchema\n            + PartialEq\n            + Clone\n            + Debug\n            + TypeInfo,\n        H: Hasher + Default,\n    \u003e MultiSMTParityStore\u003cK, V, H\u003e\n{\n    /// Open the ParityDb database, create it if it does not exist.\n    pub fn open\u003cP: AsRef\u003cPath\u003e\u003e(path: P, num_columns: u8) -\u003e std::io::Result\u003cSelf\u003e {\n        let db = ParityDb::new(path.as_ref(), num_columns);\n        Ok(Self {\n            store: Arc::new(db),\n            v: Default::default(),\n        })\n    }\n\n    /// Create or open a new tree with specified column\n    pub fn new_tree_with_store(\u0026self, col: u8) -\u003e Result\u003cMultiSMT\u003cV, H\u003e, Error\u003e {\n        let db = SMTParityStore::new(self.store.clone(), col);\n        MultiSMT::new_with_store(db)\n    }\n\n    /// Insert a value into a specific Merkle tree\n    pub fn update(\u0026self, col: u8, key: K, value: V) -\u003e SMTResult\u003cH256\u003e {\n        let mut tree = self.new_tree_with_store(col)?;\n        let h = tree.update(key.to_h256(), value)?;\n        Ok(*h)\n    }\n\n    /// Insert multiple values into a Merkle tree at once\n    pub fn update_all(\u0026self, col: u8, kvs: Vec\u003c(K, V)\u003e) -\u003e SMTResult\u003cH256\u003e {\n        let kvs = kvs\n            .into_iter()\n            .map(|(k, v)| Ok((k.to_h256(), v)))\n            .collect::\u003cResult\u003cVec\u003c(H256, V)\u003e, Error\u003e\u003e()?;\n\n        let mut tree = self.new_tree_with_store(col)?;\n        let root = tree.update_all(kvs)?;\n        Ok(*root)\n    }\n\n    /// Get the root hash\n    pub fn get_root(\u0026self, col: u8) -\u003e Result\u003cH256, Error\u003e {\n        let tree = self.new_tree_with_store(col)?;\n        Ok(*tree.root())\n    }\n\n    /// Get the value of a specific key in a particular tree\n    pub fn get_value(\u0026self, col: u8, key: K) -\u003e Result\u003cV, Error\u003e {\n        let tree = self.new_tree_with_store(col)?;\n        let value = tree.get(\u0026key.to_h256())?;\n        Ok(value)\n    }\n\n    /// Get the Merkle proof\n    pub fn get_merkle_proof(\u0026self, col: u8, key: K) -\u003e Result\u003cProof\u003cK, V\u003e, Error\u003e {\n        let tree = self.new_tree_with_store(col)?;\n        let proof = tree.merkle_proof(vec![key.to_h256()])?;\n        let leaves_bitmap = proof.leaves_bitmap();\n        let siblings = proof.merkle_path();\n        let leave_bitmap = leaves_bitmap[0];\n        let value = self.get_value(col, key.clone())?;\n\n        Ok(Proof {\n            key: key.clone(),\n            value: value.clone(),\n            path: key.to_h256(),\n            value_hash: value.to_h256(),\n            root: *tree.root(),\n            leave_bitmap,\n            siblings: siblings.clone(),\n        })\n    }\n\n    /// Get the Merkle proof, the return value is `Vec\u003cu8\u003e`\n    pub fn get_merkle_proof_old(\u0026self, col: u8, keys: Vec\u003cK\u003e) -\u003e SMTResult\u003cVec\u003cu8\u003e\u003e {\n        let tree = self.new_tree_with_store(col)?;\n        let keys = keys\n            .into_iter()\n            .map(|k| Ok(k.to_h256()))\n            .collect::\u003cResult\u003cVec\u003cH256\u003e, Error\u003e\u003e()?;\n\n        let proof = tree.merkle_proof(keys.clone())?;\n        let proof = proof.compile(keys)?;\n        Ok(proof.0)\n    }\n\n    /// Before data is updated, the future value of the root hash can be calculated in advance\n    pub fn get_next_root(\u0026self, old_proof: Vec\u003cu8\u003e, next_kvs: Vec\u003c(K, V)\u003e) -\u003e Result\u003cH256, Error\u003e {\n        let p = CompiledMerkleProof(old_proof);\n        let kvs = next_kvs\n            .into_iter()\n            .map(|(k, v)| Ok((k.to_h256(), v.to_h256())))\n            .collect::\u003cResult\u003cVec\u003c(H256, H256)\u003e, Error\u003e\u003e()?;\n\n        let next_root = p.compute_root::\u003cH\u003e(kvs)?;\n        Ok(next_root)\n    }\n\n    /// Delete a specific Merkle tree by clearing its column\n    pub fn clear(\u0026self, col: u8) -\u003e Result\u003c(), Error\u003e {\n        self.store\n            .clear_column(col)\n            .map_err(|e| Error::Store(e.to_string()))?;\n        Ok(())\n    }\n\n    /// Verify the Merkle proof\n    pub fn verify(\u0026self, proof: Proof\u003cK, V\u003e) -\u003e bool {\n        let mut res = false;\n        if proof.value != V::default() {\n            res = smt_verify::\u003cH\u003e(\n                proof.path,\n                proof.value_hash,\n                proof.leave_bitmap,\n                proof.siblings,\n                proof.root,\n            )\n        }\n        res\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use smt_primitives::{kv::{SMTKey, SMTValue}, keccak_hasher::Keccak256Hasher};\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_apis() {\n        // Create multi_tree\n        let temp_dir = tempdir().unwrap();\n        let multi_tree =\n            MultiSMTParityStore::\u003cSMTKey, SMTValue, Keccak256Hasher\u003e::open(temp_dir.path(), 2)\n                .unwrap();\n\n        let tree1_col: u8 = 0;\n        let tree2_col: u8 = 1;\n        multi_tree.clear(tree1_col).unwrap();\n        multi_tree.clear(tree2_col).unwrap();\n        multi_tree.new_tree_with_store(tree1_col).unwrap();\n        multi_tree.new_tree_with_store(tree2_col).unwrap();\n\n        // Get roots from both trees\n        assert_eq!(multi_tree.get_root(tree1_col).unwrap(), H256::zero());\n        assert_eq!(multi_tree.get_root(tree2_col).unwrap(), H256::zero());\n\n        // Insert data into tree1\n        let tree1_key1 = SMTKey {\n            address: \"1\".to_string(),\n        };\n        let tree1_value1 = SMTValue {\n            nonce: 1,\n            balance: 99,\n        };\n        let tree1_key2 = SMTKey {\n            address: \"2\".to_string(),\n        };\n        let tree1_value2 = SMTValue {\n            nonce: 2,\n            balance: 97,\n        };\n\n        assert_eq!(\n            multi_tree.get_value(tree1_col, tree1_key1.clone()).unwrap(),\n            SMTValue::default()\n        );\n        assert_eq!(multi_tree.get_root(tree1_col).unwrap(), H256::zero());\n\n        // Update and verify\n        multi_tree\n            .update(tree1_col, tree1_key1.clone(), tree1_value1.clone())\n            .unwrap();\n        assert_eq!(\n            multi_tree.get_value(tree1_col, tree1_key1.clone()).unwrap(),\n            tree1_value1.clone()\n        );\n\n        let proof = multi_tree\n            .get_merkle_proof(tree1_col, tree1_key1.clone())\n            .unwrap();\n        assert!(multi_tree.verify(proof));\n\n        // Test remove\n        multi_tree\n            .update(tree1_col, tree1_key1.clone(), SMTValue::default())\n            .unwrap();\n        assert_eq!(\n            multi_tree.get_value(tree1_col, tree1_key1.clone()).unwrap(),\n            SMTValue::default()\n        );\n\n        // Test multiple updates\n        multi_tree\n            .update(tree1_col, tree1_key1.clone(), tree1_value1.clone())\n            .unwrap();\n        let _tree1_root1 = multi_tree.get_root(tree1_col).unwrap();\n\n        let old_proof = multi_tree\n            .get_merkle_proof_old(tree1_col, vec![tree1_key2.clone()])\n            .unwrap();\n        let _next_root = multi_tree\n            .get_next_root(old_proof, vec![(tree1_key2.clone(), tree1_value2.clone())])\n            .unwrap();\n\n        let tree2_root1 = multi_tree\n            .update(tree1_col, tree1_key2.clone(), tree1_value2.clone())\n            .unwrap();\n\n        assert_eq!(_next_root, tree2_root1);\n\n        // Test clear\n        multi_tree.clear(tree1_col).unwrap();\n        assert_eq!(\n            multi_tree.get_value(tree1_col, tree1_key1.clone()).unwrap(),\n            SMTValue::default()\n        );\n\n        // Test batch update\n        let mut kvs: Vec\u003c(SMTKey, SMTValue)\u003e = vec![];\n        for i in 1..2 {\n            kvs.push((\n                SMTKey {\n                    address: i.to_string(),\n                },\n                SMTValue {\n                    nonce: i as u64,\n                    balance: i as u128,\n                },\n            ));\n        }\n\n        multi_tree.update_all(tree1_col, kvs.clone()).unwrap();\n    }\n}\n","traces":[{"line":53,"address":[],"length":0,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":62,"address":[],"length":0,"stats":{"Line":18}},{"line":63,"address":[],"length":0,"stats":{"Line":18}},{"line":64,"address":[],"length":0,"stats":{"Line":18}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":8}},{"line":70,"address":[],"length":0,"stats":{"Line":4}},{"line":71,"address":[],"length":0,"stats":{"Line":4}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":3}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":87,"address":[],"length":0,"stats":{"Line":4}},{"line":88,"address":[],"length":0,"stats":{"Line":8}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":5}},{"line":94,"address":[],"length":0,"stats":{"Line":10}},{"line":95,"address":[],"length":0,"stats":{"Line":5}},{"line":96,"address":[],"length":0,"stats":{"Line":5}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":1}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":129,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":137,"address":[],"length":0,"stats":{"Line":3}},{"line":140,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":145,"address":[],"length":0,"stats":{"Line":3}},{"line":146,"address":[],"length":0,"stats":{"Line":3}},{"line":147,"address":[],"length":0,"stats":{"Line":3}},{"line":148,"address":[],"length":0,"stats":{"Line":6}},{"line":149,"address":[],"length":0,"stats":{"Line":3}},{"line":153,"address":[],"length":0,"stats":{"Line":1}},{"line":154,"address":[],"length":0,"stats":{"Line":1}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":1}}],"covered":64,"coverable":68},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","parity","parity_db.rs"],"content":"use parity_db::{clear_column, Db, Options};\nuse std::{fmt, path::PathBuf};\n\npub struct ParityDb {\n    path: PathBuf,\n    num_columns: u8,\n}\n\n#[derive(Debug)]\npub enum StoreError {\n    DbError(parity_db::Error),\n    InvalidColumnId,\n}\n\n//  Display trait\nimpl fmt::Display for StoreError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            StoreError::DbError(e) =\u003e write!(f, \"Database error: {:?}\", e),\n            StoreError::InvalidColumnId =\u003e write!(f, \"Invalid column ID\"),\n        }\n    }\n}\n\nimpl From\u003cparity_db::Error\u003e for StoreError {\n    fn from(error: parity_db::Error) -\u003e Self {\n        StoreError::DbError(error)\n    }\n}\n\nimpl ParityDb {\n    /// create a new ParityDb instance\n    pub fn new(path: impl Into\u003cPathBuf\u003e, num_columns: u8) -\u003e Self {\n        Self {\n            path: path.into(),\n            num_columns,\n        }\n    }\n\n    /// Opens an existing database or creates a new one if it doesn't exist\n    pub fn open_or_create(\u0026self) -\u003e Result\u003cDb, StoreError\u003e {\n        let options = Options::with_columns(\u0026self.path, self.num_columns);\n        let db = Db::open_or_create(\u0026options)?;\n        Ok(db)\n    }\n\n    fn check_column(\u0026self, column: u8) -\u003e Result\u003c(), StoreError\u003e {\n        if column \u003e= self.num_columns {\n            return Err(StoreError::InvalidColumnId);\n        }\n        Ok(())\n    }\n\n    /// Insert a value into the specified column\n    pub fn insert(\u0026self, column: u8, key: \u0026[u8], value: \u0026[u8]) -\u003e Result\u003c(), StoreError\u003e {\n        self.check_column(column)?;\n        let db = self.open_or_create()?;\n        db.commit(vec![(column, key.to_vec(), Some(value.to_vec()))])?;\n        Ok(())\n    }\n\n    /// Delete a value from the specified column\n    pub fn delete(\u0026self, column: u8, key: \u0026[u8]) -\u003e Result\u003c(), StoreError\u003e {\n        self.check_column(column)?;\n        let db = self.open_or_create()?;\n        db.commit(vec![(column, key.to_vec(), None)])?;\n        Ok(())\n    }\n\n    /// Get a value from the specified column\n    pub fn get(\u0026self, column: u8, key: \u0026[u8]) -\u003e Result\u003cOption\u003cVec\u003cu8\u003e\u003e, StoreError\u003e {\n        self.check_column(column)?;\n        let db = self.open_or_create()?;\n        Ok(db.get(column, key)?)\n    }\n\n    /// Delete the entire database by removing all files\n    pub fn destroy(self) -\u003e Result\u003c(), StoreError\u003e {\n        if self.path.exists() {\n            std::fs::remove_dir_all(\u0026self.path)\n                .map_err(|e| StoreError::DbError(parity_db::Error::Io(e)))?;\n        }\n\n        Ok(())\n    }\n\n    /// Ensure the database is properly closed before operations like clear_column\n    fn ensure_closed(\u0026self) -\u003e Result\u003c(), StoreError\u003e {\n        let db = self.open_or_create()?;\n        drop(db);\n        Ok(())\n    }\n\n    /// Clear all data in a column without recreating it\n    pub fn clear_column(\u0026self, column: u8) -\u003e Result\u003c(), StoreError\u003e {\n        self.check_column(column)?;\n        self.ensure_closed()?;\n        clear_column(\u0026self.path, column)?;\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_basic_operations() {\n        let temp_dir = tempdir().unwrap();\n        let store = ParityDb::new(temp_dir.path(), 2);\n\n        // Test insert\n        let key = b\"test_key\";\n        let value = b\"test_value\";\n        store.insert(0, key, value).unwrap();\n\n        // Test get\n        let retrieved = store.get(0, key).unwrap();\n        assert_eq!(retrieved, Some(value.to_vec()));\n\n        // Test delete\n        store.delete(0, key).unwrap();\n        let retrieved = store.get(0, key).unwrap();\n        assert_eq!(retrieved, None);\n\n        // Test destroy\n        store.destroy().unwrap();\n        assert!(!temp_dir.path().exists());\n    }\n\n    #[test]\n    fn test_reset_column() {\n        let temp_dir = tempdir().unwrap();\n        let store = ParityDb::new(temp_dir.path(), 2);\n\n        // Insert data in both columns\n        store.insert(0, b\"key1\", b\"value1\").unwrap();\n        store.insert(1, b\"key2\", b\"value2\").unwrap();\n\n        // Clear column 0\n        store.clear_column(0).unwrap();\n\n        // Verify data\n        assert_eq!(store.get(0, b\"key1\").unwrap(), None);\n        assert_eq!(store.get(1, b\"key2\").unwrap(), Some(b\"value2\".to_vec()));\n    }\n\n    #[test]\n    fn test_clear_column() {\n        let temp_dir = tempdir().unwrap();\n        let store = ParityDb::new(temp_dir.path(), 2);\n\n        // Insert some test data\n        for i in 0..100 {\n            let key = format!(\"key{}\", i).into_bytes();\n            let value = format!(\"value{}\", i).into_bytes();\n            store.insert(0, \u0026key, \u0026value).unwrap();\n            store.insert(1, \u0026key, \u0026value).unwrap();\n        }\n\n        // Clear column 0\n        store.clear_column(0).unwrap();\n\n        // Verify column 0 is empty but column 1 still has data\n        for i in 0..100 {\n            let key = format!(\"key{}\", i).into_bytes();\n            assert_eq!(store.get(0, \u0026key).unwrap(), None);\n            assert!(store.get(1, \u0026key).unwrap().is_some());\n        }\n    }\n\n    #[test]\n    fn test_column_bounds() {\n        let temp_dir = tempdir().unwrap();\n        let store = ParityDb::new(temp_dir.path(), 2);\n\n        // Test inserting to invalid column\n        let result = store.insert(2, b\"key\", b\"value\");\n        assert!(result.is_err());\n\n        // Test getting from invalid column\n        let result = store.get(2, b\"key\");\n        assert!(result.is_err());\n\n        // Test deleting from invalid column\n        let result = store.delete(2, b\"key\");\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":6}},{"line":35,"address":[],"length":0,"stats":{"Line":6}},{"line":41,"address":[],"length":0,"stats":{"Line":3521}},{"line":42,"address":[],"length":0,"stats":{"Line":3521}},{"line":43,"address":[],"length":0,"stats":{"Line":7042}},{"line":47,"address":[],"length":0,"stats":{"Line":3524}},{"line":48,"address":[],"length":0,"stats":{"Line":3524}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":51,"address":[],"length":0,"stats":{"Line":3521}},{"line":55,"address":[],"length":0,"stats":{"Line":1234}},{"line":56,"address":[],"length":0,"stats":{"Line":1235}},{"line":57,"address":[],"length":0,"stats":{"Line":2466}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":1233}},{"line":63,"address":[],"length":0,"stats":{"Line":261}},{"line":64,"address":[],"length":0,"stats":{"Line":262}},{"line":65,"address":[],"length":0,"stats":{"Line":520}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":260}},{"line":71,"address":[],"length":0,"stats":{"Line":2024}},{"line":72,"address":[],"length":0,"stats":{"Line":2025}},{"line":73,"address":[],"length":0,"stats":{"Line":4046}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":5}},{"line":89,"address":[],"length":0,"stats":{"Line":10}},{"line":95,"address":[],"length":0,"stats":{"Line":5}},{"line":96,"address":[],"length":0,"stats":{"Line":5}},{"line":97,"address":[],"length":0,"stats":{"Line":5}},{"line":98,"address":[],"length":0,"stats":{"Line":5}},{"line":99,"address":[],"length":0,"stats":{"Line":5}}],"covered":32,"coverable":41},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","parity","parity_req.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#![allow(unused_imports)]\nuse serde::{self, Deserialize, Serialize};\nuse smt_primitives::kv::{SMTKey, SMTValue};\nuse std::{fmt::Debug, marker::PhantomData};\nuse utoipa::{IntoParams, ToSchema, __dev::ComposeSchema};\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct ReqUpdate\u003cK, V\u003e {\n    pub prefix: u8,\n    #[serde(flatten)]\n    pub key: K,\n    #[serde(flatten)]\n    pub value: V,\n}\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct ReqByKey\u003cK\u003e {\n    pub prefix: u8,\n    #[serde(flatten)]\n    pub key: K,\n}\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct ReqByKVs\u003cKVPair\u003e {\n    pub prefix: u8,\n    #[serde(flatten)]\n    pub kv: KVPair,\n}\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct KVPair\u003cK, V\u003e {\n    #[serde(flatten)]\n    pub key: K,\n    #[serde(flatten)]\n    pub value: V,\n}\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct ReqByPrefix {\n    pub prefix: u8,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","parity","parity_store.rs"],"content":"use codec::{Decode, Encode};\nuse sparse_merkle_tree::{\n    error::Error,\n    traits::{StoreReadOps, StoreWriteOps, Value},\n    BranchKey, BranchNode, H256,\n};\nuse std::sync::Arc;\n\nuse crate::parity_db::ParityDb;\n\npub struct SMTParityStore {\n    inner: Arc\u003cParityDb\u003e,\n    col: u8,\n}\n\nimpl SMTParityStore {\n    pub fn new(db: Arc\u003cParityDb\u003e, col: u8) -\u003e Self {\n        SMTParityStore { inner: db, col }\n    }\n}\n\nimpl\u003cV\u003e StoreWriteOps\u003cV\u003e for SMTParityStore\nwhere\n    V: Value + Into\u003cVec\u003cu8\u003e\u003e,\n{\n    fn insert_branch(\u0026mut self, node_key: BranchKey, branch: BranchNode) -\u003e Result\u003c(), Error\u003e {\n        self.inner\n            .insert(self.col, \u0026node_key.encode(), \u0026branch.encode())\n            .map_err(|e| Error::Store(e.to_string()))\n    }\n\n    fn insert_leaf(\u0026mut self, leaf_key: H256, leaf: V) -\u003e Result\u003c(), Error\u003e {\n        self.inner\n            .insert(self.col, \u0026leaf_key.encode(), \u0026leaf.into())\n            .map_err(|e| Error::Store(e.to_string()))\n    }\n\n    fn remove_branch(\u0026mut self, node_key: \u0026BranchKey) -\u003e Result\u003c(), Error\u003e {\n        self.inner\n            .delete(self.col, \u0026node_key.encode())\n            .map_err(|e| Error::Store(e.to_string()))\n    }\n\n    fn remove_leaf(\u0026mut self, leaf_key: \u0026H256) -\u003e Result\u003c(), Error\u003e {\n        self.inner\n            .delete(self.col, \u0026leaf_key.encode())\n            .map_err(|e| Error::Store(e.to_string()))\n    }\n}\n\nimpl\u003cV\u003e StoreReadOps\u003cV\u003e for SMTParityStore\nwhere\n    V: Value + From\u003cVec\u003cu8\u003e\u003e,\n{\n    fn get_branch(\u0026self, branch_key: \u0026BranchKey) -\u003e Result\u003cOption\u003cBranchNode\u003e, Error\u003e {\n        self.inner\n            .get(self.col, \u0026branch_key.encode())\n            .map_err(|e| Error::Store(e.to_string()))?\n            .map(|v| BranchNode::decode(\u0026mut v.as_slice()).unwrap())\n            .map_or(Ok(None), |v| Ok(Some(v)))\n    }\n\n    fn get_leaf(\u0026self, leaf_key: \u0026H256) -\u003e Result\u003cOption\u003cV\u003e, Error\u003e {\n        self.inner\n            .get(self.col, \u0026leaf_key.encode())\n            .map_err(|e| Error::Store(e.to_string()))?\n            .map(|v| v.into())\n            .map_or(Ok(None), |v| Ok(Some(v)))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use smt_primitives::kv::{SMTValue};\n    use sparse_merkle_tree::{merge::MergeValue};\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_store() {\n        // \n        let temp_dir = tempdir().unwrap();\n        let db = ParityDb::new(temp_dir.path(), 2);\n        let mut store = SMTParityStore::new(Arc::new(db), 0);\n\n        // \n        let leaf1_key: H256 = [1u8; 32].to_vec().into();\n        let leaf1 = SMTValue {\n            nonce: 1,\n            balance: 99,\n        };\n        assert_eq!(store.get_leaf(\u0026leaf1_key).unwrap(), None::\u003cSMTValue\u003e);\n        store.insert_leaf(leaf1_key, leaf1.clone()).unwrap();\n        assert_eq!(store.get_leaf(\u0026leaf1_key).unwrap(), Some(leaf1));\n        \u003cSMTParityStore as StoreWriteOps\u003cSMTValue\u003e\u003e::remove_leaf(\u0026mut store, \u0026leaf1_key).unwrap();\n        assert_eq!(store.get_leaf(\u0026leaf1_key).unwrap(), None::\u003cSMTValue\u003e);\n\n        // \n        let node1_key: BranchKey = BranchKey::new(100, [2u8; 32].into());\n        let node1: BranchNode = BranchNode {\n            left: MergeValue::from_h256([3u8; 32].into()),\n            right: MergeValue::from_h256([4u8; 32].into()),\n        };\n        assert_eq!(\n            \u003cSMTParityStore as StoreReadOps\u003cSMTValue\u003e\u003e::get_branch(\u0026store, \u0026node1_key).unwrap(),\n            None::\u003cBranchNode\u003e\n        );\n        \u003cSMTParityStore as StoreWriteOps\u003cSMTValue\u003e\u003e::insert_branch(\n            \u0026mut store,\n            node1_key.clone(),\n            node1.clone(),\n        )\n        .unwrap();\n        assert_eq!(\n            \u003cSMTParityStore as StoreReadOps\u003cSMTValue\u003e\u003e::get_branch(\u0026store, \u0026node1_key).unwrap(),\n            Some(node1.clone())\n        );\n        \u003cSMTParityStore as StoreWriteOps\u003cSMTValue\u003e\u003e::remove_branch(\u0026mut store, \u0026node1_key).unwrap();\n        assert_eq!(\n            \u003cSMTParityStore as StoreReadOps\u003cSMTValue\u003e\u003e::get_branch(\u0026store, \u0026node1_key).unwrap(),\n            None::\u003cBranchNode\u003e\n        );\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":19}},{"line":26,"address":[],"length":0,"stats":{"Line":1025}},{"line":27,"address":[],"length":0,"stats":{"Line":1025}},{"line":28,"address":[],"length":0,"stats":{"Line":1025}},{"line":29,"address":[],"length":0,"stats":{"Line":2050}},{"line":32,"address":[],"length":0,"stats":{"Line":5}},{"line":33,"address":[],"length":0,"stats":{"Line":5}},{"line":34,"address":[],"length":0,"stats":{"Line":5}},{"line":35,"address":[],"length":0,"stats":{"Line":10}},{"line":38,"address":[],"length":0,"stats":{"Line":257}},{"line":39,"address":[],"length":0,"stats":{"Line":257}},{"line":40,"address":[],"length":0,"stats":{"Line":257}},{"line":41,"address":[],"length":0,"stats":{"Line":514}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":55,"address":[],"length":0,"stats":{"Line":1814}},{"line":56,"address":[],"length":0,"stats":{"Line":1814}},{"line":57,"address":[],"length":0,"stats":{"Line":1814}},{"line":58,"address":[],"length":0,"stats":{"Line":3628}},{"line":59,"address":[],"length":0,"stats":{"Line":2339}},{"line":60,"address":[],"length":0,"stats":{"Line":525}},{"line":63,"address":[],"length":0,"stats":{"Line":5}},{"line":64,"address":[],"length":0,"stats":{"Line":5}},{"line":65,"address":[],"length":0,"stats":{"Line":5}},{"line":66,"address":[],"length":0,"stats":{"Line":10}},{"line":67,"address":[],"length":0,"stats":{"Line":8}},{"line":68,"address":[],"length":0,"stats":{"Line":3}}],"covered":29,"coverable":29},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","rocks","apis.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Provide APIs, including database creation, creation of multiple Merkle trees, and Merkle tree-related operations.\n\n#![allow(dead_code)]\n#![allow(unused_imports)]\n\nuse crate::store::SMTStore;\nuse ethers::core::k256::sha2::digest::Key;\nuse kvdb_rocksdb::Database;\nuse smt_primitives::{\n    keccak_hasher::Keccak256Hasher,\n    verify::{verify as smt_verify, Proof},\n};\nuse sparse_merkle_tree::{\n    merge::MergeValue,\n    traits::{Hasher, Value},\n    SparseMerkleTree, H256,\n};\nuse std::{fmt::Debug, io, marker::PhantomData, path::Path};\n\nuse scale_info::TypeInfo;\nuse serde::{Deserialize, Serialize};\nuse serde_with::serde_as;\nuse sparse_merkle_tree::{\n    error::{Error, Result, Result as SMTResult},\n    CompiledMerkleProof,\n};\nuse std::{convert::AsRef, sync::Arc};\nuse utoipa::{ToSchema, __dev::ComposeSchema};\n// use crate::traits::MSS;\n\ntype MultiSMT\u003cV, H\u003e = SparseMerkleTree\u003cH, V, SMTStore\u003e;\n\n/// Multiple Merkle trees are stored in a KV database.\npub struct MultiSMTStore\u003cK, V, H\u003e {\n    store: Arc\u003cDatabase\u003e,\n    v: PhantomData\u003c(K, V, H)\u003e,\n}\n\nimpl\u003cK, V, H\u003e MultiSMTStore\u003cK, V, H\u003e\nwhere\n    K: Value\n        + Clone\n        + Serialize\n        + ToSchema\n        + Deserialize\u003c'static\u003e\n        + ComposeSchema\n        + Debug\n        + TypeInfo,\n    V: Default\n        + Value\n        + Into\u003cVec\u003cu8\u003e\u003e\n        + From\u003cVec\u003cu8\u003e\u003e\n        + ToSchema\n        + Serialize\n        + Deserialize\u003c'static\u003e\n        + ComposeSchema\n        + PartialEq\n        + Clone\n        + Debug\n        + TypeInfo,\n    H: Hasher + Default,\n{\n    /// Open the KV database, create it if it does not exist.\n    pub fn open\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e io::Result\u003cSelf\u003e {\n        let db = Database::open(\u0026Default::default(), path)?;\n        Ok(Self {\n            store: Arc::new(db),\n            v: PhantomData,\n        })\n    }\n\n    /// Create or open a new tree.\n    pub fn new_tree_with_store(\u0026self, prefix: String) -\u003e Result\u003cMultiSMT\u003cV, H\u003e\u003e {\n        let db = SMTStore::new(self.store.clone(), prefix);\n        MultiSMT::new_with_store(db)\n    }\n\n    /// Insert a value into a specific Merkle tree.\n    pub fn update(\u0026self, prefix: String, key: K, value: V) -\u003e SMTResult\u003cH256\u003e {\n        let mut tree = self.new_tree_with_store(prefix)?;\n        let h = tree.update(key.to_h256(), value)?;\n        Ok(*h)\n    }\n\n    /// Insert multiple values into a Merkle tree at once.\n    pub fn update_all(\u0026self, prefix: String, kvs: Vec\u003c(K, V)\u003e) -\u003e SMTResult\u003cH256\u003e {\n        let kvs = kvs\n            .into_iter()\n            .map(|(k, v)| Ok((k.to_h256(), v)))\n            .collect::\u003cResult\u003cVec\u003c(H256, V)\u003e\u003e\u003e()?;\n\n        let mut tree = self.new_tree_with_store(prefix)?;\n        let root = tree.update_all(kvs)?;\n        Ok(*root)\n    }\n\n    /// Get the root hash.\n    pub fn get_root(\u0026self, prefix: String) -\u003e Result\u003cH256\u003e {\n        let tree = self.new_tree_with_store(prefix)?;\n        Ok(*tree.root())\n    }\n\n    /// Get the value of a specific key in a particular tree.\n    pub fn get_value(\u0026self, prefix: String, key: K) -\u003e Result\u003cV\u003e {\n        let tree = self.new_tree_with_store(prefix)?;\n        let value = tree.get(\u0026key.to_h256())?;\n        Ok(value)\n    }\n\n    /// Get the Merkle proof.\n    pub fn get_merkle_proof(\u0026self, prefix: String, key: K) -\u003e Result\u003cProof\u003cK, V\u003e\u003e {\n        let tree = self.new_tree_with_store(prefix.clone())?;\n        let proof = tree.merkle_proof(vec![key.to_h256()])?;\n        let leaves_bitmap = proof.leaves_bitmap();\n        let siblings = proof.merkle_path();\n        let leave_bitmap = leaves_bitmap[0];\n        let value = self.get_value(prefix, key.clone())?;\n\n        Ok(Proof {\n            key: key.clone(),\n            value: value.clone(),\n            path: key.to_h256(),\n            value_hash: value.to_h256(),\n            root: *tree.root(),\n            leave_bitmap,\n            siblings: siblings.clone(),\n        })\n    }\n\n    /// Get the Merkle proof, the return value is `Vec\u003cu8\u003e`, which is not developer-friendly and may be inefficient for on-chain gas or functionality.\n    pub fn get_merkle_proof_old(\u0026self, prefix: String, keys: Vec\u003cK\u003e) -\u003e SMTResult\u003cVec\u003cu8\u003e\u003e {\n        let tree = self.new_tree_with_store(prefix)?;\n        let keys = keys\n            .into_iter()\n            .map(|k| Ok(k.to_h256()))\n            .collect::\u003cResult\u003cVec\u003cH256\u003e\u003e\u003e()?;\n\n        let proof = tree.merkle_proof(keys.clone())?;\n        let proof = proof.compile(keys)?;\n        Ok(proof.0)\n    }\n\n    /// Before data is updated, the future value of the root hash can be calculated in advance.\n    pub fn get_next_root(\u0026self, old_proof: Vec\u003cu8\u003e, next_kvs: Vec\u003c(K, V)\u003e) -\u003e Result\u003cH256\u003e {\n        let p = CompiledMerkleProof(old_proof);\n        let kvs = next_kvs\n            .into_iter()\n            .map(|(k, v)| Ok((k.to_h256(), v.to_h256())))\n            .collect::\u003cResult\u003cVec\u003c(H256, H256)\u003e\u003e\u003e()?;\n\n        let next_root = p.compute_root::\u003cH\u003e(kvs)?;\n        Ok(next_root)\n    }\n\n    /// Delete a specific Merkle tree.\n    pub fn clear(\u0026self, prefix: String) {\n        let mut tx = self.store.transaction();\n        tx.delete_prefix(Default::default(), prefix.as_bytes());\n        self.store.write(tx).unwrap();\n    }\n\n    /// Verify the Merkle proof.\n    pub fn verify(\u0026self, proof: Proof\u003cK, V\u003e) -\u003e bool {\n        let mut res = false;\n        if proof.value != V::default() {\n            res = smt_verify::\u003cH\u003e(\n                proof.path,\n                proof.value_hash,\n                proof.leave_bitmap,\n                proof.siblings,\n                proof.root,\n            )\n        }\n        res\n    }\n}\n\n#[cfg(test)]\npub mod test {\n    use super::*;\n    use actix_web::web;\n    use smt_primitives::kv::{SMTKey, SMTValue};\n    use std::sync::Mutex;\n    #[test]\n    fn test_apis() {\n        // multi_tree\n        let base_path = \"./apis_test_db\";\n        let multi_tree =\n            MultiSMTStore::\u003cSMTKey, SMTValue, Keccak256Hasher\u003e::open(Path::new(base_path)).unwrap();\n\n        let tree1: \u0026str = \"tree1\";\n        let tree2: \u0026str = \"tree2\";\n        multi_tree.clear(tree1.to_string());\n        multi_tree.clear(tree2.to_string());\n        multi_tree.new_tree_with_store(tree1.to_string()).unwrap();\n        multi_tree.new_tree_with_store(tree2.to_string()).unwrap();\n\n        // treeroot\n        assert_eq!(\n            multi_tree.get_root(tree1.to_string()).unwrap(),\n            H256::zero()\n        );\n        assert_eq!(\n            multi_tree.get_root(tree2.to_string()).unwrap(),\n            H256::zero()\n        );\n\n        // tree\n        let tree1_key1 = SMTKey {\n            address: \"1\".to_string(),\n        };\n        let tree1_value1: SMTValue = SMTValue {\n            nonce: 1,\n            balance: 99,\n        };\n        let tree1_key2 = SMTKey {\n            address: \"2\".to_string(),\n        };\n        let tree1_value2: SMTValue = SMTValue {\n            nonce: 2,\n            balance: 97,\n        };\n\n        assert_eq!(\n            multi_tree\n                .get_value(tree1.to_string(), tree1_key1.clone())\n                .unwrap(),\n            SMTValue::default()\n        );\n        assert_eq!(\n            multi_tree.get_root(tree1.to_string()).unwrap(),\n            H256::zero()\n        );\n        multi_tree\n            .update(tree1.to_string(), tree1_key1.clone(), tree1_value1.clone())\n            .unwrap();\n        assert_eq!(\n            multi_tree\n                .get_value(tree1.to_string(), tree1_key1.clone())\n                .unwrap(),\n            tree1_value1.clone()\n        );\n        let proof = multi_tree\n            .get_merkle_proof(tree1.to_string(), tree1_key1.clone())\n            .unwrap();\n        assert_eq!(multi_tree.verify(proof), true);\n        // remove\n        multi_tree\n            .update(tree1.to_string(), tree1_key1.clone(), SMTValue::default())\n            .unwrap();\n        assert_eq!(\n            multi_tree\n                .get_value(tree1.to_string(), tree1_key1.clone())\n                .unwrap(),\n            SMTValue::default()\n        );\n        assert_eq!(\n            multi_tree.get_root(tree1.to_string()).unwrap(),\n            H256::zero()\n        );\n        multi_tree\n            .update(tree1.to_string(), tree1_key1.clone(), tree1_value1.clone())\n            .unwrap();\n        let tree1_root1 = multi_tree.get_root(tree1.to_string()).unwrap();\n        let old_proof = multi_tree\n            .get_merkle_proof_old(tree1.to_string(), vec![tree1_key2.clone()])\n            .unwrap();\n        let _next_root = multi_tree\n            .get_next_root(\n                old_proof.clone(),\n                vec![(tree1_key2.clone(), tree1_value2.clone())],\n            )\n            .unwrap();\n        multi_tree\n            .update(tree1.to_string(), tree1_key2.clone(), tree1_value2.clone())\n            .unwrap();\n        let tree1_root2 = multi_tree.get_root(tree2.to_string()).unwrap();\n        assert_ne!(tree1_root1, tree1_root2);\n        assert_eq!(\n            multi_tree.get_root(tree2.to_string()).unwrap(),\n            H256::zero()\n        );\n\n        let tree2_root1 = multi_tree\n            .update(tree2.to_string(), tree1_key1.clone(), tree1_value1.clone())\n            .unwrap();\n        multi_tree\n            .update(tree2.to_string(), tree1_key2.clone(), tree1_value2.clone())\n            .unwrap();\n        assert_eq!(tree1_root1, tree2_root1);\n        assert_eq!(\n            multi_tree.get_root(tree1.to_string()).unwrap(),\n            multi_tree.get_root(tree2.to_string()).unwrap()\n        );\n        let tree2_proof1 = multi_tree\n            .get_merkle_proof(tree2.to_string(), tree1_key2.clone())\n            .unwrap();\n        assert_eq!(multi_tree.verify(tree2_proof1), true);\n\n        // clear\n        multi_tree.clear(tree1.to_string());\n        assert_eq!(\n            multi_tree\n                .get_value(tree1.to_string(), tree1_key2.clone())\n                .unwrap(),\n            SMTValue::default()\n        );\n        assert_eq!(\n            multi_tree\n                .get_value(tree2.to_string(), tree1_key2.clone())\n                .unwrap(),\n            tree1_value2.clone()\n        );\n        multi_tree.clear(tree2.to_string());\n        assert_eq!(\n            multi_tree\n                .get_value(tree2.to_string(), tree1_key2.clone())\n                .unwrap(),\n            SMTValue::default()\n        );\n        assert_eq!(\n            multi_tree\n                .get_value(tree2.to_string(), tree1_key1.clone())\n                .unwrap(),\n            SMTValue::default()\n        );\n        assert_eq!(\n            multi_tree.get_root(tree2.to_string()).unwrap(),\n            H256::zero()\n        );\n        let mut kvs: Vec\u003c(SMTKey, SMTValue)\u003e = vec![];\n\n        for i in 1..2 {\n            kvs.push((\n                SMTKey {\n                    address: i.to_string(),\n                },\n                SMTValue {\n                    nonce: i as u64,\n                    balance: i as u128,\n                },\n            ));\n        }\n\n        for kv in kvs.clone() {\n            multi_tree\n                .update(tree2.to_string(), kv.0.clone(), kv.1.clone())\n                .unwrap();\n            let p = multi_tree\n                .get_merkle_proof(tree2.to_string(), kv.0.clone())\n                .unwrap();\n            assert_eq!(multi_tree.verify(p), true);\n        }\n\n        multi_tree.clear(tree1.to_string());\n        for kv in kvs.clone() {\n            multi_tree\n                .update_all(tree1.to_string(), vec![(kv.0.clone(), kv.1.clone())])\n                .unwrap();\n            let p = multi_tree\n                .get_merkle_proof(tree1.to_string(), kv.0.clone())\n                .unwrap();\n            assert_eq!(multi_tree.verify(p), true);\n        }\n        assert_eq!(\n            multi_tree.get_root(tree1.to_string()).unwrap(),\n            multi_tree.get_root(tree2.to_string()).unwrap()\n        );\n        multi_tree\n            .update_all(tree1.to_string(), kvs.clone())\n            .unwrap();\n    }\n}\n","traces":[{"line":81,"address":[],"length":0,"stats":{"Line":3}},{"line":82,"address":[],"length":0,"stats":{"Line":6}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":345}},{"line":91,"address":[],"length":0,"stats":{"Line":345}},{"line":92,"address":[],"length":0,"stats":{"Line":345}},{"line":96,"address":[],"length":0,"stats":{"Line":109}},{"line":97,"address":[],"length":0,"stats":{"Line":218}},{"line":98,"address":[],"length":0,"stats":{"Line":109}},{"line":99,"address":[],"length":0,"stats":{"Line":109}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":4}},{"line":106,"address":[],"length":0,"stats":{"Line":6}},{"line":109,"address":[],"length":0,"stats":{"Line":2}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":12}},{"line":116,"address":[],"length":0,"stats":{"Line":24}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":113}},{"line":122,"address":[],"length":0,"stats":{"Line":226}},{"line":123,"address":[],"length":0,"stats":{"Line":113}},{"line":124,"address":[],"length":0,"stats":{"Line":113}},{"line":128,"address":[],"length":0,"stats":{"Line":106}},{"line":129,"address":[],"length":0,"stats":{"Line":212}},{"line":130,"address":[],"length":0,"stats":{"Line":106}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":106}},{"line":136,"address":[],"length":0,"stats":{"Line":106}},{"line":137,"address":[],"length":0,"stats":{"Line":106}},{"line":138,"address":[],"length":0,"stats":{"Line":106}},{"line":139,"address":[],"length":0,"stats":{"Line":106}},{"line":140,"address":[],"length":0,"stats":{"Line":106}},{"line":141,"address":[],"length":0,"stats":{"Line":106}},{"line":142,"address":[],"length":0,"stats":{"Line":106}},{"line":143,"address":[],"length":0,"stats":{"Line":106}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":3}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":7}},{"line":174,"address":[],"length":0,"stats":{"Line":7}},{"line":175,"address":[],"length":0,"stats":{"Line":7}},{"line":176,"address":[],"length":0,"stats":{"Line":7}},{"line":180,"address":[],"length":0,"stats":{"Line":4}},{"line":181,"address":[],"length":0,"stats":{"Line":4}},{"line":182,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":4}},{"line":184,"address":[],"length":0,"stats":{"Line":4}},{"line":185,"address":[],"length":0,"stats":{"Line":4}},{"line":186,"address":[],"length":0,"stats":{"Line":4}},{"line":187,"address":[],"length":0,"stats":{"Line":4}},{"line":188,"address":[],"length":0,"stats":{"Line":4}},{"line":191,"address":[],"length":0,"stats":{"Line":4}}],"covered":60,"coverable":67},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","rocks","mod.rs"],"content":"pub mod apis;\npub mod req;\npub mod store;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","rocks","req.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#![allow(unused_imports)]\nuse serde::{self, Deserialize, Serialize};\nuse smt_primitives::kv::{SMTKey, SMTValue};\nuse std::{fmt::Debug, marker::PhantomData};\nuse utoipa::{IntoParams, ToSchema, __dev::ComposeSchema};\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct ReqUpdate\u003cK, V\u003e {\n    pub prefix: String,\n    #[serde(flatten)]\n    pub key: K,\n    #[serde(flatten)]\n    pub value: V,\n}\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct ReqByKey\u003cK\u003e {\n    pub prefix: String,\n    #[serde(flatten)]\n    pub key: K,\n}\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct ReqByKVs\u003cKVPair\u003e {\n    pub prefix: String,\n    #[serde(flatten)]\n    pub kv: KVPair,\n}\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct KVPair\u003cK, V\u003e {\n    #[serde(flatten)]\n    pub key: K,\n    #[serde(flatten)]\n    pub value: V,\n}\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct ReqByPrefix {\n    pub prefix: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","rocks","store.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Store the Merkle tree data in a KVDB (Key-Value Database).\n\n#![allow(unused_imports)]\n#![allow(clippy::needless_lifetimes)]\nuse sparse_merkle_tree::{\n    error::Error,\n    traits::{StoreReadOps, StoreWriteOps, Value},\n    BranchKey, BranchNode, H256,\n};\nuse std::{marker::PhantomData, sync::Arc};\n\nuse codec::{Decode, Encode};\n// use rocksdb::{DBCommon, DB, DBWithThreadMode, OptimisticTransactionDB, ThreadMode};\nuse kvdb_rocksdb::Database;\n\npub struct SMTStore {\n    inner: Arc\u003cDatabase\u003e,\n    // col: u32, //  0\n    prefix: String,\n}\n\nimpl SMTStore {\n    pub fn new(db: Arc\u003cDatabase\u003e, prefix: impl Into\u003cString\u003e) -\u003e Self {\n        SMTStore {\n            inner: db,\n            // col,\n            prefix: prefix.into(),\n        }\n    }\n}\n\nimpl\u003cV\u003e StoreWriteOps\u003cV\u003e for SMTStore\nwhere\n    V: Value + Into\u003cVec\u003cu8\u003e\u003e,\n{\n    fn insert_branch(\u0026mut self, node_key: BranchKey, branch: BranchNode) -\u003e Result\u003c(), Error\u003e {\n        let mut tx = self.inner.transaction();\n        tx.put(\n            Default::default(),\n            \u0026[self.prefix.as_bytes(), \u0026node_key.encode()].concat(),\n            \u0026branch.encode(),\n        );\n        self.inner\n            .write(tx)\n            .map_err(|e| Error::Store(e.to_string()))\n    }\n\n    // \n    fn insert_leaf(\u0026mut self, leaf_key: H256, leaf: V) -\u003e Result\u003c(), Error\u003e {\n        let mut tx = self.inner.transaction();\n        tx.put(\n            Default::default(),\n            \u0026[self.prefix.as_bytes(), \u0026leaf_key.encode()].concat(),\n            \u0026leaf.into(),\n        );\n        self.inner\n            .write(tx)\n            .map_err(|e| Error::Store(e.to_string()))\n    }\n\n    fn remove_branch(\u0026mut self, node_key: \u0026BranchKey) -\u003e Result\u003c(), Error\u003e {\n        let mut tx = self.inner.transaction();\n        tx.delete(\n            Default::default(),\n            \u0026[self.prefix.as_bytes(), \u0026node_key.encode()].concat(),\n        );\n        self.inner\n            .write(tx)\n            .map_err(|e| Error::Store(e.to_string()))\n    }\n\n    fn remove_leaf(\u0026mut self, leaf_key: \u0026H256) -\u003e Result\u003c(), Error\u003e {\n        let mut tx = self.inner.transaction();\n        tx.delete(\n            Default::default(),\n            \u0026[self.prefix.as_bytes(), \u0026leaf_key.encode()].concat(),\n        );\n        self.inner\n            .write(tx)\n            .map_err(|e| Error::Store(e.to_string()))\n    }\n}\n\nimpl\u003cV\u003e StoreReadOps\u003cV\u003e for SMTStore\nwhere\n    V: Value + From\u003cVec\u003cu8\u003e\u003e,\n{\n    fn get_branch(\u0026self, branch_key: \u0026BranchKey) -\u003e Result\u003cOption\u003cBranchNode\u003e, Error\u003e {\n        self.inner\n            .get(\n                Default::default(),\n                \u0026[self.prefix.as_bytes(), \u0026branch_key.encode()].concat(),\n            )\n            .map(|s| s.map(|v| BranchNode::decode(\u0026mut v.as_slice()).unwrap()))\n            .map_err(|e| Error::Store(e.to_string()))\n    }\n\n    fn get_leaf(\u0026self, leaf_key: \u0026H256) -\u003e Result\u003cOption\u003cV\u003e, Error\u003e {\n        self.inner\n            .get(\n                Default::default(),\n                \u0026[self.prefix.as_bytes(), leaf_key.as_slice()].concat(),\n            )\n            .map(|s| s.map(|v| v.into()))\n            .map_err(|e| Error::Store(e.to_string()))\n    }\n}\n\n#[cfg(test)]\npub mod test {\n    use super::*;\n    use smt_primitives::kv::{SMTKey, SMTValue};\n    use sparse_merkle_tree::{merge::MergeValue, traits::Value};\n    use std::path::Path;\n\n    #[test]\n    fn test_store() {\n        // \n        let base_path = \"./test_store_db\";\n        let db = Database::open(\u0026Default::default(), Path::new(base_path)).unwrap();\n        let mut store = SMTStore::new(Arc::new(db), \"test\");\n\n        //\n        let leaf1_key: H256 = [1u8; 32].to_vec().into();\n        let leaf1 = SMTValue {\n            nonce: 1,\n            balance: 99,\n        };\n        assert_eq!(store.get_leaf(\u0026leaf1_key).unwrap(), None::\u003cSMTValue\u003e);\n        store.insert_leaf(leaf1_key, leaf1.clone()).unwrap();\n        assert_eq!(store.get_leaf(\u0026leaf1_key).unwrap(), Some(leaf1));\n        \u003cSMTStore as StoreWriteOps\u003cSMTValue\u003e\u003e::remove_leaf(\u0026mut store, \u0026leaf1_key).unwrap();\n        assert_eq!(store.get_leaf(\u0026leaf1_key).unwrap(), None::\u003cSMTValue\u003e);\n\n        // \n        let node1_key: BranchKey = BranchKey::new(100, [2u8; 32].into());\n        let node1: BranchNode = BranchNode {\n            left: MergeValue::from_h256([3u8; 32].into()),\n            right: MergeValue::from_h256([4u8; 32].into()),\n        };\n        assert_eq!(\n            \u003cSMTStore as StoreReadOps\u003cSMTValue\u003e\u003e::get_branch(\u0026store, \u0026node1_key).unwrap(),\n            None::\u003cBranchNode\u003e\n        );\n        \u003cSMTStore as StoreWriteOps\u003cSMTValue\u003e\u003e::insert_branch(\n            \u0026mut store,\n            node1_key.clone(),\n            node1.clone(),\n        )\n        .unwrap();\n        assert_eq!(\n            \u003cSMTStore as StoreReadOps\u003cSMTValue\u003e\u003e::get_branch(\u0026store, \u0026node1_key).unwrap(),\n            Some(node1.clone())\n        );\n        \u003cSMTStore as StoreWriteOps\u003cSMTValue\u003e\u003e::remove_branch(\u0026mut store, \u0026node1_key.clone())\n            .unwrap();\n        assert_eq!(\n            \u003cSMTStore as StoreReadOps\u003cSMTValue\u003e\u003e::get_branch(\u0026store, \u0026node1_key).unwrap(),\n            None::\u003cBranchNode\u003e\n        );\n    }\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":346}},{"line":44,"address":[],"length":0,"stats":{"Line":346}},{"line":53,"address":[],"length":0,"stats":{"Line":27649}},{"line":54,"address":[],"length":0,"stats":{"Line":27649}},{"line":55,"address":[],"length":0,"stats":{"Line":27649}},{"line":56,"address":[],"length":0,"stats":{"Line":27649}},{"line":57,"address":[],"length":0,"stats":{"Line":27649}},{"line":58,"address":[],"length":0,"stats":{"Line":27649}},{"line":60,"address":[],"length":0,"stats":{"Line":27649}},{"line":61,"address":[],"length":0,"stats":{"Line":27649}},{"line":62,"address":[],"length":0,"stats":{"Line":55298}},{"line":66,"address":[],"length":0,"stats":{"Line":109}},{"line":67,"address":[],"length":0,"stats":{"Line":109}},{"line":68,"address":[],"length":0,"stats":{"Line":109}},{"line":69,"address":[],"length":0,"stats":{"Line":109}},{"line":70,"address":[],"length":0,"stats":{"Line":109}},{"line":71,"address":[],"length":0,"stats":{"Line":109}},{"line":73,"address":[],"length":0,"stats":{"Line":109}},{"line":74,"address":[],"length":0,"stats":{"Line":109}},{"line":75,"address":[],"length":0,"stats":{"Line":218}},{"line":78,"address":[],"length":0,"stats":{"Line":769}},{"line":79,"address":[],"length":0,"stats":{"Line":769}},{"line":80,"address":[],"length":0,"stats":{"Line":769}},{"line":81,"address":[],"length":0,"stats":{"Line":769}},{"line":82,"address":[],"length":0,"stats":{"Line":769}},{"line":84,"address":[],"length":0,"stats":{"Line":769}},{"line":85,"address":[],"length":0,"stats":{"Line":769}},{"line":86,"address":[],"length":0,"stats":{"Line":1538}},{"line":89,"address":[],"length":0,"stats":{"Line":4}},{"line":90,"address":[],"length":0,"stats":{"Line":4}},{"line":91,"address":[],"length":0,"stats":{"Line":4}},{"line":92,"address":[],"length":0,"stats":{"Line":4}},{"line":93,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":4}},{"line":97,"address":[],"length":0,"stats":{"Line":8}},{"line":105,"address":[],"length":0,"stats":{"Line":56857}},{"line":106,"address":[],"length":0,"stats":{"Line":56857}},{"line":108,"address":[],"length":0,"stats":{"Line":56857}},{"line":109,"address":[],"length":0,"stats":{"Line":56857}},{"line":111,"address":[],"length":0,"stats":{"Line":256258}},{"line":112,"address":[],"length":0,"stats":{"Line":113714}},{"line":115,"address":[],"length":0,"stats":{"Line":111}},{"line":116,"address":[],"length":0,"stats":{"Line":111}},{"line":118,"address":[],"length":0,"stats":{"Line":111}},{"line":119,"address":[],"length":0,"stats":{"Line":111}},{"line":121,"address":[],"length":0,"stats":{"Line":551}},{"line":122,"address":[],"length":0,"stats":{"Line":222}}],"covered":48,"coverable":48},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","traits.rs"],"content":"use scale_info::TypeInfo;\nuse serde::{Deserialize, Serialize};\nuse smt_primitives::verify::Proof;\nuse sparse_merkle_tree::{\n    error::{Error, Result as SMTResult},\n    traits::{Hasher, Value},\n    H256,\n};\nuse std::{fmt::Debug, path::Path};\nuse utoipa::{ToSchema, __dev::ComposeSchema};\n\n/// Multi Sparse Merkle Tree Store trait\n/// Defines common operations for managing multiple Sparse Merkle Trees in a single store\npub trait MSS\u003cT, K, V, H\u003e: Sized\nwhere\n    T: AsRef\u003c[u8]\u003e, // tree_id \n    K: Value + Clone + Serialize + ToSchema + Deserialize\u003c'static\u003e + ComposeSchema + Debug + TypeInfo,\n    V: Default\n        + Value\n        + Into\u003cVec\u003cu8\u003e\u003e\n        + From\u003cVec\u003cu8\u003e\u003e\n        + ToSchema\n        + Serialize\n        + Deserialize\u003c'static\u003e\n        + ComposeSchema\n        + PartialEq\n        + Clone\n        + Debug\n        + TypeInfo,\n    H: Hasher + Default,\n{\n    /// Associated type for the tree implementation\n    type Tree;\n\n    /// Open the database, create it if it does not exist\n    fn open\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e std::io::Result\u003cSelf\u003e;\n\n    /// Create or open a new tree\n    fn new_tree_with_store\u003c'a\u003e(\u0026'a self, tree_id: T) -\u003e Result\u003cSelf::Tree, Error\u003e;\n\n    /// Insert a value into a specific Merkle tree\n    fn update(\u0026self, tree_id: T, key: K, value: V) -\u003e SMTResult\u003cH256\u003e;\n\n    /// Insert multiple values into a Merkle tree at once\n    fn update_all(\u0026self, tree_id: T, kvs: Vec\u003c(K, V)\u003e) -\u003e SMTResult\u003cH256\u003e;\n\n    /// Get the root hash of a specific tree\n    fn get_root(\u0026self, tree_id: T) -\u003e Result\u003cH256, Error\u003e;\n\n    /// Get the value of a specific key in a particular tree\n    fn get_value(\u0026self, tree_id: T, key: K) -\u003e Result\u003cV, Error\u003e;\n\n    /// Get the Merkle proof for a specific key\n    fn get_merkle_proof(\u0026self, tree_id: T, key: K) -\u003e Result\u003cProof\u003cK, V\u003e, Error\u003e;\n\n    /// Get the Merkle proof in raw bytes format\n    fn get_merkle_proof_old(\u0026self, tree_id: T, keys: Vec\u003cK\u003e) -\u003e SMTResult\u003cVec\u003cu8\u003e\u003e;\n\n    /// Calculate the future root hash before updating data\n    fn get_next_root(\u0026self, old_proof: Vec\u003cu8\u003e, next_kvs: Vec\u003c(K, V)\u003e) -\u003e Result\u003cH256, Error\u003e;\n\n    /// Delete/clear a specific Merkle tree\n    fn clear(\u0026self, tree_id: T) -\u003e Result\u003c(), Error\u003e;\n\n    /// Verify a Merkle proof\n    fn verify(\u0026self, proof: Proof\u003cK, V\u003e) -\u003e bool;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","ink-contract","SMT","lib.rs"],"content":"#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n#![allow(unexpected_cfgs)]\n\n#[ink::contract]\nmod smt {\n    use smt_primitives::{\n        keccak_hasher::Keccak256Hasher,\n        kv::{SMTKey, SMTValue},\n        sparse_merkle_tree::H256,\n        verify::{verify as smt_verify, Proof},\n    };\n\n    /// Defines the storage of your contract.\n    /// Add new fields to the below struct in order\n    /// to add new static storage fields to your contract.\n    #[ink(storage)]\n    #[derive(Default)]\n    pub struct Smt;\n\n    #[ink(event)]\n    pub struct SMTVerify {\n        who: AccountId,\n        #[ink(topic)]\n        path: H256,\n        #[ink(topic)]\n        root: H256,\n    }\n\n    pub type Result\u003cT\u003e = core::result::Result\u003cT, Error\u003e;\n\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        SMTVerifyFaild,\n    }\n\n    impl Smt {\n        #[ink(constructor)]\n        pub fn new() -\u003e Self {\n            Self::default()\n        }\n\n        #[ink(message)]\n        pub fn smt_verify(\u0026self, proof: Proof\u003cSMTKey, SMTValue\u003e) -\u003e Result\u003c()\u003e {\n            self.do_verify(proof)\n        }\n\n        fn do_verify(\u0026self, proof: Proof\u003cSMTKey, SMTValue\u003e) -\u003e Result\u003c()\u003e {\n            let from = self.env().caller();\n            if !smt_verify::\u003cKeccak256Hasher\u003e(\n                proof.path,\n                proof.value_hash,\n                proof.leave_bitmap,\n                proof.siblings,\n                proof.root,\n            ) {\n                return Err(Error::SMTVerifyFaild);\n            }\n            Self::env().emit_event(SMTVerify {\n                who: from,\n                path: proof.path,\n                root: proof.root,\n            });\n            Ok(())\n        }\n    }\n\n    /// Unit tests in Rust are normally defined within such a `#[cfg(test)]`\n    /// module and test functions are marked with a `#[test]` attribute.\n    /// The below code is technically just normal Rust code.\n    #[cfg(test)]\n    mod tests {\n        #![allow(unused_imports)]\n        /// Imports all the definitions from the outer scope so we can use them here.\n        use super::*;\n        use smt_backend_lib::apis::MultiSMTStore;\n        use smt_primitives::{\n            keccak_hasher::Keccak256Hasher,\n            kv::{SMTKey, SMTValue},\n            verify::Proof,\n        };\n        use std::path::Path;\n\n        pub fn creat_db_and_get_proof(size: u8) -\u003e Vec\u003cProof\u003cSMTKey, SMTValue\u003e\u003e {\n            let base_path = \"./smt_ink_test_db\";\n            let multi_tree =\n                MultiSMTStore::\u003cSMTKey, SMTValue, Keccak256Hasher\u003e::open(Path::new(base_path))\n                    .unwrap();\n            // tree\n            let tree = \"tree1\";\n            multi_tree.clear(tree.to_string());\n            let mut kvs: Vec\u003c(SMTKey, SMTValue)\u003e = vec![];\n\n            for i in 0..size {\n                kvs.push((\n                    SMTKey {\n                        address: i.to_string(),\n                    },\n                    SMTValue {\n                        nonce: i as u64,\n                        balance: i as u128,\n                    },\n                ));\n            }\n\n            for kv in kvs.clone() {\n                multi_tree\n                    .update(tree.to_string(), kv.0.clone(), kv.1.clone())\n                    .unwrap();\n            }\n\n            let mut proofs: Vec\u003cProof\u003cSMTKey, SMTValue\u003e\u003e = vec![];\n            for kv in kvs.clone() {\n                let proof = multi_tree\n                    .get_merkle_proof(tree.to_string(), kv.0.clone())\n                    .unwrap();\n                proofs.push(proof);\n            }\n\n            proofs\n        }\n\n        #[ink::test]\n        fn smt_verify_works() {\n            let smt = Smt::new();\n            let proofs = creat_db_and_get_proof(2);\n            assert_ne!(smt.smt_verify(proofs[0].clone()), Ok(()));\n            proofs[1..].iter().for_each(|p| {\n                // ;\n                assert_eq!(smt.smt_verify(p.clone()), Ok(()));\n            });\n        }\n    }\n\n    /// This is how you'd write end-to-end (E2E) or integration tests for ink! contracts.\n    ///\n    /// When running these you need to make sure that you:\n    /// - Compile the tests with the `e2e-tests` feature flag enabled (`--features e2e-tests`)\n    /// - Are running a Substrate node which contains `pallet-contracts` in the background\n    #[cfg(all(test, feature = \"e2e-tests\"))]\n    mod e2e_tests {\n        /// Imports all the definitions from the outer scope so we can use them here.\n        use super::*;\n        use crate::smt::tests::creat_db_and_get_proof;\n\n        /// A helper function used for calling contract messages.\n        use ink_e2e::ContractsBackend;\n\n        /// The End-to-End test `Result` type.\n        type E2EResult\u003cT\u003e = std::result::Result\u003cT, Box\u003cdyn std::error::Error\u003e\u003e;\n\n        #[ink_e2e::test]\n        async fn it_works(mut client: ink_e2e::Client\u003cC, E\u003e) -\u003e E2EResult\u003c()\u003e {\n            let mut constructor = SmtRef::new();\n            let contract = client\n                .instantiate(\"smt\", \u0026ink_e2e::bob(), \u0026mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = contract.call_builder::\u003cSmt\u003e();\n\n            let proofs = creat_db_and_get_proof(2);\n\n            let verify = call_builder.smt_verify(proofs[1].clone());\n            let _flip_result = client\n                .call(\u0026ink_e2e::bob(), \u0026verify)\n                .submit()\n                .await\n                .expect(\"verify failed\");\n            // \n\n            Ok(())\n        }\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":64,"address":[],"length":0,"stats":{"Line":1}}],"covered":16,"coverable":16},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","pallet","SMT","src","benchmarking.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#![cfg(feature = \"runtime-benchmarks\")]\nuse super::*;\n\n#[allow(unused)]\nuse crate::Pallet as Template;\nuse frame_benchmarking::v2::*;\nuse frame_system::RawOrigin;\nuse mock::creat_db_and_get_proof;\nuse primitives::kv::{SMTKey, SMTValue};\n\n#[benchmarks]\nmod benchmarks {\n    use super::*;\n\n    #[benchmark]\n    fn smt_verify() {\n        let proof = creat_db_and_get_proof(3);\n        let caller: T::AccountId = whitelisted_caller();\n        #[extrinsic_call]\n        smt_verify(RawOrigin::Signed(caller), p);\n    }\n\n    impl_benchmark_test_suite!(Template, crate::mock::new_test_ext(), crate::mock::Test);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","pallet","SMT","src","lib.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! This template will be responsible for verifying Merkle tree proofs on-chain. We follow the principle of minimizing on-chain computation and storage resources as much as possible, providing only the verification method.  \n//! The advantage of Merkle trees lies precisely in this approach.  \n//! The Merkle tree proof is provided by the `merkle_proof` API from the SMT backend.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\npub use pallet::*;\n\n#[cfg(test)]\nmod mock;\n\n#[cfg(test)]\nmod tests;\n\npub mod weights;\n\n#[cfg(feature = \"runtime-benchmarks\")]\nmod benchmarking;\n\n#[frame_support::pallet]\npub mod pallet {\n    use crate::weights::WeightInfo;\n    use core::convert::TryInto;\n    use frame_support::{dispatch::DispatchResultWithPostInfo, pallet_prelude::*};\n    use frame_system::pallet_prelude::*;\n    use primitives::{\n        sparse_merkle_tree::{\n            traits::{Hasher, Value},\n            H256,\n        },\n        verify::{self, Proof},\n    };\n    use scale_info::prelude::fmt::Debug;\n\n    /// Configure the pallet by specifying the parameters and types on which it depends.\n    #[pallet::config]\n    pub trait Config: frame_system::Config {\n        /// Because this pallet emits events, it depends on the runtime's definition of an event.\n        type RuntimeEvent: From\u003cEvent\u003cSelf\u003e\u003e + IsType\u003c\u003cSelf as frame_system::Config\u003e::RuntimeEvent\u003e;\n        /// A type representing the weights required by the dispatchables of this pallet.\n        type WeightInfo: crate::weights::WeightInfo;\n        /// The data type of the Key in the KVDB.\n        type SMTKey: Value + Default + Debug + Clone + TypeInfo + Encode + Decode + PartialEq;\n        /// The data type of the value in the KVDB.\n        type SMTValue: Value + Default + Debug + Clone + TypeInfo + Encode + Decode + PartialEq;\n        /// The hash algorithm chosen for this Merkle tree off-chain.\n        type SMTHasher: Hasher + Default;\n    }\n\n    #[pallet::pallet]\n    pub struct Pallet\u003cT\u003e(_);\n\n    // Pallets use events to inform users when important changes are made.\n    // https://docs.substrate.io/v3/runtime/events-and-errors\n    #[pallet::event]\n    #[pallet::generate_deposit(pub(super) fn deposit_event)]\n    pub enum Event\u003cT: Config\u003e {\n        /// Merkle proof verification passed.\n        SMTVerify {\n            /// Who submitted the proof to the blockchain.\n            account: T::AccountId,\n            /// The path of the leaf being proven.\n            path: H256,\n            /// root hash\n            root: H256,\n        },\n    }\n\n    // Errors inform users that something went wrong.\n    #[pallet::error]\n    pub enum Error\u003cT\u003e {\n        /// Merkle proof verification failed.\n        SMTVerifyFaild,\n    }\n\n    #[pallet::hooks]\n    impl\u003cT: Config\u003e Hooks\u003cBlockNumberFor\u003cT\u003e\u003e for Pallet\u003cT\u003e {}\n\n    // Dispatchable functions allows users to interact with the pallet and invoke state changes.\n    // These functions materialize as \"extrinsics\", which are often compared to transactions.\n    // Dispatchable functions must be annotated with a weight and must return a DispatchResult.\n    #[pallet::call]\n    impl\u003cT: Config\u003e Pallet\u003cT\u003e {\n\n        /// Verify the Merkle proof provided off-chain.\n        /// \n        #[pallet::call_index(0)]\n        #[pallet::weight(T::WeightInfo::smt_verify().saturating_mul(1_u64 + proof.siblings.len() as u64))]\n        pub fn smt_verify(\n            origin: OriginFor\u003cT\u003e,\n            proof: verify::Proof\u003cT::SMTKey, T::SMTValue\u003e,\n        ) -\u003e DispatchResultWithPostInfo {\n            let who = ensure_signed(origin)?;\n            Self::do_verify(who, proof)\n        }\n    }\n\n    impl\u003cT: Config\u003e Pallet\u003cT\u003e {\n        pub fn do_verify(\n            who: T::AccountId,\n            proof: Proof\u003cT::SMTKey, T::SMTValue\u003e,\n        ) -\u003e DispatchResultWithPostInfo {\n            ensure!(\n                verify::verify::\u003cT::SMTHasher\u003e(\n                    proof.path,\n                    proof.value_hash,\n                    proof.leave_bitmap,\n                    proof.siblings,\n                    proof.root,\n                ),\n                Error::\u003cT\u003e::SMTVerifyFaild\n            );\n            Self::deposit_event(Event::\u003cT\u003e::SMTVerify {\n                account: who,\n                path: proof.path,\n                root: proof.root,\n            });\n\n            Ok(().into())\n        }\n    }\n}\n","traces":[{"line":110,"address":[],"length":0,"stats":{"Line":200}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":100}},{"line":120,"address":[],"length":0,"stats":{"Line":100}},{"line":121,"address":[],"length":0,"stats":{"Line":100}},{"line":122,"address":[],"length":0,"stats":{"Line":100}},{"line":123,"address":[],"length":0,"stats":{"Line":100}},{"line":124,"address":[],"length":0,"stats":{"Line":100}},{"line":125,"address":[],"length":0,"stats":{"Line":100}},{"line":126,"address":[],"length":0,"stats":{"Line":100}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[],"length":0,"stats":{"Line":99}},{"line":131,"address":[],"length":0,"stats":{"Line":99}},{"line":132,"address":[],"length":0,"stats":{"Line":99}},{"line":133,"address":[],"length":0,"stats":{"Line":99}},{"line":136,"address":[],"length":0,"stats":{"Line":99}}],"covered":15,"coverable":16},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","pallet","SMT","src","mock.rs"],"content":"use frame_support::{derive_impl, parameter_types, traits::Everything};\nuse frame_system as system;\nuse primitives::{\n    keccak_hasher::Keccak256Hasher,\n    kv::{SMTKey, SMTValue},\n    verify::Proof,\n};\nuse smt_backend_lib::apis::MultiSMTStore;\nuse sp_core::H256;\nuse sp_runtime::{\n    traits::{BlakeTwo256, IdentityLookup},\n    BuildStorage,\n};\nuse std::path::Path;\ntype Block = frame_system::mocking::MockBlock\u003cTest\u003e;\n\npub fn creat_db_and_get_proof(size: u8) -\u003e Vec\u003cProof\u003cSMTKey, SMTValue\u003e\u003e {\n    let base_path = \"./smt_mock_db\";\n    let multi_tree =\n        MultiSMTStore::\u003cSMTKey, SMTValue, Keccak256Hasher\u003e::open(Path::new(base_path)).unwrap();\n    // tree\n    let tree = \"tree1\";\n    multi_tree.clear(tree.to_string());\n    let mut kvs: Vec\u003c(SMTKey, SMTValue)\u003e = vec![];\n\n    for i in 0..size {\n        kvs.push((\n            SMTKey {\n                address: i.to_string(),\n            },\n            SMTValue {\n                nonce: i as u64,\n                balance: i as u128,\n            },\n        ));\n    }\n\n    for kv in kvs.clone() {\n        multi_tree\n            .update(tree.to_string(), kv.0.clone(), kv.1.clone())\n            .unwrap();\n    }\n\n    let mut proofs: Vec\u003cProof\u003cSMTKey, SMTValue\u003e\u003e = vec![];\n    for kv in kvs.clone() {\n        let proof = multi_tree\n            .get_merkle_proof(tree.to_string(), kv.0.clone())\n            .unwrap();\n        proofs.push(proof);\n    }\n\n    proofs\n}\n\n// Configure a mock runtime to test the pallet.\nframe_support::construct_runtime!(\n    pub enum Test\n    {\n        System: frame_system::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e},\n        TemplateModule: crate::{Pallet, Call, Storage, Event\u003cT\u003e},\n    }\n);\n\nparameter_types! {\n    pub const SS58Prefix: u8 = 42;\n}\n\n#[derive_impl(frame_system::config_preludes::TestDefaultConfig)]\nimpl system::Config for Test {\n    type BaseCallFilter = Everything;\n    type BlockWeights = ();\n    type BlockLength = ();\n    type DbWeight = ();\n    type RuntimeOrigin = RuntimeOrigin;\n    type RuntimeCall = RuntimeCall;\n    type Nonce = u64;\n    type Hash = H256;\n    type Hashing = BlakeTwo256;\n    type AccountId = u64;\n    type Lookup = IdentityLookup\u003cSelf::AccountId\u003e;\n    type Block = Block;\n    type RuntimeEvent = RuntimeEvent;\n    type Version = ();\n    type PalletInfo = PalletInfo;\n    type AccountData = ();\n    type OnNewAccount = ();\n    type OnKilledAccount = ();\n    type SystemWeightInfo = ();\n    type SS58Prefix = SS58Prefix;\n    type OnSetCode = ();\n    type MaxConsumers = frame_support::traits::ConstU32\u003c16\u003e;\n}\n\nimpl crate::Config for Test {\n    type RuntimeEvent = RuntimeEvent;\n    type WeightInfo = ();\n    type SMTHasher = Keccak256Hasher;\n    type SMTKey = SMTKey;\n    type SMTValue = SMTValue;\n}\n\n// Build genesis storage according to the mock runtime.\npub fn new_test_ext() -\u003e sp_io::TestExternalities {\n    system::GenesisConfig::\u003cTest\u003e::default()\n        .build_storage()\n        .unwrap()\n        .into()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","pallet","SMT","src","tests.rs"],"content":"#![allow(unused_imports)]\nuse crate::{mock::*, Error};\nuse frame_support::{assert_err, assert_noop, assert_ok};\nuse primitives::verify::Proof;\n\n#[test]\nfn it_works_for_smt_verify() {\n    new_test_ext().execute_with(|| {\n        // Dispatch a signed extrinsic.\n        let who = RuntimeOrigin::signed(1);\n        let proofs = creat_db_and_get_proof(100 as u8);\n        assert_err!(\n            TemplateModule::smt_verify(who.clone(), proofs[0].clone()),\n            Error::\u003cTest\u003e::SMTVerifyFaild\n        );\n        proofs[1..].iter().for_each(|p| {\n            assert_ok!(TemplateModule::smt_verify(who.clone(), p.clone()));\n        });\n    });\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","pallet","SMT","src","weights.rs"],"content":"\n//! Autogenerated weights for pallet_template\n//!\n//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev\n//! DATE: 2023-04-06, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`\n//! WORST CASE MAP SIZE: `1000000`\n//! HOSTNAME: `Alexs-MacBook-Pro-2.local`, CPU: `\u003cUNKNOWN\u003e`\n//! EXECUTION: Some(Wasm), WASM-EXECUTION: Compiled, CHAIN: Some(\"dev\"), DB CACHE: 1024\n\n// Executed Command:\n// ../../target/release/node-template\n// benchmark\n// pallet\n// --chain\n// dev\n// --pallet\n// pallet_template\n// --extrinsic\n// *\n// --steps=50\n// --repeat=20\n// --wasm-execution=compiled\n// --output\n// pallets/template/src/weights.rs\n// --template\n// ../../.maintain/frame-weight-template.hbs\n\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused_parens)]\n#![allow(unused_imports)]\n\nuse frame_support::{traits::Get, weights::{Weight, constants::RocksDbWeight}};\nuse core::marker::PhantomData;\n\n/// Weight functions needed for pallet_template.\npub trait WeightInfo {\n\tfn smt_verify() -\u003e Weight;\n}\n\n/// Weights for pallet_template using the Substrate node and recommended hardware.\npub struct SubstrateWeight\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: frame_system::Config\u003e WeightInfo for SubstrateWeight\u003cT\u003e {\n\n\t/// Storage: TemplateModule Something (r:1 w:1)\n\t/// Proof: TemplateModule Something (max_values: Some(1), max_size: Some(4), added: 499, mode: MaxEncodedLen)\n\tfn smt_verify() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `32`\n\t\t//  Estimated: `1489`\n\t\t// Minimum execution time: 6_000_000 picoseconds.\n\t\tWeight::from_parts(6_000_000, 1489)\n\t\t\t.saturating_add(T::DbWeight::get().reads(1_u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1_u64))\n\t}\n}\n\n// For backwards compatibility and tests\nimpl WeightInfo for () {\n\t\n\t/// Storage: TemplateModule Something (r:1 w:1)\n\t/// Proof: TemplateModule Something (max_values: Some(1), max_size: Some(4), added: 499, mode: MaxEncodedLen)\n\tfn smt_verify() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `32`\n\t\t//  Estimated: `1489`\n\t\t// Minimum execution time: 6_000_000 picoseconds.\n\t\tWeight::from_parts(6_000_000, 1489)\n\t\t\t.saturating_add(RocksDbWeight::get().reads(1_u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(1_u64))\n\t}\n}","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","primitives","src","keccak_hasher.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Typically, the computation of the Merkle tree root, as well as proof generation and verification, relies on a specific hash algorithm.\n//! This algorithm is responsible for transforming complex data structures encountered along the path into a hash value. In SMT, hash computations are needed for data types like `[u8; 32]` and `u8`.\n//! In this project, Keccak256 will be used by default, primarily considering Ethereum compatibility. However, you can choose other hash algorithms based on the specific requirements of your project.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse sha3::{Digest, Keccak256};\nuse sparse_merkle_tree::{traits::Hasher, H256};\n\n/// Choose the Keccak256 algorithm to compute the hash values for `[u8; 32]` and `u8` data.\npub struct Keccak256Hasher(Keccak256);\n\nimpl Default for Keccak256Hasher {\n    fn default() -\u003e Self {\n        Keccak256Hasher(Keccak256::new())\n    }\n}\n\nimpl Hasher for Keccak256Hasher {\n    fn write_h256(\u0026mut self, h: \u0026H256) {\n        self.0.update(h.as_ref());\n    }\n    fn write_byte(\u0026mut self, b: u8) {\n        self.0.update(\u0026[b][..])\n    }\n\n    fn finish(self) -\u003e H256 {\n        let a: [u8; 32] = self.0.finalize().into();\n        a.into()\n    }\n}\n\n#[cfg(test)]\npub mod test {\n    use super::*;\n    use ethers::utils::keccak256;\n    #[test]\n    fn test_hasher() {\n        let mut hasher = Keccak256Hasher::default();\n        hasher.write_h256(\u0026H256::default());\n        let h1 = hasher.finish();\n\n        let h11: H256 = keccak256(\u0026H256::default()).into();\n        assert_eq!(h1, h11);\n\n        let b: H256 = [1u8; 32].to_vec().into();\n        let mut hasher1 = Keccak256Hasher::default();\n        hasher1.write_h256(\u0026b);\n        let h2 = hasher1.finish();\n        let h22: H256 = keccak256(\u0026b).into();\n        assert_eq!(h2, h22);\n\n        let mut hasher2 = Keccak256Hasher::default();\n        hasher2.write_byte(25u8);\n        let h2: H256 = hasher2.finish();\n        assert_eq!(h2, keccak256(25u8.to_be_bytes()).into());\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":2656}},{"line":32,"address":[],"length":0,"stats":{"Line":2656}},{"line":37,"address":[],"length":0,"stats":{"Line":6847}},{"line":38,"address":[],"length":0,"stats":{"Line":6847}},{"line":40,"address":[],"length":0,"stats":{"Line":4967}},{"line":41,"address":[],"length":0,"stats":{"Line":4967}},{"line":44,"address":[],"length":0,"stats":{"Line":2656}},{"line":45,"address":[],"length":0,"stats":{"Line":2656}},{"line":46,"address":[],"length":0,"stats":{"Line":2656}}],"covered":9,"coverable":9},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","primitives","src","kv.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! You can think of this backend as a KVDB, but it also provides Merkle proofs for the existence or non-existence of data.  \n//! Here, define the data structures for your key and value, as they determine how data is stored in the database.  \n//! Your key will ultimately be hashed, and this hash will determine the path of your value in the Merkle tree.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\nuse codec::{Decode, Encode};\n// use ethers::utils::keccak256;\nuse scale_info::TypeInfo;\nuse serde::{Deserialize, Serialize};\nuse serde_with::{serde_as, DisplayFromStr};\n// use sp_core::Hasher::keccak256;\nuse scale_info::prelude::{string::String, vec::Vec};\nuse sha3::Digest;\n// use sp_crypto_hashing::keccak_256;\nuse scale_info::prelude::fmt::Debug;\nuse sha3::Keccak256;\nuse sparse_merkle_tree::{traits::Value, H256};\n\ncfg_if::cfg_if! {\n    if #[cfg(feature=\"std\")] {\n        /// The data structure of the value in the KVDB, which determines the type of data you store in the Merkle tree.\n        use utoipa::{IntoParams, ToSchema};\n        #[serde_as]\n        #[derive(\n            Encode,\n            Decode,\n            Debug,\n            Serialize,\n            Deserialize,\n            Default,\n            PartialEq,\n            Eq,\n            Clone,\n            ToSchema,\n            IntoParams,\n            TypeInfo,\n        )]\n        pub struct SMTValue {\n            /// The nonce value of the user account.\n            // #[serde_as(as = \"DisplayFromStr\")]\n            pub nonce: u64,\n            /// The balance of the user account.\n            #[serde_as(as = \"DisplayFromStr\")]\n            pub balance: u128,\n        }\n\n        #[serde_as]\n        #[derive(\n            Encode,\n            Decode,\n            Debug,\n            Serialize,\n            Deserialize,\n            Default,\n            PartialEq,\n            Eq,\n            Clone,\n            ToSchema,\n            IntoParams,\n            TypeInfo,\n        )]\n        /// The key in the KVDB, which determines for whom you are storing data.\n        pub struct SMTKey {\n            /// The on-chain user address.\n            pub address: String,\n        }\n    } else {\n        /// The data structure of the value in the KVDB, which determines the type of data you store in the Merkle tree.\n        #[serde_as]\n        #[derive(\n            Encode,\n            Decode,\n            Debug,\n            Serialize,\n            Deserialize,\n            Default,\n            PartialEq,\n            Eq,\n            Clone,\n            // ToSchema,\n            // IntoParams,\n            TypeInfo,\n        )]\n        pub struct SMTValue {\n            /// The nonce value of the user account.\n            // #[serde_as(as = \"DisplayFromStr\")]\n            pub nonce: u64,\n             /// The balance of the user account.\n            #[serde_as(as = \"DisplayFromStr\")]\n            pub balance: u128,\n        }\n\n        /// The key in the KVDB, which determines for whom you are storing data.\n        #[serde_as]\n        #[derive(\n            Encode,\n            Decode,\n            Debug,\n            Serialize,\n            Deserialize,\n            Default,\n            PartialEq,\n            Eq,\n            Clone,\n            TypeInfo,\n        )]\n        pub struct SMTKey {\n            /// The on-chain user address.\n            pub address: String,\n        }\n\n    }\n\n}\n\n/// How the key in the KVDB is computed into a hash value.\nimpl Value for SMTKey {\n    fn zero() -\u003e Self {\n        SMTKey::default()\n    }\n\n    fn to_h256(\u0026self) -\u003e sparse_merkle_tree::H256 {\n        let mut k = Keccak256::new();\n        k.update(self.encode().as_slice());\n        let r: [u8; 32] = k.finalize().into();\n        r.into()\n    }\n}\n\n/// How the value in the KVDB is computed into a hash value.\nimpl Value for SMTValue {\n    fn zero() -\u003e Self {\n        Default::default()\n    }\n\n    fn to_h256(\u0026self) -\u003e sparse_merkle_tree::H256 {\n        if self == \u0026Default::default() {\n            return H256::zero();\n        }\n        let mut k = Keccak256::new();\n        k.update(self.encode().as_slice());\n        let r: [u8; 32] = k.finalize().into();\n        r.into()\n    }\n}\n\nimpl From\u003cSMTValue\u003e for Vec\u003cu8\u003e {\n    fn from(value: SMTValue) -\u003e Self {\n        value.encode()\n    }\n}\n\nimpl From\u003cVec\u003cu8\u003e\u003e for SMTValue {\n    fn from(value: Vec\u003cu8\u003e) -\u003e Self {\n        let a: SMTValue = Decode::decode::\u003c\u0026[u8]\u003e(\u0026mut value.as_slice()).unwrap_or_default();\n        a\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::SMTValue;\n    use sparse_merkle_tree::{traits::Value, H256};\n\n    #[test]\n    fn test_value() {\n        let v = SMTValue {\n            nonce: 1,\n            balance: 100000,\n        };\n        let v_vec: Vec\u003cu8\u003e = v.clone().into();\n        assert_eq!(v, v_vec.into());\n\n        let v1: SMTValue = Default::default();\n        assert_eq!(v1.to_h256(), H256::default());\n    }\n}\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":452}},{"line":140,"address":[],"length":0,"stats":{"Line":452}},{"line":141,"address":[],"length":0,"stats":{"Line":452}},{"line":142,"address":[],"length":0,"stats":{"Line":452}},{"line":143,"address":[],"length":0,"stats":{"Line":452}},{"line":149,"address":[],"length":0,"stats":{"Line":10}},{"line":150,"address":[],"length":0,"stats":{"Line":10}},{"line":153,"address":[],"length":0,"stats":{"Line":226}},{"line":154,"address":[],"length":0,"stats":{"Line":226}},{"line":155,"address":[],"length":0,"stats":{"Line":7}},{"line":157,"address":[],"length":0,"stats":{"Line":219}},{"line":158,"address":[],"length":0,"stats":{"Line":219}},{"line":159,"address":[],"length":0,"stats":{"Line":219}},{"line":160,"address":[],"length":0,"stats":{"Line":219}},{"line":165,"address":[],"length":0,"stats":{"Line":115}},{"line":166,"address":[],"length":0,"stats":{"Line":115}},{"line":171,"address":[],"length":0,"stats":{"Line":111}},{"line":172,"address":[],"length":0,"stats":{"Line":111}},{"line":173,"address":[],"length":0,"stats":{"Line":111}}],"covered":19,"coverable":28},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","primitives","src","lib.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\npub mod keccak_hasher;\npub mod kv;\npub mod verify;\npub use sparse_merkle_tree;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","primitives","src","verify.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Verify the Merkle proof.  \n//! This provides a more user-friendly method of verifying the Merkle proof, rather than just a sequence of `Vec\u003cu8\u003e` that cannot be directly parsed back into the original data.  \n//! It enables you to perform more actions on-chain.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n#![allow(dead_code)]\n#![allow(unused_imports)]\n#![allow(clippy::collapsible_else_if)]\n#![allow(clippy::legacy_numeric_constants)]\n#![allow(clippy::arithmetic_side_effects)]\n\nextern crate alloc;\nuse alloc::vec::Vec;\nuse codec::{Decode, Encode};\nuse scale_info::{prelude::fmt::Debug, TypeInfo};\nuse serde::{self, Deserialize, Serialize};\nuse sparse_merkle_tree::{\n    merge::{hash_base_node, merge, MergeValue},\n    traits::Hasher,\n    H256,\n};\n\ncfg_if::cfg_if! {\n    if #[cfg(feature=\"std\")] {\n        use utoipa::{ToSchema, IntoParams, __dev::ComposeSchema};\n\n        /// Merkle proof.\n        #[derive(Debug, Serialize, Deserialize, Clone, Encode, Decode, TypeInfo, PartialEq, ToSchema)]\n        pub struct Proof\u003cK: Debug + Clone + TypeInfo, V: Default + Debug + Clone + TypeInfo\u003e {\n            /// The key in the KVDB.\n            #[serde(flatten)]\n            pub key: K,\n            /// The value in the KVDB.\n            #[serde(flatten)]\n            pub value: V,\n            /// The Merkle leaf's path (i.e., the hash value of the key).\n            pub path: H256,\n            /// The hash value of the Merkle leaf (i.e., the hash value of the value).\n            pub value_hash: H256,\n            /// Merkle root hash.\n            pub root: H256,\n            /// Path marker, indicating where hashing should be performed.\n            pub leave_bitmap: H256,\n            /// Branches encountered on the leave_bitmap that need to be hashed. They correspond one-to-one with the leave_bitmap.\n            pub siblings: Vec\u003cMergeValue\u003e,\n        }\n\n    } else {\n         /// Merkle proof.\n        #[derive(Debug, Serialize, Deserialize, Clone, Encode, Decode, TypeInfo, PartialEq)]\n        pub struct Proof\u003cK: Debug + Clone + TypeInfo, V: Default + Debug + Clone + TypeInfo\u003e {\n            /// The key in the KVDB.\n            #[serde(flatten)]\n            pub key: K,\n            /// The value in the KVDB.\n            #[serde(flatten)]\n            pub value: V,\n            /// The Merkle leaf's path (i.e., the hash value of the key).\n            pub path: H256,\n            /// The hash value of the Merkle leaf (i.e., the hash value of the value).\n            pub value_hash: H256,\n            /// Merkle root hash.\n            pub root: H256,\n            /// Path marker, indicating where hashing should be performed.\n            pub leave_bitmap: H256,\n            /// Branches encountered on the leave_bitmap that need to be hashed. They correspond one-to-one with the leave_bitmap.\n            pub siblings: Vec\u003cMergeValue\u003e,\n        }\n    }\n\n}\n\n/// When there is only one value in the database (i.e., only one leaf, and the other leaves are empty), how to compute the root.\nfn single_leaf_verify\u003cH: Hasher + Default\u003e(key: H256, value: H256) -\u003e MergeValue {\n    if value.is_zero() {\n        MergeValue::from_h256(value)\n    } else {\n        let base_key = key.parent_path(0);\n        let base_node = hash_base_node::\u003cH\u003e(0, \u0026base_key, \u0026value);\n        let zero_bits = key;\n        MergeValue::MergeWithZero {\n            base_node,\n            zero_bits,\n            zero_count: 0,\n        }\n    }\n}\n\nfn into_merge_value\u003cH: Hasher + Default\u003e(key: H256, value: H256, height: u8) -\u003e MergeValue {\n    // try keep hash same with MergeWithZero\n    if value.is_zero() || height == 0 {\n        MergeValue::from_h256(value)\n    } else {\n        let base_key = key.parent_path(0);\n        let base_node = hash_base_node::\u003cH\u003e(0, \u0026base_key, \u0026value);\n        let mut zero_bits = key;\n        for i in height..=core::u8::MAX {\n            if key.get_bit(i) {\n                zero_bits.clear_bit(i);\n            }\n        }\n        MergeValue::MergeWithZero {\n            base_node,\n            zero_bits,\n            zero_count: height,\n        }\n    }\n}\n\n/// Verify the Merkle proof,  \n/// including the verification when there is only one leaf (which differs slightly from multi-leaf cases).\npub fn verify\u003cH: Hasher + Default\u003e(\n    path: H256,\n    value_hash: H256,\n    leave_bitmap: H256,\n    siblings: Vec\u003cMergeValue\u003e,\n    root: H256,\n) -\u003e bool {\n    if value_hash.is_zero() {\n        return false;\n    }\n    if siblings.is_empty() {\n        return single_leaf_verify::\u003cH\u003e(path, value_hash).hash::\u003cH\u003e() == root;\n    }\n\n    let mut current_path = path;\n    let mut n = 0;\n\n    let mut current_v = MergeValue::zero();\n\n    let mut left: MergeValue = MergeValue::zero();\n    let mut right: MergeValue = MergeValue::zero();\n\n    for i in 0..=u8::MAX {\n        let parent_path = current_path.parent_path(i);\n        if leave_bitmap.get_bit(i) {\n            if n == 0 {\n                current_v = into_merge_value::\u003cH\u003e(path, value_hash, i);\n            }\n            if current_path.is_right(i) {\n                left = siblings[n].clone();\n                right = current_v.clone();\n            } else {\n                left = current_v.clone();\n                right = siblings[n].clone();\n            }\n\n            n += 1;\n        } else {\n            if n \u003e 0 {\n                if current_path.is_right(i) {\n                    left = MergeValue::zero();\n                    right = current_v.clone();\n                } else {\n                    left = current_v.clone();\n                    right = MergeValue::zero();\n                }\n            }\n        }\n\n        current_v = merge::\u003cH\u003e(i, \u0026parent_path, \u0026left, \u0026right);\n\n        current_path = parent_path;\n    }\n    current_v.hash::\u003cH\u003e() == root\n}\n","traces":[{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":5}},{"line":92,"address":[],"length":0,"stats":{"Line":5}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":5}},{"line":96,"address":[],"length":0,"stats":{"Line":5}},{"line":97,"address":[],"length":0,"stats":{"Line":5}},{"line":106,"address":[],"length":0,"stats":{"Line":100}},{"line":108,"address":[],"length":0,"stats":{"Line":200}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":100}},{"line":112,"address":[],"length":0,"stats":{"Line":100}},{"line":113,"address":[],"length":0,"stats":{"Line":100}},{"line":114,"address":[],"length":0,"stats":{"Line":805}},{"line":115,"address":[],"length":0,"stats":{"Line":1205}},{"line":116,"address":[],"length":0,"stats":{"Line":400}},{"line":129,"address":[],"length":0,"stats":{"Line":107}},{"line":136,"address":[],"length":0,"stats":{"Line":107}},{"line":137,"address":[],"length":0,"stats":{"Line":2}},{"line":139,"address":[],"length":0,"stats":{"Line":105}},{"line":140,"address":[],"length":0,"stats":{"Line":5}},{"line":143,"address":[],"length":0,"stats":{"Line":100}},{"line":144,"address":[],"length":0,"stats":{"Line":100}},{"line":146,"address":[],"length":0,"stats":{"Line":100}},{"line":148,"address":[],"length":0,"stats":{"Line":100}},{"line":149,"address":[],"length":0,"stats":{"Line":100}},{"line":151,"address":[],"length":0,"stats":{"Line":51300}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":792}},{"line":155,"address":[],"length":0,"stats":{"Line":100}},{"line":157,"address":[],"length":0,"stats":{"Line":1028}},{"line":158,"address":[],"length":0,"stats":{"Line":336}},{"line":159,"address":[],"length":0,"stats":{"Line":336}},{"line":161,"address":[],"length":0,"stats":{"Line":356}},{"line":162,"address":[],"length":0,"stats":{"Line":356}},{"line":165,"address":[],"length":0,"stats":{"Line":692}},{"line":167,"address":[],"length":0,"stats":{"Line":24908}},{"line":168,"address":[],"length":0,"stats":{"Line":177}},{"line":169,"address":[],"length":0,"stats":{"Line":64}},{"line":170,"address":[],"length":0,"stats":{"Line":64}},{"line":172,"address":[],"length":0,"stats":{"Line":49}},{"line":173,"address":[],"length":0,"stats":{"Line":49}},{"line":178,"address":[],"length":0,"stats":{"Line":25600}},{"line":180,"address":[],"length":0,"stats":{"Line":25600}},{"line":182,"address":[],"length":0,"stats":{"Line":100}}],"covered":41,"coverable":46},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","benches","smt_benchmark.rs"],"content":"#[macro_use]\nextern crate criterion;\n\nuse criterion::Criterion;\nuse rand::{thread_rng, Rng};\nuse sparse_merkle_tree::{\n    blake2b::Blake2bHasher, default_store::DefaultStore, SparseMerkleTree, H256,\n};\n\nconst TARGET_LEAVES_COUNT: usize = 20;\n\n#[allow(clippy::upper_case_acronyms)]\ntype SMT = SparseMerkleTree\u003cBlake2bHasher, H256, DefaultStore\u003cH256\u003e\u003e;\n\nfn random_h256(rng: \u0026mut impl Rng) -\u003e H256 {\n    let mut buf = [0u8; 32];\n    rng.fill(\u0026mut buf);\n    buf.into()\n}\n\nfn random_smt(update_count: usize, rng: \u0026mut impl Rng) -\u003e (SMT, Vec\u003cH256\u003e) {\n    let mut smt = SparseMerkleTree::default();\n    let mut keys = Vec::with_capacity(update_count);\n    for _ in 0..update_count {\n        let key = random_h256(rng);\n        let value = random_h256(rng);\n        smt.update(key, value).unwrap();\n        keys.push(key);\n    }\n    (smt, keys)\n}\n\nfn random_smt_update_all(update_count: usize, rng: \u0026mut impl Rng) {\n    let mut smt = SMT::default();\n    let mut kvs = Vec::with_capacity(update_count);\n    for _ in 0..update_count {\n        let key = random_h256(rng);\n        let value = random_h256(rng);\n        kvs.push((key, value));\n    }\n    smt.update_all(kvs).unwrap();\n}\n\nfn bench(c: \u0026mut Criterion) {\n    c.bench_function_over_inputs(\n        \"SMT update\",\n        |b, \u0026\u0026size| {\n            b.iter(|| {\n                let mut rng = thread_rng();\n                random_smt(size, \u0026mut rng)\n            });\n        },\n        \u0026[100, 10_000],\n    );\n\n    c.bench_function_over_inputs(\n        \"SMT update_all\",\n        |b, \u0026\u0026size| {\n            b.iter(|| {\n                let mut rng = thread_rng();\n                random_smt_update_all(size, \u0026mut rng)\n            });\n        },\n        \u0026[100, 10_000],\n    );\n\n    c.bench_function_over_inputs(\n        \"SMT get\",\n        |b, \u0026\u0026size| {\n            let mut rng = thread_rng();\n            let (smt, _keys) = random_smt(size, \u0026mut rng);\n            b.iter(|| {\n                let key = random_h256(\u0026mut rng);\n                smt.get(\u0026key).unwrap();\n            });\n        },\n        \u0026[5_000, 10_000],\n    );\n\n    c.bench_function(\"SMT generate merkle proof\", |b| {\n        let mut rng = thread_rng();\n        let (smt, mut keys) = random_smt(10_000, \u0026mut rng);\n        keys.dedup();\n        let keys: Vec\u003c_\u003e = keys.into_iter().take(TARGET_LEAVES_COUNT).collect();\n        b.iter(|| {\n            smt.merkle_proof(keys.clone()).unwrap();\n        });\n    });\n\n    c.bench_function(\"SMT verify merkle proof\", |b| {\n        let mut rng = thread_rng();\n        let (smt, mut keys) = random_smt(10_000, \u0026mut rng);\n        keys.dedup();\n        let leaves: Vec\u003c_\u003e = keys\n            .iter()\n            .take(TARGET_LEAVES_COUNT)\n            .map(|k| (*k, smt.get(k).unwrap()))\n            .collect();\n        let proof = smt\n            .merkle_proof(keys.into_iter().take(TARGET_LEAVES_COUNT).collect())\n            .unwrap();\n        let root = smt.root();\n        b.iter(|| {\n            let valid = proof.clone().verify::\u003cBlake2bHasher\u003e(root, leaves.clone());\n            assert!(valid.expect(\"verify result\"));\n        });\n    });\n}\n\ncriterion_group!(\n    name = benches;\n    config = Criterion::default().sample_size(10);\n    targets = bench\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","benches","store_counter_benchmark.rs"],"content":"#[macro_use]\nextern crate criterion;\n\nuse std::sync::atomic::{AtomicUsize, Ordering};\n\nuse rand::{thread_rng, Rng};\nuse sparse_merkle_tree::{\n    blake2b::Blake2bHasher,\n    default_store::DefaultStore,\n    error::Error,\n    traits::{StoreReadOps, StoreWriteOps},\n    BranchKey, BranchNode, SparseMerkleTree, H256,\n};\n\n#[derive(Debug, Default)]\nstruct DefaultStoreWithCounters\u003cV\u003e {\n    store: DefaultStore\u003cV\u003e,\n    counters: Counters,\n}\n\n#[derive(Debug, Default)]\nstruct Counters {\n    get_branch_counter: AtomicUsize,\n    get_leaf_counter: AtomicUsize,\n    insert_branch_counter: AtomicUsize,\n    insert_leaf_counter: AtomicUsize,\n    remove_branch_counter: AtomicUsize,\n    remove_leaf_counter: AtomicUsize,\n}\n\nimpl\u003cV: Clone\u003e StoreReadOps\u003cV\u003e for DefaultStoreWithCounters\u003cV\u003e {\n    fn get_branch(\u0026self, branch_key: \u0026BranchKey) -\u003e Result\u003cOption\u003cBranchNode\u003e, Error\u003e {\n        self.counters\n            .get_branch_counter\n            .fetch_add(1, Ordering::SeqCst);\n        self.store.get_branch(branch_key)\n    }\n    fn get_leaf(\u0026self, leaf_key: \u0026H256) -\u003e Result\u003cOption\u003cV\u003e, Error\u003e {\n        self.counters\n            .get_leaf_counter\n            .fetch_add(1, Ordering::SeqCst);\n        self.store.get_leaf(leaf_key)\n    }\n}\n\nimpl\u003cV\u003e StoreWriteOps\u003cV\u003e for DefaultStoreWithCounters\u003cV\u003e {\n    fn insert_branch(\u0026mut self, branch_key: BranchKey, branch: BranchNode) -\u003e Result\u003c(), Error\u003e {\n        self.counters\n            .insert_branch_counter\n            .fetch_add(1, Ordering::SeqCst);\n        self.store.insert_branch(branch_key, branch)\n    }\n    fn insert_leaf(\u0026mut self, leaf_key: H256, leaf: V) -\u003e Result\u003c(), Error\u003e {\n        self.counters\n            .insert_leaf_counter\n            .fetch_add(1, Ordering::SeqCst);\n        self.store.insert_leaf(leaf_key, leaf)\n    }\n    fn remove_branch(\u0026mut self, branch_key: \u0026BranchKey) -\u003e Result\u003c(), Error\u003e {\n        self.counters\n            .remove_branch_counter\n            .fetch_add(1, Ordering::SeqCst);\n        self.store.remove_branch(branch_key)\n    }\n    fn remove_leaf(\u0026mut self, leaf_key: \u0026H256) -\u003e Result\u003c(), Error\u003e {\n        self.counters\n            .remove_leaf_counter\n            .fetch_add(1, Ordering::SeqCst);\n        self.store.remove_leaf(leaf_key)\n    }\n}\n\n#[allow(clippy::upper_case_acronyms)]\ntype SMT = SparseMerkleTree\u003cBlake2bHasher, H256, DefaultStoreWithCounters\u003cH256\u003e\u003e;\n\nfn random_h256(rng: \u0026mut impl Rng) -\u003e H256 {\n    let mut buf = [0u8; 32];\n    rng.fill(\u0026mut buf);\n    buf.into()\n}\n\nfn random_smt(update_count: usize, rng: \u0026mut impl Rng) {\n    let mut smt = SMT::default();\n    let mut keys = Vec::with_capacity(update_count);\n    for _ in 0..update_count {\n        let key = random_h256(rng);\n        let value = random_h256(rng);\n        smt.update(key, value).unwrap();\n        keys.push(key);\n    }\n    println!(\n        \"random update {} keys, store counters: {:?}\",\n        update_count,\n        smt.store().counters\n    );\n}\n\nfn random_smt_update_all(update_count: usize, rng: \u0026mut impl Rng) {\n    let mut smt = SMT::default();\n    let mut kvs = Vec::with_capacity(update_count);\n    for _ in 0..update_count {\n        let key = random_h256(rng);\n        let value = random_h256(rng);\n        kvs.push((key, value));\n    }\n    smt.update_all(kvs).unwrap();\n    println!(\n        \"random update_all {} keys, store counters: {:?}\",\n        update_count,\n        smt.store().counters\n    );\n}\n\nfn main() {\n    let mut rng = thread_rng();\n    random_smt(100, \u0026mut rng);\n    random_smt(10000, \u0026mut rng);\n    random_smt_update_all(100, \u0026mut rng);\n    random_smt_update_all(10000, \u0026mut rng);\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":30},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","build.rs"],"content":"fn main() {\n    #[cfg(feature = \"smtc\")]\n    {\n        println!(\"cargo:rerun-if-changed=c/ckb_smt.h\");\n\n        cc::Build::new()\n            .file(\"src/ckb_smt.c\")\n            .static_flag(true)\n            .flag(\"-O3\")\n            .flag(\"-fvisibility=hidden\")\n            .flag(\"-fdata-sections\")\n            .flag(\"-ffunction-sections\")\n            .include(\"src/\")\n            .include(\"c/\")\n            .include(\"c/deps/ckb-c-stdlib\")\n            .flag(\"-Wall\")\n            .flag(\"-Werror\")\n            .flag(\"-Wno-unused-parameter\")\n            .flag(\"-Wno-nonnull\")\n            .define(\"__SHARED_LIBRARY__\", None)\n            .define(\"CKB_STDLIB_NO_SYSCALL_IMPL\", None)\n            .compile(\"smt-c-impl\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","c","rust-tests","build.rs"],"content":"fn main() {\n    println!(\"cargo:rerun-if-changed=../ckb_smt.h\");\n\n    cc::Build::new()\n        .file(\"../../src/ckb_smt.c\")\n        .static_flag(true)\n        .flag(\"-O3\")\n        .flag(\"-fvisibility=hidden\")\n        .flag(\"-fdata-sections\")\n        .flag(\"-ffunction-sections\")\n        .include(\"../../src\")\n        .include(\"..\")\n        .include(\"../deps/ckb-c-stdlib\")\n        .flag(\"-Wall\")\n        .flag(\"-Werror\")\n        .flag(\"-Wno-unused-parameter\")\n        .flag(\"-Wno-nonnull\")\n        .define(\"__SHARED_LIBRARY__\", None)\n        .define(\"CKB_STDLIB_NO_SYSCALL_IMPL\", None)\n        .compile(\"dl-c-impl\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","c","rust-tests","src","lib.rs"],"content":"#[cfg(test)]\nmod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","c","rust-tests","src","tests","mod.rs"],"content":"mod smt;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","c","rust-tests","src","tests","smt.rs"],"content":"use anyhow::Result;\nuse anyhow::Result as AnyResult;\nuse blake2b_rs::{Blake2b, Blake2bBuilder};\nuse core::ffi::c_void;\nuse proptest::prelude::*;\nuse rand::prelude::Rng;\nuse serde::{Deserialize, Serialize};\nuse sparse_merkle_tree::traits::Hasher;\nuse sparse_merkle_tree::{default_store::DefaultStore, SparseMerkleTree, H256};\nuse std::collections::HashMap;\nuse std::fs;\n\n#[link(name = \"dl-c-impl\", kind = \"static\")]\nextern \"C\" {\n    fn smt_state_new(capacity: u32) -\u003e *mut c_void;\n    fn smt_state_len(state: *mut c_void) -\u003e u32;\n\n    fn smt_state_insert(state: *mut c_void, key: *const u8, value: *const u8) -\u003e isize;\n    fn smt_state_fetch(state: *mut c_void, key: *const u8, value: *mut u8) -\u003e isize;\n    fn smt_state_normalize(state: *mut c_void);\n    #[allow(dead_code)]\n    fn smt_calculate_root(\n        buffer: *mut u8,\n        state: *const c_void,\n        proof: *const u8,\n        proof_length: u32,\n    ) -\u003e isize;\n    fn smt_verify(\n        hash: *const u8,\n        state: *const c_void,\n        proof: *const u8,\n        proof_length: u32,\n    ) -\u003e isize;\n}\n\npub struct SmtCImpl {\n    state_ptr: *mut c_void,\n}\n\nfn ffi_smt_result\u003cT\u003e(value: T, code: isize) -\u003e Result\u003cT, isize\u003e {\n    if code == 0 {\n        Ok(value)\n    } else {\n        Err(code)\n    }\n}\n\nfn ffi_assert_slice_len(slice: \u0026[u8], expected_len: usize) -\u003e Result\u003c(), isize\u003e {\n    if slice.len() == expected_len {\n        Ok(())\n    } else {\n        Err(-999)\n    }\n}\n\nimpl SmtCImpl {\n    pub fn new(capacity: u32) -\u003e SmtCImpl {\n        let state_ptr = unsafe { smt_state_new(capacity) };\n        SmtCImpl { state_ptr }\n    }\n\n    pub fn len(\u0026self) -\u003e u32 {\n        unsafe { smt_state_len(self.state_ptr) }\n    }\n\n    pub fn insert(\u0026mut self, key: \u0026[u8], value: \u0026[u8]) -\u003e Result\u003c(), isize\u003e {\n        ffi_assert_slice_len(key, 32)?;\n        ffi_assert_slice_len(value, 32)?;\n        let code = unsafe { smt_state_insert(self.state_ptr, key.as_ptr(), value.as_ptr()) };\n        ffi_smt_result((), code)\n    }\n\n    pub fn fetch(\u0026self, key: \u0026[u8]) -\u003e Result\u003c[u8; 32], isize\u003e {\n        ffi_assert_slice_len(key, 32)?;\n        let mut value = [0u8; 32];\n        let code = unsafe { smt_state_fetch(self.state_ptr, key.as_ptr(), value.as_mut_ptr()) };\n        ffi_smt_result(value, code)\n    }\n\n    pub fn normalize(\u0026mut self) {\n        unsafe {\n            smt_state_normalize(self.state_ptr);\n        }\n    }\n\n    #[allow(dead_code)]\n    pub fn calculate_root(\u0026self, proof: \u0026[u8]) -\u003e Result\u003c[u8; 32], isize\u003e {\n        let mut hash = [0u8; 32];\n        let code = unsafe {\n            smt_calculate_root(\n                hash.as_mut_ptr(),\n                self.state_ptr,\n                proof.as_ptr(),\n                proof.len() as u32,\n            )\n        };\n        ffi_smt_result(hash, code)\n    }\n\n    pub fn verify(\u0026self, root: \u0026[u8], proof: \u0026[u8]) -\u003e Result\u003c(), isize\u003e {\n        ffi_assert_slice_len(root, 32)?;\n        let code = unsafe {\n            smt_verify(\n                root.as_ptr(),\n                self.state_ptr,\n                proof.as_ptr(),\n                proof.len() as u32,\n            )\n        };\n        ffi_smt_result((), code)\n    }\n}\n\npub type Leave = ([u8; 32], [u8; 32]);\n\n#[derive(Default, Serialize, Deserialize)]\npub struct Proof {\n    pub leaves: Vec\u003cLeave\u003e,\n    pub compiled_proof: Vec\u003cu8\u003e,\n    pub error: Option\u003cString\u003e,\n}\n\n#[derive(Default, Serialize, Deserialize)]\npub struct Case {\n    pub name: String,\n    pub leaves: Vec\u003cLeave\u003e,\n    pub root: [u8; 32],\n    pub proofs: Vec\u003cProof\u003e,\n}\n\npub struct CkbBlake2bHasher(Blake2b);\n\nimpl Default for CkbBlake2bHasher {\n    fn default() -\u003e Self {\n        // NOTE: here we not set the `personal` since ckb_smt.c linked blake2b implementation from blake2b-rs\n        let blake2b = Blake2bBuilder::new(32)\n            .personal(b\"ckb-default-hash\")\n            .build();\n        CkbBlake2bHasher(blake2b)\n    }\n}\n\nimpl Hasher for CkbBlake2bHasher {\n    fn write_byte(\u0026mut self, b: u8) {\n        self.0.update(\u0026[b][..]);\n    }\n    fn write_h256(\u0026mut self, h: \u0026H256) {\n        self.0.update(h.as_slice());\n    }\n    fn finish(self) -\u003e H256 {\n        let mut hash = [0u8; 32];\n        self.0.finalize(\u0026mut hash);\n        hash.into()\n    }\n}\n\npub type CkbSMT = SparseMerkleTree\u003cCkbBlake2bHasher, H256, DefaultStore\u003cH256\u003e\u003e;\n\npub fn new_ckb_smt(pairs: Vec\u003c(H256, H256)\u003e) -\u003e CkbSMT {\n    let mut smt = CkbSMT::default();\n    for (key, value) in pairs {\n        smt.update(key, value).unwrap();\n    }\n    smt\n}\n\nfn h256_by_u8(n: u8) -\u003e [u8; 32] {\n    let mut data = [0u8; 32];\n    data[31] = n;\n    data\n}\n\n#[test]\nfn test_normalize() {\n    // pushed key = 7, value = 1\n    // pushed key = 1, value = 1\n    // pushed key = 1, value = 2\n    // pushed key = 2, value = 1\n    // pushed key = 2, value = 2\n    // pushed key = 0, value = 1\n    // pushed key = 0, value = 2\n    // pushed key = 6, value = 1\n    let mut smt_state = SmtCImpl::new(256);\n    let data_set = [\n        (7, 1),\n        (1, 1),\n        (1, 2),\n        (2, 1),\n        (2, 2),\n        (0, 1),\n        (0, 2),\n        (6, 1),\n    ];\n    for (k, v) in \u0026data_set {\n        smt_state.insert(\u0026h256_by_u8(*k), \u0026h256_by_u8(*v)).unwrap();\n    }\n    assert_eq!(smt_state.len() as usize, data_set.len());\n    smt_state.normalize();\n    assert_eq!(smt_state.len(), 5);\n    for (k, v) in \u0026[(0, 2), (1, 2), (2, 2), (6, 1), (7, 1)] {\n        assert_eq!(smt_state.fetch(\u0026h256_by_u8(*k)).unwrap(), h256_by_u8(*v));\n    }\n}\n\n#[test]\nfn test_normalize_random() {\n    let mut rng = rand::thread_rng();\n    for pair_size in vec![1, 2, 100, 256, 512, 1024, 2048] {\n        for _ in 0..4 {\n            let mut final_map: HashMap\u003cu8, u8\u003e = HashMap::default();\n            let mut smt_state = SmtCImpl::new(pair_size);\n            let rand_pairs: Vec\u003c(u8, u8)\u003e =\n                (0..pair_size).map(|_| (rng.gen(), rng.gen())).collect();\n            for (key, value) in \u0026rand_pairs {\n                final_map.insert(*key, *value);\n                smt_state\n                    .insert(\u0026h256_by_u8(*key), \u0026h256_by_u8(*value))\n                    .unwrap();\n            }\n            assert_eq!(smt_state.len(), pair_size);\n            smt_state.normalize();\n            assert_eq!(smt_state.len() as usize, final_map.len());\n            for (key, value) in \u0026final_map {\n                let byte32_value = smt_state.fetch(\u0026h256_by_u8(*key)).unwrap();\n                assert_eq!(h256_by_u8(*value), byte32_value);\n            }\n        }\n    }\n}\n\nfn run_test_case(case: Case) -\u003e AnyResult\u003c()\u003e {\n    let Case { leaves, proofs, .. } = case;\n\n    let ckb_smt = new_ckb_smt(\n        leaves\n            .iter()\n            .map(|(k, v)| ((*k).into(), (*v).into()))\n            .collect(),\n    );\n\n    for proof in proofs {\n        let Proof { leaves, error, .. } = proof;\n        let keys: Vec\u003c_\u003e = leaves.iter().map(|(k, _v)| (*k).into()).collect();\n        let ckb_actual_proof = match ckb_smt.merkle_proof(keys) {\n            Ok(proof) =\u003e proof,\n            Err(err) =\u003e {\n                let expected_error = error.expect(\"expected error\");\n                assert_eq!(expected_error, format!(\"{}\", err));\n                return Ok(());\n            }\n        };\n        let ckb_actual_compiled_proof = ckb_actual_proof.clone().compile(\n            leaves\n                .iter()\n                .map(|(k, _v)| (*k).into())\n                .collect(),\n        )?;\n        let ckb_actual_compiled_proof_bin: Vec\u003cu8\u003e = ckb_actual_compiled_proof.clone().into();\n\n        let mut smt_state = SmtCImpl::new(leaves.len() as u32);\n        for (key, value) in \u0026leaves {\n            smt_state.insert(key, value).unwrap();\n        }\n        for (key, value) in \u0026leaves {\n            let fetched_value = smt_state.fetch(key).unwrap();\n            assert_eq!(value, \u0026fetched_value);\n        }\n        smt_state.normalize();\n        for (key, value) in \u0026leaves {\n            let fetched_value = smt_state.fetch(key).unwrap();\n            assert_eq!(value, \u0026fetched_value);\n        }\n\n        assert_eq!(smt_state.len(), leaves.len() as u32);\n        smt_state\n            .verify(ckb_smt.root().as_slice(), \u0026ckb_actual_compiled_proof_bin)\n            .unwrap();\n    }\n    Ok(())\n}\n\nfn hex2bin(src: String) -\u003e Vec\u003cu8\u003e {\n    hex::decode(src).unwrap_or(Vec::new())\n}\n\n#[test]\nfn test_smt_c_verify1() {\n    let key = hex2bin(\"381dc5391dab099da5e28acd1ad859a051cf18ace804d037f12819c6fbc0e18b\".to_owned());\n    let value = hex2bin(\"9158ce9b0e11dd150ba2ae5d55c1db04b1c5986ec626f2e38a93fe8ad0b2923b\".to_owned());\n    let root_hash = hex2bin(\"ebe0fab376cd802d364eeb44af20c67a74d6183a33928fead163120ef12e6e06\".to_owned());\n    let proof = hex2bin(\n        \"4c4fff51ff322de8a89fe589987f97220cfcb6820bd798b31a0b56ffea221093d35f909e580b00000000000000000000000000000000000000000000000000000000000000\".to_owned());\n\n    unsafe {\n        let changes = smt_state_new(32);\n        smt_state_insert(changes, key.as_ptr(), value.as_ptr());\n        smt_state_normalize(changes);\n\n        let verify_ref = smt_verify(root_hash.as_ptr(), changes, proof.as_ptr(), proof.len() as u32);\n        assert_eq!(0, verify_ref);\n    }\n}\n\n#[test]\nfn test_smt_c_verify2() {\n    let key = hex2bin(\"a9bb945be71f0bd2757d33d2465b6387383da42f321072e47472f0c9c7428a8a\".to_owned());\n    let value = hex2bin(\"a939a47335f777eac4c40fbc0970e25f832a24e1d55adc45a7b76d63fe364e82\".to_owned());\n    let root_hash = hex2bin(\"6e5c722644cd55cef8c4ed886cd8b44027ae9ed129e70a4b67d87be1c6857842\".to_owned());\n    let proof = hex2bin(\n        \"4c4fff51fa8aaa2aece17b92ec3f202a40a09f7286522bae1e5581a2a49195ab6781b1b8090000000000000000000000000000000000000000000000000000000000000000\".to_owned());\n\n    unsafe {\n        let changes = smt_state_new(32);\n        smt_state_insert(changes, key.as_ptr(), value.as_ptr());\n        smt_state_normalize(changes);\n\n        let verify_ref = smt_verify(root_hash.as_ptr(), changes, proof.as_ptr(), proof.len() as u32);\n        assert_eq!(0, verify_ref);\n    }\n}\n\n// FIXME: uncomment this later\n// pub const FIXTURES_DIR: \u0026str = \"../deps/sparse-merkle-tree/fixtures\";\n// #[test]\n// fn test_fixtures() {\n//     for i in 0..100 {\n//         let path = format!(\"{}/basic/case-{}.json\", FIXTURES_DIR, i);\n//         let content = fs::read(\u0026path).expect(\"read\");\n//         let case: Case = serde_json::from_slice(\u0026content).expect(\"parse json\");\n//         run_test_case(case).expect(\"test case c impl\");\n//         println!(\"pass {}\", i);\n//     }\n// }\n\nproptest! {\n    #[test]\n    fn test_random_merkle_proof(key: [u8; 32], value: [u8;32]) {\n        let key = H256::from(key);\n        let value = H256::from(value);\n        const EXPECTED_PROOF_SIZE: usize = 16;\n\n        let mut tree = CkbSMT::default();\n        tree.update(key, value).expect(\"update\");\n        if !tree.is_empty() {\n            let proof = tree.merkle_proof(vec![key]).expect(\"proof\");\n            let compiled_proof = proof\n                .clone()\n                .compile(vec![key])\n                .expect(\"compile proof\");\n            assert!(proof.merkle_path().len() \u003c EXPECTED_PROOF_SIZE);\n            assert!(proof\n                    .verify::\u003cCkbBlake2bHasher\u003e(tree.root(), vec![(key, value)])\n                    .expect(\"verify\"));\n            assert!(compiled_proof\n                    .verify::\u003cCkbBlake2bHasher\u003e(tree.root(), vec![(key, value)])\n                    .expect(\"compiled verify\"));\n\n            let compiled_proof_bin: Vec\u003cu8\u003e = compiled_proof.into();\n            let mut smt_state = SmtCImpl::new(8);\n            smt_state.insert(key.as_slice(), value.as_slice()).unwrap();\n            smt_state.normalize();\n            smt_state\n                .verify(tree.root().as_slice(), \u0026compiled_proof_bin)\n                .expect(\"verify with c\");\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","blake2b.rs"],"content":"// use crate::{traits::Hasher, H256};\n// use blake2b_rs::{Blake2b, Blake2bBuilder};\n//\n// const BLAKE2B_KEY: \u0026[u8] = \u0026[];\n// const BLAKE2B_LEN: usize = 32;\n// const PERSONALIZATION: \u0026[u8] = b\"sparsemerkletree\";\n//\n// pub struct Blake2bHasher(Blake2b);\n//\n// impl Default for Blake2bHasher {\n//     fn default() -\u003e Self {\n//         let blake2b = Blake2bBuilder::new(BLAKE2B_LEN)\n//             .personal(PERSONALIZATION)\n//             .key(BLAKE2B_KEY)\n//             .build();\n//         Blake2bHasher(blake2b)\n//     }\n// }\n//\n// impl Hasher for Blake2bHasher {\n//     fn write_h256(\u0026mut self, h: \u0026H256) {\n//         self.0.update(h.as_slice());\n//     }\n//     fn write_byte(\u0026mut self, b: u8) {\n//         self.0.update(\u0026[b][..]);\n//     }\n//     fn finish(self) -\u003e H256 {\n//         let mut hash = [0u8; 32];\n//         self.0.finalize(\u0026mut hash);\n//         hash.into()\n//     }\n// }\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","ckb_smt.rs"],"content":"use crate::H256;\nuse core::{ptr, result::Result};\n\nextern crate alloc;\nuse alloc::{boxed::Box, vec::Vec};\n\n#[repr(C)]\nstruct smt_pair_t {\n    key: [u8; 32],\n    value: [u8; 32],\n    order: u32,\n}\n\n#[repr(C)]\nstruct smt_state_t {\n    pairs: *mut smt_pair_t,\n    len: u32,\n    capacity: u32,\n}\n\n#[link(name = \"smt-c-impl\", kind = \"static\")]\nextern \"C\" {\n    fn smt_state_init(state: *mut smt_state_t, buffer: *const smt_pair_t, capacity: u32);\n\n    fn smt_state_insert(state: *mut smt_state_t, key: *const u8, value: *const u8) -\u003e i32;\n    fn smt_state_normalize(state: *mut smt_state_t);\n    fn smt_verify(\n        hash: *const u8,\n        state: *const smt_state_t,\n        proof: *const u8,\n        proof_length: u32,\n    ) -\u003e i32;\n}\n\n#[derive(Default)]\npub struct SMTBuilder {\n    data: Vec\u003c(H256, H256)\u003e,\n}\n\npub struct SMT {\n    state: Box\u003csmt_state_t\u003e,\n    _buffer: Vec\u003csmt_pair_t\u003e,\n}\n\nimpl SMTBuilder {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    pub fn insert(self, key: \u0026H256, value: \u0026H256) -\u003e Result\u003cSelf, i32\u003e {\n        let mut ret = self;\n        ret.data.push((*key, *value));\n        Ok(ret)\n    }\n\n    pub fn build(self) -\u003e Result\u003cSMT, i32\u003e {\n        let capacity = self.data.len();\n        let mut smt = SMT {\n            state: Box::new(smt_state_t {\n                pairs: ptr::null_mut(),\n                len: 0,\n                capacity: 0,\n            }),\n            _buffer: Vec::with_capacity(capacity as usize),\n        };\n        unsafe {\n            smt_state_init(smt.state.as_mut(), smt._buffer.as_ptr(), capacity as u32);\n\n            for (key, value) in self.data {\n                let ret = smt_state_insert(\n                    smt.state.as_mut(),\n                    key.as_slice().as_ptr(),\n                    value.as_slice().as_ptr(),\n                );\n                if ret != 0 {\n                    return Err(ret);\n                }\n            }\n\n            smt_state_normalize(smt.state.as_mut());\n        }\n        Ok(smt)\n    }\n}\n\nimpl SMT {\n    pub fn verify(\u0026self, root: \u0026H256, proof: \u0026[u8]) -\u003e Result\u003c(), i32\u003e {\n        unsafe {\n            let verify_ret = smt_verify(\n                root.as_slice().as_ptr(),\n                self.state.as_ref(),\n                proof.as_ptr(),\n                proof.len() as u32,\n            );\n            if 0 != verify_ret {\n                return Err(verify_ret);\n            }\n        }\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","default_store.rs"],"content":"use crate::{\n    collections,\n    error::Error,\n    traits::{StoreReadOps, StoreWriteOps},\n    tree::{BranchKey, BranchNode},\n    H256,\n};\n\n#[derive(Debug, Clone, Default)]\npub struct DefaultStore\u003cV\u003e {\n    branches_map: Map\u003cBranchKey, BranchNode\u003e,\n    leaves_map: Map\u003cH256, V\u003e,\n}\n\nimpl\u003cV\u003e DefaultStore\u003cV\u003e {\n    pub fn branches_map(\u0026self) -\u003e \u0026Map\u003cBranchKey, BranchNode\u003e {\n        \u0026self.branches_map\n    }\n    pub fn leaves_map(\u0026self) -\u003e \u0026Map\u003cH256, V\u003e {\n        \u0026self.leaves_map\n    }\n    pub fn clear(\u0026mut self) {\n        self.branches_map.clear();\n        self.leaves_map.clear();\n    }\n}\n\nimpl\u003cV: Clone\u003e StoreReadOps\u003cV\u003e for DefaultStore\u003cV\u003e {\n    fn get_branch(\u0026self, branch_key: \u0026BranchKey) -\u003e Result\u003cOption\u003cBranchNode\u003e, Error\u003e {\n        Ok(self.branches_map.get(branch_key).map(Clone::clone))\n    }\n    fn get_leaf(\u0026self, leaf_key: \u0026H256) -\u003e Result\u003cOption\u003cV\u003e, Error\u003e {\n        Ok(self.leaves_map.get(leaf_key).map(Clone::clone))\n    }\n}\n\nimpl\u003cV\u003e StoreWriteOps\u003cV\u003e for DefaultStore\u003cV\u003e {\n    fn insert_branch(\u0026mut self, branch_key: BranchKey, branch: BranchNode) -\u003e Result\u003c(), Error\u003e {\n        self.branches_map.insert(branch_key, branch);\n        Ok(())\n    }\n    fn insert_leaf(\u0026mut self, leaf_key: H256, leaf: V) -\u003e Result\u003c(), Error\u003e {\n        self.leaves_map.insert(leaf_key, leaf);\n        Ok(())\n    }\n    fn remove_branch(\u0026mut self, branch_key: \u0026BranchKey) -\u003e Result\u003c(), Error\u003e {\n        self.branches_map.remove(branch_key);\n        Ok(())\n    }\n    fn remove_leaf(\u0026mut self, leaf_key: \u0026H256) -\u003e Result\u003c(), Error\u003e {\n        self.leaves_map.remove(leaf_key);\n        Ok(())\n    }\n}\n\ncfg_if::cfg_if! {\n    if #[cfg(feature = \"std\")] {\n        pub type Map\u003cK, V\u003e = collections::HashMap\u003cK, V\u003e;\n        pub type Entry\u003c'a, K, V\u003e = collections::hash_map::Entry\u003c'a, K, V\u003e;\n    } else {\n        pub type Map\u003cK, V\u003e = collections::BTreeMap\u003cK, V\u003e;\n        pub type Entry\u003c'a, K, V\u003e = collections::btree_map::Entry\u003c'a, K, V\u003e;\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":23},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","error.rs"],"content":"use crate::{string, H256};\n\npub type Result\u003cT\u003e = ::core::result::Result\u003cT, Error\u003e;\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum Error {\n    MissingBranch(u8, H256),\n    MissingLeaf(H256),\n    CorruptedProof,\n    EmptyProof,\n    EmptyKeys,\n    IncorrectNumberOfLeaves { expected: usize, actual: usize },\n    Store(string::String),\n    CorruptedStack,\n    NonSiblings,\n    InvalidCode(u8),\n    NonMergableRange,\n}\n\nimpl core::fmt::Display for Error {\n    fn fmt(\u0026self, f: \u0026mut core::fmt::Formatter\u003c'_\u003e) -\u003e core::fmt::Result {\n        match self {\n            Error::MissingBranch(height, key) =\u003e {\n                write!(\n                    f,\n                    \"Corrupted store, missing branch height:{}, key:{:?}\",\n                    height, key\n                )?;\n            }\n            Error::MissingLeaf(key) =\u003e {\n                write!(f, \"Corrupted store, missing leaf {:?}\", key)?;\n            }\n            Error::CorruptedProof =\u003e {\n                write!(f, \"Corrupted proof\")?;\n            }\n            Error::EmptyProof =\u003e {\n                write!(f, \"Empty proof\")?;\n            }\n            Error::EmptyKeys =\u003e {\n                write!(f, \"Empty keys\")?;\n            }\n            Error::IncorrectNumberOfLeaves { expected, actual } =\u003e {\n                write!(\n                    f,\n                    \"Incorrect number of leaves, expected {} actual {}\",\n                    expected, actual\n                )?;\n            }\n            Error::Store(err_msg) =\u003e {\n                write!(f, \"Backend store error: {}\", err_msg)?;\n            }\n            Error::CorruptedStack =\u003e {\n                write!(f, \"Corrupted serialized proof stack\")?;\n            }\n            Error::NonSiblings =\u003e {\n                write!(f, \"Merging non-siblings in serialized stack\")?;\n            }\n            Error::InvalidCode(code) =\u003e {\n                write!(f, \"Invalid serialized proof code: {}\", code)?;\n            }\n            Error::NonMergableRange =\u003e {\n                write!(f, \"Ranges can not be merged\")?;\n            }\n        }\n        Ok(())\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl std::error::Error for Error {}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":23},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","h256.rs"],"content":"use crate::vec::Vec;\nuse codec::{Decode, Encode};\nuse core::cmp::Ordering;\nuse scale_info::TypeInfo;\nuse serde::{Deserialize, Serialize};\nuse serde_with::serde_as;\n\ncfg_if::cfg_if! {\n    if #[cfg(feature=\"std\")] {\n        use utoipa::ToSchema;\n        #[serde_as]\n        #[derive(\n            Eq, PartialEq, Debug, Default, Hash, Clone, Copy, Decode, Encode, Deserialize, Serialize,\n            ToSchema, TypeInfo\n        )]\n        pub struct H256(#[serde_as(as = \"serde_with::hex::Hex\")] [u8; 32]);\n    }  else {\n        #[serde_as]\n        #[derive(\n            Eq, PartialEq, Debug, Default, Hash, Clone, Copy, Decode, Encode, Deserialize, Serialize, TypeInfo,\n        )]\n        pub struct H256(#[serde_as(as = \"serde_with::hex::Hex\")] [u8; 32]);\n\n    }\n}\n\nimpl From\u003cVec\u003cu8\u003e\u003e for H256 {\n    fn from(value: Vec\u003cu8\u003e) -\u003e Self {\n        let mut array = [0u8; 32];\n        let len = value.len().min(32);\n        array[..len].copy_from_slice(\u0026value[..len]);\n        H256(array)\n    }\n}\n\nimpl AsRef\u003c[u8]\u003e for H256 {\n    fn as_ref(\u0026self) -\u003e \u0026[u8] {\n        \u0026self.0\n    }\n}\n\nconst ZERO: H256 = H256([0u8; 32]);\nconst BYTE_SIZE: u8 = 8;\n\nimpl H256 {\n    pub const fn zero() -\u003e Self {\n        ZERO\n    }\n\n    pub fn is_zero(\u0026self) -\u003e bool {\n        self == \u0026ZERO\n    }\n\n    #[inline]\n    pub fn get_bit(\u0026self, i: u8) -\u003e bool {\n        let byte_pos = i / BYTE_SIZE;\n        let bit_pos = i % BYTE_SIZE;\n        let bit = self.0[byte_pos as usize] \u003e\u003e (7 - bit_pos) \u0026 1;\n        bit != 0\n    }\n\n    #[inline]\n    pub fn set_bit(\u0026mut self, i: u8) {\n        let byte_pos = i / BYTE_SIZE;\n        let bit_pos = i % BYTE_SIZE;\n        self.0[byte_pos as usize] |= 1 \u003c\u003c (7 - bit_pos) as u8;\n    }\n\n    #[inline]\n\n    pub fn clear_bit(\u0026mut self, i: u8) {\n        let byte_pos = i / BYTE_SIZE;\n        let bit_pos = i % BYTE_SIZE;\n        self.0[byte_pos as usize] \u0026= !((1 \u003c\u003c (7 - bit_pos)) as u8);\n    }\n\n    #[inline]\n    pub fn is_right(\u0026self, height: u8) -\u003e bool {\n        self.get_bit(height)\n    }\n\n    pub fn as_slice(\u0026self) -\u003e \u0026[u8] {\n        \u0026self.0[..]\n    }\n\n    /// Treat H256 as a path in a tree\n    /// fork height is the number of common bits(from heigher to lower: 255..=0) of two H256\n    pub fn fork_height(\u0026self, key: \u0026H256) -\u003e u8 {\n        for h in (0..=core::u8::MAX).rev() {\n            if self.get_bit(h) != key.get_bit(h) {\n                return h;\n            }\n        }\n        0\n    }\n\n    /// Treat H256 as a path in a tree\n    /// return parent_path of self\n    pub fn parent_path(\u0026self, height: u8) -\u003e Self {\n        if height == core::u8::MAX {\n            H256::zero()\n        } else {\n            self.copy_bits(height + 1)\n        }\n    }\n\n    /// Copy bits and return a new H256\n    pub fn copy_bits(\u0026self, start: u8) -\u003e Self {\n        let mut target = H256::zero();\n\n        let start_byte = (start / BYTE_SIZE) as usize;\n        // copy bytes\n        target.0[start_byte..].copy_from_slice(\u0026self.0[start_byte..]);\n\n        // reset remain bytes\n        let remain = start % BYTE_SIZE;\n        if remain \u003e 0 {\n            target.0[start_byte] \u0026= 0b11111111 \u003e\u003e remain\n        }\n\n        target\n    }\n}\n\nimpl PartialOrd for H256 {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for H256 {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n        // Compare bits from heigher to lower (255..0)\n        self.0.iter().rev().cmp(other.0.iter().rev())\n    }\n}\n\nimpl From\u003c[u8; 32]\u003e for H256 {\n    fn from(v: [u8; 32]) -\u003e H256 {\n        H256(v)\n    }\n}\n\nimpl From\u003cH256\u003e for [u8; 32] {\n    fn from(h256: H256) -\u003e [u8; 32] {\n        h256.0\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":3}},{"line":29,"address":[],"length":0,"stats":{"Line":3}},{"line":30,"address":[],"length":0,"stats":{"Line":3}},{"line":31,"address":[],"length":0,"stats":{"Line":3}},{"line":32,"address":[],"length":0,"stats":{"Line":3}},{"line":37,"address":[],"length":0,"stats":{"Line":6849}},{"line":38,"address":[],"length":0,"stats":{"Line":6849}},{"line":46,"address":[],"length":0,"stats":{"Line":167781}},{"line":47,"address":[],"length":0,"stats":{"Line":167781}},{"line":50,"address":[],"length":0,"stats":{"Line":143126}},{"line":51,"address":[],"length":0,"stats":{"Line":143126}},{"line":55,"address":[],"length":0,"stats":{"Line":141398}},{"line":56,"address":[],"length":0,"stats":{"Line":141398}},{"line":57,"address":[],"length":0,"stats":{"Line":141398}},{"line":58,"address":[],"length":0,"stats":{"Line":141398}},{"line":59,"address":[],"length":0,"stats":{"Line":141398}},{"line":63,"address":[],"length":0,"stats":{"Line":15163}},{"line":64,"address":[],"length":0,"stats":{"Line":15163}},{"line":65,"address":[],"length":0,"stats":{"Line":15163}},{"line":66,"address":[],"length":0,"stats":{"Line":15163}},{"line":71,"address":[],"length":0,"stats":{"Line":400}},{"line":72,"address":[],"length":0,"stats":{"Line":400}},{"line":73,"address":[],"length":0,"stats":{"Line":400}},{"line":74,"address":[],"length":0,"stats":{"Line":400}},{"line":78,"address":[],"length":0,"stats":{"Line":86065}},{"line":79,"address":[],"length":0,"stats":{"Line":86065}},{"line":82,"address":[],"length":0,"stats":{"Line":115}},{"line":83,"address":[],"length":0,"stats":{"Line":115}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":111721}},{"line":100,"address":[],"length":0,"stats":{"Line":111721}},{"line":101,"address":[],"length":0,"stats":{"Line":436}},{"line":103,"address":[],"length":0,"stats":{"Line":111285}},{"line":108,"address":[],"length":0,"stats":{"Line":111285}},{"line":109,"address":[],"length":0,"stats":{"Line":111285}},{"line":111,"address":[],"length":0,"stats":{"Line":111285}},{"line":113,"address":[],"length":0,"stats":{"Line":111285}},{"line":116,"address":[],"length":0,"stats":{"Line":111285}},{"line":117,"address":[],"length":0,"stats":{"Line":111285}},{"line":118,"address":[],"length":0,"stats":{"Line":97769}},{"line":121,"address":[],"length":0,"stats":{"Line":111285}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":3340}},{"line":140,"address":[],"length":0,"stats":{"Line":3340}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}}],"covered":42,"coverable":55},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","lib.rs"],"content":"//! Constructs a new `SparseMerkleTree\u003cH, V, S\u003e`.\n//!\n//! # Examples\n//!\n//! ```\n//! use sparse_merkle_tree::{\n//!     blake2b::Blake2bHasher, default_store::DefaultStore,\n//!     error::Error, MerkleProof,\n//!     SparseMerkleTree, traits::Value, H256\n//! };\n//! use blake2b_rs::{Blake2b, Blake2bBuilder};\n//!\n//! // define SMT\n//! type SMT = SparseMerkleTree\u003cBlake2bHasher, Word, DefaultStore\u003cWord\u003e\u003e;\n//!\n//! // define SMT value\n//! #[derive(Default, Clone)]\n//! pub struct Word(String);\n//! impl Value for Word {\n//!    fn to_h256(\u0026self) -\u003e H256 {\n//!        if self.0.is_empty() {\n//!            return H256::zero();\n//!        }\n//!        let mut buf = [0u8; 32];\n//!        let mut hasher = new_blake2b();\n//!        hasher.update(self.0.as_bytes());\n//!        hasher.finalize(\u0026mut buf);\n//!        buf.into()\n//!    }\n//!    fn zero() -\u003e Self {\n//!        Default::default()\n//!    }\n//! }\n//!\n//! // helper function\n//! fn new_blake2b() -\u003e Blake2b {\n//!     Blake2bBuilder::new(32).personal(b\"SMT\").build()\n//! }\n//!\n//! fn construct_smt() {\n//!     let mut tree = SMT::default();\n//!     for (i, word) in \"The quick brown fox jumps over the lazy dog\"\n//!         .split_whitespace()\n//!         .enumerate()\n//!     {\n//!         let key: H256 = {\n//!             let mut buf = [0u8; 32];\n//!             let mut hasher = new_blake2b();\n//!             hasher.update(\u0026(i as u32).to_le_bytes());\n//!             hasher.finalize(\u0026mut buf);\n//!             buf.into()\n//!         };\n//!         let value = Word(word.to_string());\n//!         // insert key value into tree\n//!         tree.update(key, value).expect(\"update\");\n//!     }\n//!\n//!     println!(\"SMT root is {:?} \", tree.root());\n//! }\n//! ```\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\npub mod blake2b;\n#[cfg(feature = \"smtc\")]\npub mod ckb_smt;\npub mod default_store;\npub mod error;\npub mod h256;\npub mod merge;\npub mod merkle_proof;\n#[cfg(test)]\nmod tests;\npub mod traits;\nmod tree;\n#[cfg(feature = \"trie\")]\nmod trie_tree;\n\n#[cfg(feature = \"smtc\")]\npub use ckb_smt::{SMTBuilder, SMT};\npub use h256::H256;\npub use merkle_proof::{CompiledMerkleProof, MerkleProof};\n#[cfg(not(feature = \"trie\"))]\npub use tree::SparseMerkleTree;\npub use tree::{BranchKey, BranchNode};\n#[cfg(feature = \"trie\")]\npub use trie_tree::SparseMerkleTree;\n\n/// Expected path size: log2(256) * 2, used for hint vector capacity\npub const EXPECTED_PATH_SIZE: usize = 16;\n// Max stack size can be used when verify compiled proof\npub(crate) const MAX_STACK_SIZE: usize = 257;\n\ncfg_if::cfg_if! {\n    if #[cfg(feature = \"std\")] {\n        use std::collections;\n        use std::vec;\n        use std::string;\n    } else {\n        extern crate alloc;\n        use alloc::collections;\n        use alloc::vec;\n        use alloc::string;\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","merge.rs"],"content":"#![cfg_attr(not(feature = \"std\"), no_std)]\n#![allow(unused_imports)]\nuse crate::{h256::H256, traits::Hasher};\nuse codec::{Decode, Encode};\nuse serde::{Deserialize, Serialize};\nuse serde_with::{hex::Hex, serde_as, DisplayFromStr};\n// use tiny_keccak::{Hasher as OtherHasher, Keccak};\nconst MERGE_NORMAL: u8 = 1;\nconst MERGE_ZEROS: u8 = 2;\nuse scale_info::TypeInfo;\n\ncfg_if::cfg_if! {\n    if #[cfg(feature=\"std\")] {\n        use utoipa::{ToSchema};\n        #[serde_as]\n        #[derive(Debug, Eq, PartialEq, Clone, Decode, Encode, Deserialize, Serialize, ToSchema, TypeInfo)]\n        pub enum MergeValue {\n            Value(#[serde_as(as = \"Hex\")] H256),\n            MergeWithZero {\n                #[serde_as(as = \"Hex\")]\n                base_node: H256,\n                #[serde_as(as = \"Hex\")]\n                zero_bits: H256,\n                // #[serde_as(as = \"DisplayFromStr\")]\n                zero_count: u8,\n            },\n            #[cfg(feature = \"trie\")]\n            ShortCut {\n                #[serde_as(as = \"Hex\")]\n                key: H256,\n                #[serde_as(as = \"Hex\")]\n                value: H256,\n                // #[serde_as(as = \"DisplayFromStr\")]\n                height: u8,\n            },\n}\n    }\n    else {\n        #[serde_as]\n        #[derive(Debug, Eq, PartialEq, Clone, Decode, Encode, Deserialize, Serialize, TypeInfo)]\n        pub enum MergeValue {\n            Value(#[serde_as(as = \"Hex\")] H256),\n            MergeWithZero {\n                #[serde_as(as = \"Hex\")]\n                base_node: H256,\n                #[serde_as(as = \"Hex\")]\n                zero_bits: H256,\n                // #[serde_as(as = \"DisplayFromStr\")]\n                zero_count: u8,\n            },\n            #[cfg(feature = \"trie\")]\n            ShortCut {\n                #[serde_as(as = \"Hex\")]\n                key: H256,\n                #[serde_as(as = \"Hex\")]\n                value: H256,\n                // #[serde_as(as = \"DisplayFromStr\")]\n                height: u8,\n    },\n}\n\n    }\n}\n\nimpl MergeValue {\n    pub fn from_h256(v: H256) -\u003e Self {\n        MergeValue::Value(v)\n    }\n\n    pub fn zero() -\u003e Self {\n        MergeValue::Value(H256::zero())\n    }\n\n    pub fn is_zero(\u0026self) -\u003e bool {\n        match self {\n            MergeValue::Value(v) =\u003e v.is_zero(),\n            MergeValue::MergeWithZero { .. } =\u003e false,\n            #[cfg(feature = \"trie\")]\n            MergeValue::ShortCut { .. } =\u003e false,\n        }\n    }\n\n    #[cfg(feature = \"trie\")]\n    pub fn shortcut_or_value(key: H256, value: H256, height: u8) -\u003e Self {\n        if height == 0 || value.is_zero() {\n            MergeValue::Value(value)\n        } else {\n            MergeValue::ShortCut { key, value, height }\n        }\n    }\n\n    #[cfg(feature = \"trie\")]\n    pub fn is_shortcut(\u0026self) -\u003e bool {\n        matches!(self, MergeValue::ShortCut { .. })\n    }\n\n    pub fn hash\u003cH: Hasher + Default\u003e(\u0026self) -\u003e H256 {\n        match self {\n            MergeValue::Value(v) =\u003e *v,\n            MergeValue::MergeWithZero {\n                base_node,\n                zero_bits,\n                zero_count,\n            } =\u003e {\n                let mut hasher = H::default();\n                hasher.write_byte(MERGE_ZEROS);\n                hasher.write_h256(base_node);\n                hasher.write_h256(zero_bits);\n                hasher.write_byte(*zero_count);\n                hasher.finish()\n            }\n            #[cfg(feature = \"trie\")]\n            MergeValue::ShortCut { key, value, height } =\u003e {\n                into_merge_value::\u003cH\u003e(*key, *value, *height).hash::\u003cH\u003e()\n            }\n        }\n    }\n}\n\npub fn into_merge_value1\u003cH: Hasher + Default\u003e(key: H256, value: H256, height: u8) -\u003e MergeValue {\n    // try keep hash same with MergeWithZero\n    if value.is_zero() || height == 0 {\n        MergeValue::from_h256(value)\n    } else {\n        let base_key = key.parent_path(0);\n        let base_node = hash_base_node::\u003cH\u003e(0, \u0026base_key, \u0026value);\n        let mut zero_bits = key;\n        for i in height..=core::u8::MAX {\n            if key.get_bit(i) {\n                zero_bits.clear_bit(i);\n            }\n        }\n        MergeValue::MergeWithZero {\n            base_node,\n            zero_bits,\n            zero_count: height,\n        }\n    }\n}\n\n/// Helper function for Shortcut node\n/// Transform it into a MergeValue or MergeWithZero node\n#[cfg(feature = \"trie\")]\npub fn into_merge_value\u003cH: Hasher + Default\u003e(key: H256, value: H256, height: u8) -\u003e MergeValue {\n    // try keep hash same with MergeWithZero\n    if value.is_zero() || height == 0 {\n        MergeValue::from_h256(value)\n    } else {\n        let base_key = key.parent_path(0);\n        let base_node = hash_base_node::\u003cH\u003e(0, \u0026base_key, \u0026value);\n        let mut zero_bits = key;\n        for i in height..=core::u8::MAX {\n            if key.get_bit(i) {\n                zero_bits.clear_bit(i);\n            }\n        }\n        MergeValue::MergeWithZero {\n            base_node,\n            zero_bits,\n            zero_count: height,\n        }\n    }\n}\n\n/// Hash base node into a H256\npub fn hash_base_node\u003cH: Hasher + Default\u003e(\n    base_height: u8,\n    base_key: \u0026H256,\n    base_value: \u0026H256,\n) -\u003e H256 {\n    let mut hasher = H::default();\n    // use tiny_keccak::Hasher;\n\n    hasher.write_byte(base_height);\n    hasher.write_h256(base_key);\n    hasher.write_h256(base_value);\n    hasher.finish()\n}\n\n/// Merge two hash with node information\n/// this function optimized for ZERO_HASH\n/// if lhs and rhs both are ZERO_HASH return ZERO_HASH, otherwise hash all info.\npub fn merge\u003cH: Hasher + Default\u003e(\n    height: u8,\n    node_key: \u0026H256,\n    lhs: \u0026MergeValue,\n    rhs: \u0026MergeValue,\n) -\u003e MergeValue {\n    if lhs.is_zero() \u0026\u0026 rhs.is_zero() {\n        return MergeValue::zero();\n    }\n    if lhs.is_zero() {\n        let res = merge_with_zero::\u003cH\u003e(height, node_key, rhs, true);\n        return res;\n    }\n    if rhs.is_zero() {\n        let res = merge_with_zero::\u003cH\u003e(height, node_key, lhs, false);\n        return res;\n    }\n\n    let mut hasher = H::default();\n    hasher.write_byte(MERGE_NORMAL);\n    hasher.write_byte(height);\n    hasher.write_h256(node_key);\n    hasher.write_h256(\u0026lhs.hash::\u003cH\u003e());\n    hasher.write_h256(\u0026rhs.hash::\u003cH\u003e());\n    MergeValue::Value(hasher.finish())\n}\n\npub fn merge_with_zero\u003cH: Hasher + Default\u003e(\n    height: u8,\n    node_key: \u0026H256,\n    value: \u0026MergeValue,\n    set_bit: bool,\n) -\u003e MergeValue {\n    match value {\n        MergeValue::Value(v) =\u003e {\n            let mut zero_bits = H256::zero();\n            if set_bit {\n                zero_bits.set_bit(height);\n            }\n            let base_node = hash_base_node::\u003cH\u003e(height, node_key, v);\n            MergeValue::MergeWithZero {\n                base_node,\n                zero_bits,\n                zero_count: 1,\n            }\n        }\n        MergeValue::MergeWithZero {\n            base_node,\n            zero_bits,\n            zero_count,\n        } =\u003e {\n            let mut zero_bits = *zero_bits;\n            if set_bit {\n                zero_bits.set_bit(height);\n            }\n            MergeValue::MergeWithZero {\n                base_node: *base_node,\n                zero_bits,\n                zero_count: zero_count.wrapping_add(1),\n            }\n        }\n        #[cfg(feature = \"trie\")]\n        MergeValue::ShortCut { key, value, .. } =\u003e {\n            if height == core::u8::MAX {\n                let base_key = key.parent_path(0);\n                let base_node = hash_base_node::\u003cH\u003e(0, \u0026base_key, value);\n                MergeValue::MergeWithZero {\n                    base_node,\n                    zero_bits: *key,\n                    zero_count: 0,\n                }\n            } else {\n                MergeValue::ShortCut {\n                    key: *key,\n                    value: *value,\n                    height: height + 1,\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":61504}},{"line":19,"address":[],"length":0,"stats":{"Line":55916}},{"line":66,"address":[],"length":0,"stats":{"Line":122}},{"line":67,"address":[],"length":0,"stats":{"Line":122}},{"line":70,"address":[],"length":0,"stats":{"Line":55008}},{"line":71,"address":[],"length":0,"stats":{"Line":55008}},{"line":74,"address":[],"length":0,"stats":{"Line":215130}},{"line":75,"address":[],"length":0,"stats":{"Line":215130}},{"line":76,"address":[],"length":0,"stats":{"Line":142796}},{"line":77,"address":[],"length":0,"stats":{"Line":72334}},{"line":97,"address":[],"length":0,"stats":{"Line":3630}},{"line":98,"address":[],"length":0,"stats":{"Line":3630}},{"line":99,"address":[],"length":0,"stats":{"Line":2856}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":774}},{"line":102,"address":[],"length":0,"stats":{"Line":774}},{"line":103,"address":[],"length":0,"stats":{"Line":774}},{"line":104,"address":[],"length":0,"stats":{"Line":774}},{"line":105,"address":[],"length":0,"stats":{"Line":774}},{"line":106,"address":[],"length":0,"stats":{"Line":774}},{"line":107,"address":[],"length":0,"stats":{"Line":774}},{"line":108,"address":[],"length":0,"stats":{"Line":774}},{"line":109,"address":[],"length":0,"stats":{"Line":774}},{"line":110,"address":[],"length":0,"stats":{"Line":774}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":340}},{"line":171,"address":[],"length":0,"stats":{"Line":340}},{"line":174,"address":[],"length":0,"stats":{"Line":340}},{"line":175,"address":[],"length":0,"stats":{"Line":340}},{"line":176,"address":[],"length":0,"stats":{"Line":340}},{"line":177,"address":[],"length":0,"stats":{"Line":340}},{"line":183,"address":[],"length":0,"stats":{"Line":56137}},{"line":189,"address":[],"length":0,"stats":{"Line":96417}},{"line":190,"address":[],"length":0,"stats":{"Line":25819}},{"line":192,"address":[],"length":0,"stats":{"Line":30318}},{"line":193,"address":[],"length":0,"stats":{"Line":14461}},{"line":194,"address":[],"length":0,"stats":{"Line":14461}},{"line":196,"address":[],"length":0,"stats":{"Line":15857}},{"line":197,"address":[],"length":0,"stats":{"Line":14318}},{"line":198,"address":[],"length":0,"stats":{"Line":14318}},{"line":201,"address":[],"length":0,"stats":{"Line":1539}},{"line":202,"address":[],"length":0,"stats":{"Line":1539}},{"line":203,"address":[],"length":0,"stats":{"Line":1539}},{"line":204,"address":[],"length":0,"stats":{"Line":1539}},{"line":205,"address":[],"length":0,"stats":{"Line":1539}},{"line":206,"address":[],"length":0,"stats":{"Line":1539}},{"line":207,"address":[],"length":0,"stats":{"Line":1539}},{"line":210,"address":[],"length":0,"stats":{"Line":28779}},{"line":216,"address":[],"length":0,"stats":{"Line":28779}},{"line":217,"address":[],"length":0,"stats":{"Line":235}},{"line":218,"address":[],"length":0,"stats":{"Line":235}},{"line":219,"address":[],"length":0,"stats":{"Line":348}},{"line":220,"address":[],"length":0,"stats":{"Line":113}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":28544}},{"line":231,"address":[],"length":0,"stats":{"Line":28544}},{"line":232,"address":[],"length":0,"stats":{"Line":28544}},{"line":233,"address":[],"length":0,"stats":{"Line":28544}},{"line":234,"address":[],"length":0,"stats":{"Line":28544}},{"line":235,"address":[],"length":0,"stats":{"Line":42892}},{"line":236,"address":[],"length":0,"stats":{"Line":14348}},{"line":239,"address":[],"length":0,"stats":{"Line":28544}},{"line":241,"address":[],"length":0,"stats":{"Line":28544}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}}],"covered":60,"coverable":92},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","merkle_proof.rs"],"content":"use crate::{\n    error::{Error, Result},\n    merge::{merge, MergeValue},\n    traits::Hasher,\n    vec::Vec,\n    H256, MAX_STACK_SIZE,\n};\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct MerkleProof {\n    // leaf bitmap, bitmap.get_bit(height) is true means there need a non zero sibling in this height\n    leaves_bitmap: Vec\u003cH256\u003e,\n    // needed sibling node hash\n    merkle_path: Vec\u003cMergeValue\u003e,\n}\n\nimpl MerkleProof {\n    /// Create MerkleProof\n    /// leaves_bitmap: leaf bitmap, bitmap.get_bit(height) is true means there need a non zero sibling in this height\n    /// proof: needed sibling node hash\n    pub fn new(leaves_bitmap: Vec\u003cH256\u003e, merkle_path: Vec\u003cMergeValue\u003e) -\u003e Self {\n        MerkleProof {\n            leaves_bitmap,\n            merkle_path,\n        }\n    }\n\n    /// Destruct the structure, useful for serialization\n    pub fn take(self) -\u003e (Vec\u003cH256\u003e, Vec\u003cMergeValue\u003e) {\n        let MerkleProof {\n            leaves_bitmap,\n            merkle_path,\n        } = self;\n        (leaves_bitmap, merkle_path)\n    }\n\n    /// number of leaves required by this merkle proof\n    pub fn leaves_count(\u0026self) -\u003e usize {\n        self.leaves_bitmap.len()\n    }\n\n    /// return the inner leaves_bitmap vector\n    pub fn leaves_bitmap(\u0026self) -\u003e \u0026Vec\u003cH256\u003e {\n        \u0026self.leaves_bitmap\n    }\n\n    /// return sibling node hashes\n    pub fn merkle_path(\u0026self) -\u003e \u0026Vec\u003cMergeValue\u003e {\n        \u0026self.merkle_path\n    }\n\n    pub fn compile(self, mut leaves_keys: Vec\u003cH256\u003e) -\u003e Result\u003cCompiledMerkleProof\u003e {\n        if leaves_keys.is_empty() {\n            return Err(Error::EmptyKeys);\n        } else if leaves_keys.len() != self.leaves_count() {\n            return Err(Error::IncorrectNumberOfLeaves {\n                expected: self.leaves_count(),\n                actual: leaves_keys.len(),\n            });\n        }\n        // sort leaves keys\n        leaves_keys.sort_unstable();\n\n        let (leaves_bitmap, merkle_path) = self.take();\n\n        let mut proof: Vec\u003cu8\u003e = Vec::with_capacity(merkle_path.len() * 33 + leaves_keys.len());\n        let mut stack_fork_height = [0u8; MAX_STACK_SIZE]; // store fork height\n        let mut stack_top = 0;\n        let mut leaf_index = 0;\n        let mut merkle_path_index = 0;\n        while leaf_index \u003c leaves_keys.len() {\n            let leaf_key = leaves_keys[leaf_index];\n            let fork_height = if leaf_index + 1 \u003c leaves_keys.len() {\n                leaf_key.fork_height(\u0026leaves_keys[leaf_index + 1])\n            } else {\n                core::u8::MAX\n            };\n            proof.push(0x4C);\n            let mut zero_count = 0u16;\n            for height in 0..=fork_height {\n                if height == fork_height \u0026\u0026 leaf_index + 1 \u003c leaves_keys.len() {\n                    // If it's not final round, we don't need to merge to root (height=255)\n                    break;\n                }\n                let (op_code_opt, sibling_data_opt): (_, Option\u003cVec\u003cu8\u003e\u003e) =\n                    if stack_top \u003e 0 \u0026\u0026 stack_fork_height[stack_top - 1] == height {\n                        stack_top -= 1;\n                        (Some(0x48), None)\n                    } else if leaves_bitmap[leaf_index].get_bit(height) {\n                        if merkle_path_index \u003e= merkle_path.len() {\n                            return Err(Error::CorruptedProof);\n                        }\n                        let node = \u0026merkle_path[merkle_path_index];\n                        merkle_path_index += 1;\n                        match node {\n                            MergeValue::Value(v) =\u003e (Some(0x50), Some(v.as_slice().to_vec())),\n                            MergeValue::MergeWithZero {\n                                base_node,\n                                zero_bits,\n                                zero_count,\n                            } =\u003e {\n                                let mut buffer = crate::vec![*zero_count];\n                                buffer.extend_from_slice(base_node.as_slice());\n                                buffer.extend_from_slice(zero_bits.as_slice());\n                                (Some(0x51), Some(buffer))\n                            }\n                            #[cfg(feature = \"trie\")]\n                            _ =\u003e unreachable!(),\n                        }\n                    } else {\n                        zero_count += 1;\n                        if zero_count \u003e 256 {\n                            return Err(Error::CorruptedProof);\n                        }\n                        (None, None)\n                    };\n                if let Some(op_code) = op_code_opt {\n                    if zero_count \u003e 0 {\n                        let n = if zero_count == 256 {\n                            0\n                        } else {\n                            zero_count as u8\n                        };\n                        proof.push(0x4F);\n                        proof.push(n);\n                        zero_count = 0;\n                    }\n                    proof.push(op_code);\n                }\n                if let Some(data) = sibling_data_opt {\n                    proof.extend(\u0026data);\n                }\n            }\n            if zero_count \u003e 0 {\n                let n = if zero_count == 256 {\n                    0\n                } else {\n                    zero_count as u8\n                };\n                proof.push(0x4F);\n                proof.push(n);\n            }\n            debug_assert!(stack_top \u003c MAX_STACK_SIZE);\n            stack_fork_height[stack_top] = fork_height;\n            stack_top += 1;\n            leaf_index += 1;\n        }\n\n        if stack_top != 1 {\n            return Err(Error::CorruptedProof);\n        }\n        if leaf_index != leaves_keys.len() {\n            return Err(Error::CorruptedProof);\n        }\n        if merkle_path_index != merkle_path.len() {\n            return Err(Error::CorruptedProof);\n        }\n        Ok(CompiledMerkleProof(proof))\n    }\n\n    /// Compute root from proof\n    /// leaves: a vector of (key, value)\n    ///\n    /// return EmptyProof error when proof is empty\n    /// return CorruptedProof error when proof is invalid\n    pub fn compute_root\u003cH: Hasher + Default\u003e(self, leaves: Vec\u003c(H256, H256)\u003e) -\u003e Result\u003cH256\u003e {\n        self.compile(leaves.iter().map(|(key, _value)| *key).collect())?\n            .compute_root::\u003cH\u003e(leaves)\n    }\n\n    /// Verify merkle proof\n    /// see compute_root_from_proof\n    pub fn verify\u003cH: Hasher + Default\u003e(\n        self,\n        root: \u0026H256,\n        leaves: Vec\u003c(H256, H256)\u003e,\n    ) -\u003e Result\u003cbool\u003e {\n        let calculated_root = self.compute_root::\u003cH\u003e(leaves)?;\n        Ok(\u0026calculated_root == root)\n    }\n}\n\n/// An structure optimized for verify merkle proof\n#[derive(Debug, Clone)]\npub struct CompiledMerkleProof(pub Vec\u003cu8\u003e);\n\n// A op code context passing to the callback function\nenum OpCodeContext\u003c'a\u003e {\n    L {\n        key: \u0026'a H256,\n    },\n    P {\n        key: \u0026'a H256,\n        height: u8,\n        program_index: usize,\n    },\n    Q {\n        key: \u0026'a H256,\n        height: u8,\n        program_index: usize,\n    },\n    H {\n        key_a: \u0026'a H256,\n        key_b: \u0026'a H256,\n        height: u8,\n        value_a: \u0026'a MergeValue,\n        value_b: \u0026'a MergeValue,\n    },\n    O {\n        key: \u0026'a H256,\n        height: u8,\n        n: u8,\n    },\n}\n\nimpl CompiledMerkleProof {\n    fn compute_root_inner\u003cH: Hasher + Default, F: FnMut(OpCodeContext) -\u003e Result\u003c()\u003e\u003e(\n        \u0026self,\n        mut leaves: Vec\u003c(H256, H256)\u003e,\n        mut callback: F,\n    ) -\u003e Result\u003cH256\u003e {\n        leaves.sort_unstable_by_key(|(k, _v)| *k);\n        let mut program_index = 0;\n        let mut leaf_index = 0;\n        let mut stack: Vec\u003c(u16, H256, MergeValue)\u003e = Vec::new();\n        while program_index \u003c self.0.len() {\n            let code = self.0[program_index];\n            program_index += 1;\n            match code {\n                // L : push leaf value\n                0x4C =\u003e {\n                    if leaf_index \u003e= leaves.len() {\n                        return Err(Error::CorruptedStack);\n                    }\n                    let (k, v) = leaves[leaf_index];\n                    callback(OpCodeContext::L { key: \u0026k })?;\n                    stack.push((0, k, MergeValue::from_h256(v)));\n                    leaf_index += 1;\n                }\n                // P : hash stack top item with sibling node in proof\n                0x50 =\u003e {\n                    if stack.is_empty() {\n                        return Err(Error::CorruptedStack);\n                    }\n                    if program_index + 32 \u003e self.0.len() {\n                        return Err(Error::CorruptedProof);\n                    }\n                    let mut data = [0u8; 32];\n                    data.copy_from_slice(\u0026self.0[program_index..program_index + 32]);\n                    program_index += 32;\n                    let sibling_node = MergeValue::from_h256(H256::from(data));\n                    let (height_u16, key, value) = stack.pop().unwrap();\n                    if height_u16 \u003e 255 {\n                        return Err(Error::CorruptedProof);\n                    }\n                    let height = height_u16 as u8;\n                    let parent_key = key.parent_path(height);\n                    callback(OpCodeContext::P {\n                        key: \u0026key,\n                        height,\n                        program_index,\n                    })?;\n                    let parent = if key.get_bit(height) {\n                        merge::\u003cH\u003e(height, \u0026parent_key, \u0026sibling_node, \u0026value)\n                    } else {\n                        merge::\u003cH\u003e(height, \u0026parent_key, \u0026value, \u0026sibling_node)\n                    };\n                    stack.push((height_u16 + 1, parent_key, parent));\n                }\n                // Q : hash stack top item with sibling node in proof,\n                // this is similar to P except that proof comes in using\n                // MergeWithZero format.\n                0x51 =\u003e {\n                    if stack.is_empty() {\n                        return Err(Error::CorruptedStack);\n                    }\n                    if program_index + 65 \u003e self.0.len() {\n                        return Err(Error::CorruptedProof);\n                    }\n                    let zero_count = self.0[program_index];\n                    let base_node = {\n                        let mut data = [0u8; 32];\n                        data.copy_from_slice(\u0026self.0[program_index + 1..program_index + 33]);\n                        H256::from(data)\n                    };\n                    let zero_bits = {\n                        let mut data = [0u8; 32];\n                        data.copy_from_slice(\u0026self.0[program_index + 33..program_index + 65]);\n                        H256::from(data)\n                    };\n                    program_index += 65;\n                    let sibling_node = MergeValue::MergeWithZero {\n                        base_node,\n                        zero_bits,\n                        zero_count,\n                    };\n                    let (height_u16, key, value) = stack.pop().unwrap();\n                    if height_u16 \u003e 255 {\n                        return Err(Error::CorruptedProof);\n                    }\n                    let height = height_u16 as u8;\n                    let parent_key = key.parent_path(height);\n                    callback(OpCodeContext::Q {\n                        key: \u0026key,\n                        height,\n                        program_index,\n                    })?;\n                    let parent = if key.get_bit(height) {\n                        merge::\u003cH\u003e(height, \u0026parent_key, \u0026sibling_node, \u0026value)\n                    } else {\n                        merge::\u003cH\u003e(height, \u0026parent_key, \u0026value, \u0026sibling_node)\n                    };\n                    stack.push((height_u16 + 1, parent_key, parent));\n                }\n                // H : pop 2 items in stack hash them then push the result\n                0x48 =\u003e {\n                    if stack.len() \u003c 2 {\n                        return Err(Error::CorruptedStack);\n                    }\n                    let (height_b, key_b, value_b) = stack.pop().unwrap();\n                    let (height_a, key_a, value_a) = stack.pop().unwrap();\n                    if height_a != height_b {\n                        return Err(Error::CorruptedProof);\n                    }\n                    if height_a \u003e 255 {\n                        return Err(Error::CorruptedProof);\n                    }\n                    let height_u16 = height_a;\n                    let height = height_u16 as u8;\n                    let parent_key_a = key_a.parent_path(height);\n                    let parent_key_b = key_b.parent_path(height);\n                    if parent_key_a != parent_key_b {\n                        return Err(Error::CorruptedProof);\n                    }\n                    callback(OpCodeContext::H {\n                        key_a: \u0026key_a,\n                        key_b: \u0026key_b,\n                        height,\n                        value_a: \u0026value_a,\n                        value_b: \u0026value_b,\n                    })?;\n                    let parent = if key_a.get_bit(height) {\n                        merge::\u003cH\u003e(height, \u0026parent_key_a, \u0026value_b, \u0026value_a)\n                    } else {\n                        merge::\u003cH\u003e(height, \u0026parent_key_a, \u0026value_a, \u0026value_b)\n                    };\n                    stack.push((height_u16 + 1, parent_key_a, parent));\n                }\n                // O : hash stack top item with n zero values\n                0x4F =\u003e {\n                    if stack.is_empty() {\n                        return Err(Error::CorruptedStack);\n                    }\n                    if program_index \u003e= self.0.len() {\n                        return Err(Error::CorruptedProof);\n                    }\n                    let n = self.0[program_index];\n                    program_index += 1;\n                    let zero_count: u16 = if n == 0 { 256 } else { n as u16 };\n                    let (base_height, key, mut value) = stack.pop().unwrap();\n                    if base_height \u003e 255 {\n                        return Err(Error::CorruptedProof);\n                    }\n                    callback(OpCodeContext::O {\n                        key: \u0026key,\n                        height: base_height as u8,\n                        n,\n                    })?;\n                    let mut parent_key = key;\n                    let mut height_u16 = base_height;\n                    for idx in 0..zero_count {\n                        if base_height + idx \u003e 255 {\n                            return Err(Error::CorruptedProof);\n                        }\n                        height_u16 = base_height + idx;\n                        let height = height_u16 as u8;\n                        parent_key = key.parent_path(height);\n                        value = if key.get_bit(height) {\n                            merge::\u003cH\u003e(height, \u0026parent_key, \u0026MergeValue::zero(), \u0026value)\n                        } else {\n                            merge::\u003cH\u003e(height, \u0026parent_key, \u0026value, \u0026MergeValue::zero())\n                        };\n                    }\n                    stack.push((height_u16 + 1, parent_key, value));\n                }\n                _ =\u003e return Err(Error::InvalidCode(code)),\n            }\n            debug_assert!(stack.len() \u003c= MAX_STACK_SIZE);\n        }\n        if stack.len() != 1 {\n            return Err(Error::CorruptedStack);\n        }\n        if stack[0].0 != 256 {\n            return Err(Error::CorruptedProof);\n        }\n        if leaf_index != leaves.len() {\n            return Err(Error::CorruptedProof);\n        }\n        Ok(stack[0].2.hash::\u003cH\u003e())\n    }\n\n    /// Extract sub compiled proof for certain sub leaves from current compiled proof.\n    ///\n    /// The argument must include all leaves. The 3rd item of every tuple\n    /// indicate if the sub key is selected.\n    pub fn extract_proof\u003cH: Hasher + Default\u003e(\n        \u0026self,\n        all_leaves: Vec\u003c(H256, H256, bool)\u003e,\n    ) -\u003e Result\u003cCompiledMerkleProof\u003e {\n        let mut leaves = Vec::with_capacity(all_leaves.len());\n        let mut sub_keys = Vec::new();\n        for (key, value, included) in all_leaves {\n            leaves.push((key, value));\n            if included {\n                sub_keys.push(key);\n            }\n        }\n\n        fn match_any_sub_key(key: \u0026H256, height: u8, sub_keys: \u0026[H256]) -\u003e bool {\n            sub_keys.iter().any(|sub_key| {\n                if height == 0 {\n                    key == sub_key\n                } else {\n                    key == \u0026sub_key.parent_path(height - 1)\n                }\n            })\n        }\n\n        let mut sub_proof = Vec::default();\n        let mut is_last_merge_zero = false;\n        let mut callback = |ctx: OpCodeContext| {\n            match ctx {\n                OpCodeContext::L { key } =\u003e {\n                    if sub_keys.contains(key) {\n                        sub_proof.push(0x4C);\n                        is_last_merge_zero = false;\n                    }\n                }\n                OpCodeContext::P {\n                    key,\n                    height,\n                    program_index,\n                } =\u003e {\n                    if match_any_sub_key(key, height, \u0026sub_keys) {\n                        sub_proof.push(0x50);\n                        sub_proof.extend(\u0026self.0[program_index - 32..program_index]);\n                        is_last_merge_zero = false;\n                    }\n                }\n                OpCodeContext::Q {\n                    key,\n                    height,\n                    program_index,\n                } =\u003e {\n                    if match_any_sub_key(key, height, \u0026sub_keys) {\n                        sub_proof.push(0x51);\n                        sub_proof.extend(\u0026self.0[program_index - 65..program_index]);\n                        is_last_merge_zero = false;\n                    }\n                }\n                OpCodeContext::H {\n                    key_a,\n                    key_b,\n                    height,\n                    value_a,\n                    value_b,\n                } =\u003e {\n                    let key_a_included = match_any_sub_key(key_a, height, \u0026sub_keys);\n                    let key_b_included = match_any_sub_key(key_b, height, \u0026sub_keys);\n                    if key_a_included \u0026\u0026 key_b_included {\n                        sub_proof.push(0x48);\n                        is_last_merge_zero = false;\n                    } else if key_a_included || key_b_included {\n                        let sibling_value = if key_a_included { \u0026value_b } else { \u0026value_a };\n                        match sibling_value {\n                            MergeValue::Value(hash) =\u003e {\n                                if hash.is_zero() {\n                                    if is_last_merge_zero {\n                                        let last_n = *sub_proof.last().unwrap();\n                                        if last_n == 0 {\n                                            return Err(Error::CorruptedProof);\n                                        }\n                                        *sub_proof.last_mut().unwrap() = last_n.wrapping_add(1);\n                                    } else {\n                                        sub_proof.push(0x4F);\n                                        sub_proof.push(1);\n                                        is_last_merge_zero = true;\n                                    }\n                                } else {\n                                    sub_proof.push(0x50);\n                                    sub_proof.extend(hash.as_slice());\n                                    is_last_merge_zero = false;\n                                }\n                            }\n                            MergeValue::MergeWithZero {\n                                base_node,\n                                zero_bits,\n                                zero_count,\n                            } =\u003e {\n                                sub_proof.push(0x51);\n                                sub_proof.push(*zero_count);\n                                sub_proof.extend(base_node.as_slice());\n                                sub_proof.extend(zero_bits.as_slice());\n                                is_last_merge_zero = false;\n                            }\n                            #[cfg(feature = \"trie\")]\n                            _ =\u003e {}\n                        };\n                    }\n                }\n                OpCodeContext::O { key, height, n } =\u003e {\n                    if match_any_sub_key(key, height, \u0026sub_keys) {\n                        if is_last_merge_zero {\n                            let last_n = *sub_proof.last().unwrap();\n                            if last_n == 0 || (last_n as u16 + n as u16) \u003e 256 {\n                                return Err(Error::CorruptedProof);\n                            }\n                            *sub_proof.last_mut().unwrap() = last_n.wrapping_add(n);\n                        } else {\n                            sub_proof.push(0x4F);\n                            sub_proof.push(n);\n                            is_last_merge_zero = true;\n                        }\n                    }\n                }\n            }\n            Ok(())\n        };\n        self.compute_root_inner::\u003cH, _\u003e(leaves, \u0026mut callback)?;\n        Ok(CompiledMerkleProof(sub_proof))\n    }\n\n    pub fn compute_root\u003cH: Hasher + Default\u003e(\u0026self, leaves: Vec\u003c(H256, H256)\u003e) -\u003e Result\u003cH256\u003e {\n        self.compute_root_inner::\u003cH, _\u003e(leaves, |_| Ok(()))\n    }\n\n    pub fn verify\u003cH: Hasher + Default\u003e(\n        \u0026self,\n        root: \u0026H256,\n        leaves: Vec\u003c(H256, H256)\u003e,\n    ) -\u003e Result\u003cbool\u003e {\n        let calculated_root = self.compute_root::\u003cH\u003e(leaves)?;\n        Ok(\u0026calculated_root == root)\n    }\n}\n\nimpl From\u003cCompiledMerkleProof\u003e for Vec\u003cu8\u003e {\n    fn from(proof: CompiledMerkleProof) -\u003e Vec\u003cu8\u003e {\n        proof.0\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":109}},{"line":29,"address":[],"length":0,"stats":{"Line":2}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":2}},{"line":32,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":34,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":107}},{"line":44,"address":[],"length":0,"stats":{"Line":107}},{"line":48,"address":[],"length":0,"stats":{"Line":107}},{"line":49,"address":[],"length":0,"stats":{"Line":107}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":4}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":80,"address":[],"length":0,"stats":{"Line":512}},{"line":81,"address":[],"length":0,"stats":{"Line":514}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":512}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":512}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":2}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":510}},{"line":112,"address":[],"length":0,"stats":{"Line":510}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":510}},{"line":117,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":4}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":2}},{"line":128,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":514}},{"line":134,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":2}},{"line":140,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":149,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":2}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":2}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":2}},{"line":222,"address":[],"length":0,"stats":{"Line":4}},{"line":223,"address":[],"length":0,"stats":{"Line":2}},{"line":224,"address":[],"length":0,"stats":{"Line":2}},{"line":225,"address":[],"length":0,"stats":{"Line":2}},{"line":226,"address":[],"length":0,"stats":{"Line":10}},{"line":227,"address":[],"length":0,"stats":{"Line":8}},{"line":228,"address":[],"length":0,"stats":{"Line":8}},{"line":229,"address":[],"length":0,"stats":{"Line":8}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":2}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":2}},{"line":236,"address":[],"length":0,"stats":{"Line":2}},{"line":237,"address":[],"length":0,"stats":{"Line":2}},{"line":238,"address":[],"length":0,"stats":{"Line":2}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":2}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":2}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":2}},{"line":281,"address":[],"length":0,"stats":{"Line":2}},{"line":282,"address":[],"length":0,"stats":{"Line":2}},{"line":283,"address":[],"length":0,"stats":{"Line":2}},{"line":284,"address":[],"length":0,"stats":{"Line":2}},{"line":286,"address":[],"length":0,"stats":{"Line":2}},{"line":287,"address":[],"length":0,"stats":{"Line":2}},{"line":288,"address":[],"length":0,"stats":{"Line":2}},{"line":289,"address":[],"length":0,"stats":{"Line":2}},{"line":291,"address":[],"length":0,"stats":{"Line":2}},{"line":297,"address":[],"length":0,"stats":{"Line":2}},{"line":298,"address":[],"length":0,"stats":{"Line":2}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":2}},{"line":302,"address":[],"length":0,"stats":{"Line":2}},{"line":303,"address":[],"length":0,"stats":{"Line":2}},{"line":304,"address":[],"length":0,"stats":{"Line":2}},{"line":305,"address":[],"length":0,"stats":{"Line":2}},{"line":306,"address":[],"length":0,"stats":{"Line":2}},{"line":308,"address":[],"length":0,"stats":{"Line":4}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":2}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":4}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":4}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":4}},{"line":358,"address":[],"length":0,"stats":{"Line":4}},{"line":359,"address":[],"length":0,"stats":{"Line":4}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":4}},{"line":365,"address":[],"length":0,"stats":{"Line":4}},{"line":366,"address":[],"length":0,"stats":{"Line":4}},{"line":367,"address":[],"length":0,"stats":{"Line":4}},{"line":369,"address":[],"length":0,"stats":{"Line":4}},{"line":370,"address":[],"length":0,"stats":{"Line":4}},{"line":371,"address":[],"length":0,"stats":{"Line":510}},{"line":372,"address":[],"length":0,"stats":{"Line":510}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":510}},{"line":376,"address":[],"length":0,"stats":{"Line":510}},{"line":377,"address":[],"length":0,"stats":{"Line":510}},{"line":378,"address":[],"length":0,"stats":{"Line":510}},{"line":379,"address":[],"length":0,"stats":{"Line":256}},{"line":381,"address":[],"length":0,"stats":{"Line":254}},{"line":384,"address":[],"length":0,"stats":{"Line":4}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":16}},{"line":390,"address":[],"length":0,"stats":{"Line":2}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":2}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":2}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":2}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":2}},{"line":534,"address":[],"length":0,"stats":{"Line":12}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}}],"covered":126,"coverable":308},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","tests","fixtures.rs"],"content":"use std::fs;\n\nuse crate::{\n    blake2b::Blake2bHasher, default_store::DefaultStore, CompiledMerkleProof, SparseMerkleTree,\n    H256,\n};\nuse anyhow::Result;\nuse rand::{prelude::SliceRandom, thread_rng, Rng};\nuse serde::{Deserialize, Serialize};\n\ntype Leave = ([u8; 32], [u8; 32]);\n\n#[derive(Default, Serialize, Deserialize)]\nstruct Proof {\n    leaves: Vec\u003cLeave\u003e,\n    compiled_proof: Vec\u003cu8\u003e,\n    error: Option\u003cString\u003e,\n}\n\n#[derive(Default, Serialize, Deserialize)]\nstruct Case {\n    name: String,\n    leaves: Vec\u003cLeave\u003e,\n    root: [u8; 32],\n    proofs: Vec\u003cProof\u003e,\n}\n\ntype SMT = SparseMerkleTree\u003cBlake2bHasher, H256, DefaultStore\u003cH256\u003e\u003e;\n\nfn new_smt(pairs: Vec\u003c(H256, H256)\u003e) -\u003e SMT {\n    let mut smt = SMT::default();\n    for (key, value) in pairs {\n        smt.update(key, value).unwrap();\n    }\n    smt\n}\n\nfn leaves(min_leaves: usize, max_leaves: usize) -\u003e Vec\u003c(H256, H256)\u003e {\n    let mut rng = thread_rng();\n    let size = rng.gen_range(min_leaves..=max_leaves);\n    let mut pairs: Vec\u003c_\u003e = (0..size)\n        .map(|_| {\n            let mut k = [0u8; 32];\n            let mut v = [0u8; 32];\n            rng.fill(\u0026mut k);\n            rng.fill(\u0026mut v);\n            (k.into(), v.into())\n        })\n        .collect();\n    pairs.dedup_by_key(|(k, _v)| *k);\n    pairs\n}\n\nfn gen_test_case(name: String) -\u003e Case {\n    let leaves = leaves(1, 50);\n    let smt = new_smt(leaves.clone());\n    let mut rng = thread_rng();\n\n    let mut proofs = Vec::new();\n    for _i in 0..5 {\n        let amount = rng.gen_range(0..=leaves.len());\n        let leaves_to_proof: Vec\u003c_\u003e = leaves.choose_multiple(\u0026mut rng, amount).cloned().collect();\n        let keys: Vec\u003c_\u003e = leaves_to_proof.iter().map(|(k, _v)| *k).collect();\n        let proof = match smt.merkle_proof(keys.clone()) {\n            Ok(proof) =\u003e {\n                let compiled_proof = proof.clone().compile(keys).expect(\"compile proof\");\n                Proof {\n                    leaves: leaves_to_proof\n                        .into_iter()\n                        .map(|(k, v)| (k.into(), v.into()))\n                        .collect(),\n                    compiled_proof: compiled_proof.into(),\n                    error: None,\n                }\n            }\n            Err(err) =\u003e Proof {\n                leaves: Default::default(),\n                compiled_proof: Default::default(),\n                error: Some(format!(\"{}\", err)),\n            },\n        };\n        proofs.push(proof);\n    }\n\n    Case {\n        name,\n        root: (*smt.root()).into(),\n        leaves: leaves\n            .into_iter()\n            .map(|(k, v)| (k.into(), v.into()))\n            .collect(),\n        proofs,\n    }\n}\n\n// use `cargo test test_gen_fixtures -- --ignored` to regenerate fixtures\n#[test]\n#[ignore]\nfn test_gen_fixtures() {\n    for i in 0..100 {\n        let name = format!(\"case-{}\", i);\n        let case = gen_test_case(name.clone());\n        let content = serde_json::to_vec_pretty(\u0026case).expect(\"to json\");\n        let path = format!(\"{}/basic/{}.json\", FIXTURES_DIR, name);\n        fs::write(\u0026path, content).expect(\"write\");\n        println!(\"write {}\", \u0026path);\n    }\n}\n\nfn run_test_case(case: Case) -\u003e Result\u003c()\u003e {\n    let Case {\n        name: _name,\n        leaves,\n        root,\n        proofs,\n    } = case;\n    let smt = new_smt(\n        leaves\n            .iter()\n            .map(|(k, v)| ((*k).into(), (*v).into()))\n            .collect(),\n    );\n    assert_eq!(smt.root(), \u0026root.into(), \"root\");\n\n    for proof in proofs {\n        let Proof {\n            leaves,\n            compiled_proof,\n            error,\n        } = proof;\n        let keys = leaves.iter().map(|(k, _v)| (*k).into()).collect();\n        let actual_compiled_proof: Vec\u003cu8\u003e = match smt.merkle_proof(keys) {\n            Ok(proof) =\u003e proof\n                .compile(leaves.iter().map(|(k, _v)| (*k).into()).collect())?\n                .into(),\n            Err(err) =\u003e {\n                let expected_error = error.expect(\"expected error\");\n                assert_eq!(expected_error, format!(\"{}\", err));\n                return Ok(());\n            }\n        };\n\n        assert_eq!(compiled_proof, actual_compiled_proof, \"proof\");\n\n        let proof = CompiledMerkleProof(compiled_proof);\n        let proof_root = proof\n            .compute_root::\u003cBlake2bHasher\u003e(\n                leaves\n                    .into_iter()\n                    .map(|(k, v)| (k.into(), v.into()))\n                    .collect(),\n            )\n            .expect(\"compute_root\");\n        assert_eq!(smt.root(), \u0026proof_root, \"proof root\");\n    }\n\n    Ok(())\n}\n\nconst FIXTURES_DIR: \u0026str = \"fixtures\";\n\n#[test]\nfn test_fixtures() {\n    for i in 0..100 {\n        let path = format!(\"{}/basic/case-{}.json\", FIXTURES_DIR, i);\n        let content = fs::read(\u0026path).expect(\"read\");\n        let case: Case = serde_json::from_slice(\u0026content).expect(\"parse json\");\n        run_test_case(case).expect(\"test case\");\n        println!(\"pass {}\", i);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","tests","mod.rs"],"content":"// FIXME: fix fixtures tests later\nmod fixtures;\nmod smt;\nmod tree;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","tests","smt.rs"],"content":"#[cfg(feature = \"smtc\")]\nuse std::convert::TryInto;\n\nuse crate::*;\nuse blake2b_rs::{Blake2b, Blake2bBuilder};\nuse default_store::DefaultStore;\n#[cfg(feature = \"smtc\")]\nuse hex::decode;\nuse proptest::prelude::*;\nuse traits::Hasher;\n\n#[cfg(feature = \"smtc\")]\nfn str_to_h256(src: \u0026str) -\u003e H256 {\n    let src = decode(src).unwrap();\n    assert!(src.len() == 32);\n    let data: [u8; 32] = src.try_into().unwrap();\n    H256::from(data)\n}\n\n#[cfg(feature = \"smtc\")]\nfn str_to_vec(src: \u0026str) -\u003e Vec\u003cu8\u003e {\n    decode(src).unwrap()\n}\n\n#[cfg(feature = \"smtc\")]\n#[test]\nfn test_ckb_smt_verify1() {\n    let key = str_to_h256(\"381dc5391dab099da5e28acd1ad859a051cf18ace804d037f12819c6fbc0e18b\");\n    let val = str_to_h256(\"9158ce9b0e11dd150ba2ae5d55c1db04b1c5986ec626f2e38a93fe8ad0b2923b\");\n    let root_hash = str_to_h256(\"ebe0fab376cd802d364eeb44af20c67a74d6183a33928fead163120ef12e6e06\");\n    let proof = str_to_vec(\n        \"4c4fff51ff322de8a89fe589987f97220cfcb6820bd798b31a0b56ffea221093d35f909e580b00000000000000000000000000000000000000000000000000000000000000\");\n\n    let builder = SMTBuilder::new();\n    let builder = builder.insert(\u0026key, \u0026val).unwrap();\n\n    let smt = builder.build().unwrap();\n    assert!(smt.verify(\u0026root_hash, \u0026proof).is_ok());\n}\n\n#[cfg(feature = \"smtc\")]\n#[test]\nfn test_ckb_smt_verify2() {\n    let key = str_to_h256(\"a9bb945be71f0bd2757d33d2465b6387383da42f321072e47472f0c9c7428a8a\");\n    let val = str_to_h256(\"a939a47335f777eac4c40fbc0970e25f832a24e1d55adc45a7b76d63fe364e82\");\n    let root_hash = str_to_h256(\"6e5c722644cd55cef8c4ed886cd8b44027ae9ed129e70a4b67d87be1c6857842\");\n    let proof = str_to_vec(\n        \"4c4fff51fa8aaa2aece17b92ec3f202a40a09f7286522bae1e5581a2a49195ab6781b1b8090000000000000000000000000000000000000000000000000000000000000000\");\n\n    let builder = SMTBuilder::new();\n    let builder = builder.insert(\u0026key, \u0026val).unwrap();\n\n    let smt = builder.build().unwrap();\n    assert!(smt.verify(\u0026root_hash, \u0026proof).is_ok());\n}\n\n#[cfg(feature = \"smtc\")]\n#[test]\nfn test_ckb_smt_verify3() {\n    let key = str_to_h256(\"e8c0265680a02b680b6cbc880348f062b825b28e237da7169aded4bcac0a04e5\");\n    let val = str_to_h256(\"2ca41595841e46ce8e74ad749e5c3f1d17202150f99c3d8631233ebdd19b19eb\");\n    let root_hash = str_to_h256(\"c8f513901e34383bcec57c368628ce66da7496df0a180ee1e021df3d97cb8f7b\");\n    let proof = str_to_vec(\n        \"4c4fff51fa8aaa2aece17b92ec3f202a40a09f7286522bae1e5581a2a49195ab6781b1b8090000000000000000000000000000000000000000000000000000000000000000\");\n\n    let builder = SMTBuilder::new();\n    let builder = builder.insert(\u0026key, \u0026val).unwrap();\n\n    let smt = builder.build().unwrap();\n    assert!(smt.verify(\u0026root_hash, \u0026proof).is_ok());\n}\n\n#[cfg(feature = \"smtc\")]\n#[test]\nfn test_ckb_smt_verify_invalid() {\n    let key = str_to_h256(\"e8c0265680a02b680b6cbc880348f062b825b28e237da7169aded4bcac0a04e5\");\n    let val = str_to_h256(\"2ca41595841e46ce8e74ad749e5c3f1d17202150f99c3d8631233ebdd19b19eb\");\n    let root_hash = str_to_h256(\"a4cbf1b69a848396ac759f362679e2b185ac87a17cba747d2db1ef6fd929042f\");\n    let proof =\n        str_to_vec(\"4c50fe32845309d34f132cd6f7ac6a7881962401adc35c19a18d4fffeb511b97eabf86\");\n\n    let builder = SMTBuilder::new();\n    let builder = builder.insert(\u0026key, \u0026val).unwrap();\n\n    let smt = builder.build().unwrap();\n    assert!(smt.verify(\u0026root_hash, \u0026proof).is_err());\n}\n\npub struct CkbBlake2bHasher(Blake2b);\n\nimpl Default for CkbBlake2bHasher {\n    fn default() -\u003e Self {\n        // NOTE: here we not set the `personal` since ckb_smt.c linked blake2b implementation from blake2b-rs\n        let blake2b = Blake2bBuilder::new(32)\n            .personal(b\"ckb-default-hash\")\n            .build();\n        CkbBlake2bHasher(blake2b)\n    }\n}\n\nimpl Hasher for CkbBlake2bHasher {\n    fn write_byte(\u0026mut self, b: u8) {\n        self.0.update(\u0026[b][..]);\n    }\n    fn write_h256(\u0026mut self, h: \u0026H256) {\n        self.0.update(h.as_slice());\n    }\n    fn finish(self) -\u003e H256 {\n        let mut hash = [0u8; 32];\n        self.0.finalize(\u0026mut hash);\n        hash.into()\n    }\n}\n\npub type CkbSMT = SparseMerkleTree\u003cCkbBlake2bHasher, H256, DefaultStore\u003cH256\u003e\u003e;\nproptest! {\n    #[test]\n    fn test_random_merkle_proof(key: [u8; 32], value: [u8;32]) {\n        let key = H256::from(key);\n        let value = H256::from(value);\n        const EXPECTED_PROOF_SIZE: usize = 16;\n\n        let mut tree = CkbSMT::default();\n        tree.update(key, value).expect(\"update\");\n        if !tree.is_empty() {\n            let proof = tree.merkle_proof(vec![key]).expect(\"proof\");\n            let compiled_proof = proof\n                .clone()\n                .compile(vec![key])\n                .expect(\"compile proof\");\n            assert!(proof.merkle_path().len() \u003c EXPECTED_PROOF_SIZE);\n            assert!(proof\n                    .verify::\u003cCkbBlake2bHasher\u003e(tree.root(), vec![(key, value)])\n                    .expect(\"verify\"));\n            assert!(compiled_proof\n                    .verify::\u003cCkbBlake2bHasher\u003e(tree.root(), vec![(key, value)])\n                    .expect(\"compiled verify\"));\n\n            let single_compiled_proof = compiled_proof\n                .extract_proof::\u003cCkbBlake2bHasher\u003e(vec![(key, value, true)])\n                .expect(\"compiled one proof\");\n            assert_eq!(compiled_proof.0, single_compiled_proof.0);\n            assert!(single_compiled_proof\n                    .verify::\u003cCkbBlake2bHasher\u003e(tree.root(), vec![(key, value)])\n                    .expect(\"verify compiled one proof\"));\n\n            #[cfg(feature = \"smtc\")]\n            {\n                let compiled_proof_bin: Vec\u003cu8\u003e = compiled_proof.into();\n                let smt_state = SMTBuilder::new();\n                let smt_state = smt_state.insert(\u0026key, \u0026value).unwrap();\n                let smt = smt_state.build().unwrap();\n                smt.verify(tree.root(), \u0026compiled_proof_bin).expect(\"verify with c\");\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","tests","tree.rs"],"content":"use crate::{\n    blake2b::Blake2bHasher, default_store::DefaultStore, error::Error, merge::MergeValue,\n    MerkleProof, *,\n};\nuse proptest::prelude::*;\nuse rand::prelude::{Rng, SliceRandom};\nuse std::collections::HashMap;\n\n#[allow(clippy::upper_case_acronyms)]\ntype SMT = SparseMerkleTree\u003cBlake2bHasher, H256, DefaultStore\u003cH256\u003e\u003e;\n\n#[test]\nfn test_default_root() {\n    let mut tree = SMT::default();\n    assert_eq!(tree.store().branches_map().len(), 0);\n    assert_eq!(tree.store().leaves_map().len(), 0);\n    assert_eq!(tree.root(), \u0026H256::zero());\n\n    // insert a key-value\n    tree.update(H256::zero(), [42u8; 32].into())\n        .expect(\"update\");\n    assert_ne!(tree.root(), \u0026H256::zero());\n    assert_ne!(tree.store().branches_map().len(), 0);\n    assert_ne!(tree.store().leaves_map().len(), 0);\n    assert_eq!(tree.get(\u0026H256::zero()).expect(\"get\"), [42u8; 32].into());\n    // update zero is to delete the key\n    tree.update(H256::zero(), H256::zero()).expect(\"update\");\n    assert_eq!(tree.root(), \u0026H256::zero());\n    assert_eq!(tree.get(\u0026H256::zero()).expect(\"get\"), H256::zero());\n}\n\n#[test]\nfn test_default_tree() {\n    let tree = SMT::default();\n    assert_eq!(tree.get(\u0026H256::zero()).expect(\"get\"), H256::zero());\n    let proof = tree.merkle_proof(vec![H256::zero()]).expect(\"merkle proof\");\n    let root = proof\n        .compute_root::\u003cBlake2bHasher\u003e(vec![(H256::zero(), H256::zero())])\n        .expect(\"root\");\n    assert_eq!(\u0026root, tree.root());\n    let proof = tree.merkle_proof(vec![H256::zero()]).expect(\"merkle proof\");\n    let root2 = proof\n        .compute_root::\u003cBlake2bHasher\u003e(vec![(H256::zero(), [42u8; 32].into())])\n        .expect(\"root\");\n    assert_ne!(\u0026root2, tree.root());\n}\n\n#[test]\nfn test_default_merkle_proof() {\n    let proof = MerkleProof::new(Default::default(), Default::default());\n    let result = proof.compute_root::\u003cBlake2bHasher\u003e(vec![([42u8; 32].into(), [42u8; 32].into())]);\n    assert_eq!(\n        result.unwrap_err(),\n        Error::IncorrectNumberOfLeaves {\n            expected: 0,\n            actual: 1\n        }\n    );\n\n    // FIXME: makes room for leaves\n    // let proof = MerkleProof::new(vec![Vec::new()], Default::default());\n    // let root = proof\n    //     .compute_root::\u003cBlake2bHasher\u003e(vec![([42u8; 32].into(), [42u8; 32].into())])\n    //     .expect(\"compute root\");\n    // assert_ne!(root, H256::zero());\n}\n\n#[test]\nfn test_merkle_root() {\n    fn new_blake2b() -\u003e blake2b_rs::Blake2b {\n        blake2b_rs::Blake2bBuilder::new(32).personal(b\"SMT\").build()\n    }\n\n    let mut tree = SMT::default();\n    for (i, word) in \"The quick brown fox jumps over the lazy dog\"\n        .split_whitespace()\n        .enumerate()\n    {\n        let key: H256 = {\n            let mut buf = [0u8; 32];\n            let mut hasher = new_blake2b();\n            hasher.update(\u0026(i as u32).to_le_bytes());\n            hasher.finalize(\u0026mut buf);\n            buf.into()\n        };\n        let value: H256 = {\n            let mut buf = [0u8; 32];\n            let mut hasher = new_blake2b();\n            hasher.update(word.as_bytes());\n            hasher.finalize(\u0026mut buf);\n            buf.into()\n        };\n        tree.update(key, value).expect(\"update\");\n    }\n\n    let expected_root: H256 = [\n        209, 214, 1, 128, 166, 207, 49, 89, 206, 78, 169, 88, 18, 243, 130, 61, 150, 45, 43, 54,\n        208, 20, 237, 20, 98, 69, 130, 120, 241, 169, 248, 211,\n    ]\n    .into();\n    assert_eq!(tree.store().leaves_map().len(), 9);\n    assert_eq!(tree.root(), \u0026expected_root);\n}\n\n#[test]\nfn test_zero_value_donot_change_root() {\n    let mut tree = SMT::default();\n    let key = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 1,\n    ]\n    .into();\n    let value = H256::zero();\n    tree.update(key, value).unwrap();\n    assert_eq!(tree.root(), \u0026H256::zero());\n    assert_eq!(tree.store().leaves_map().len(), 0);\n    assert_eq!(tree.store().branches_map().len(), 0);\n}\n\n#[test]\nfn test_zero_value_donot_change_store() {\n    let mut tree = SMT::default();\n    let key = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n    let value = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 1,\n    ]\n    .into();\n    tree.update(key, value).unwrap();\n    assert_ne!(tree.root(), \u0026H256::zero());\n    let root = *tree.root();\n    let store = tree.store().clone();\n\n    // insert a zero value leaf\n    let key = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 1,\n    ]\n    .into();\n    let value = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n    tree.update(key, value).unwrap();\n    assert_eq!(tree.root(), \u0026root);\n    assert_eq!(tree.store().leaves_map(), store.leaves_map());\n    assert_eq!(tree.store().branches_map(), store.branches_map());\n}\n\n#[test]\nfn test_delete_a_leaf() {\n    let mut tree = SMT::default();\n    let key = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n    let value = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 1,\n    ]\n    .into();\n    tree.update(key, value).unwrap();\n    assert_ne!(tree.root(), \u0026H256::zero());\n\n    let key = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 2,\n    ]\n    .into();\n\n    tree.update(key, value).unwrap();\n\n    let root = *tree.root();\n    let store = tree.store().clone();\n\n    // insert a leaf\n    let key = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 1,\n    ]\n    .into();\n    let value = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 1,\n    ]\n    .into();\n    tree.update(key, value).unwrap();\n    assert_ne!(tree.root(), \u0026root);\n\n    // delete a leaf\n    tree.update(key, H256::zero()).unwrap();\n    assert_eq!(tree.root(), \u0026root);\n    assert_eq!(tree.store().leaves_map(), store.leaves_map());\n    assert_eq!(tree.store().branches_map(), store.branches_map());\n}\n\n#[test]\nfn test_sibling_key_get() {\n    {\n        let mut tree = SMT::default();\n        let key = H256::from([\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]);\n        let value = H256::from([1u8; 32]);\n        tree.update(key, value).expect(\"update\");\n\n        let sibling_key = H256::from([\n            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]);\n        // get non exists sibling key should return zero value;\n        assert_eq!(H256::zero(), tree.get(\u0026sibling_key).unwrap());\n    }\n\n    {\n        let mut tree = SMT::default();\n        let key = H256::from([\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]);\n        let value = H256::from([1u8; 32]);\n        tree.update(key, value).expect(\"update\");\n\n        let sibling_key = H256::from([\n            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]);\n        let sibling_value = H256::from([2u8; 32]);\n        tree.update(sibling_key, sibling_value).expect(\"update\");\n        // get sibling key should return corresponding value\n        assert_eq!(value, tree.get(\u0026key).unwrap());\n        assert_eq!(sibling_value, tree.get(\u0026sibling_key).unwrap());\n    }\n}\n\nfn test_construct(key: H256, value: H256) {\n    // insert same value to sibling key will construct a different root\n\n    let mut tree = SMT::default();\n    tree.update(key, value).expect(\"update\");\n\n    let mut sibling_key = key;\n    if sibling_key.get_bit(0) {\n        sibling_key.clear_bit(0);\n    } else {\n        sibling_key.set_bit(0);\n    }\n    let mut tree2 = SMT::default();\n    tree2.update(sibling_key, value).expect(\"update\");\n    assert_ne!(tree.root(), tree2.root());\n}\n\nfn test_update(key: H256, value: H256) {\n    let mut tree = SMT::default();\n    tree.update(key, value).expect(\"update\");\n    assert_eq!(tree.get(\u0026key), Ok(value));\n}\n\n#[cfg(not(feature = \"trie\"))]\nfn test_update_tree_store(key: H256, value: H256, value2: H256) {\n    const EXPECTED_LEAVES_LEN: usize = 1;\n\n    let mut tree = SMT::default();\n    tree.update(key, value).expect(\"update\");\n    assert_eq!(tree.store().branches_map().len(), 256);\n    assert_eq!(tree.store().leaves_map().len(), EXPECTED_LEAVES_LEN);\n    tree.update(key, value2).expect(\"update\");\n    assert_eq!(tree.store().branches_map().len(), 256);\n    assert_eq!(tree.store().leaves_map().len(), EXPECTED_LEAVES_LEN);\n    assert_eq!(tree.get(\u0026key), Ok(value2));\n}\n\nfn test_merkle_proof(key: H256, value: H256) {\n    const EXPECTED_MERKLE_PATH_SIZE: usize = 1;\n\n    let mut tree = SMT::default();\n    tree.update(key, value).expect(\"update\");\n    if !tree.is_empty() {\n        let proof = tree.merkle_proof(vec![key]).expect(\"proof\");\n        let compiled_proof = proof.clone().compile(vec![key]).expect(\"compile proof\");\n        assert!(proof.merkle_path().len() \u003c EXPECTED_MERKLE_PATH_SIZE);\n        assert!(proof\n            .verify::\u003cBlake2bHasher\u003e(tree.root(), vec![(key, value)])\n            .expect(\"verify\"));\n        assert!(compiled_proof\n            .verify::\u003cBlake2bHasher\u003e(tree.root(), vec![(key, value)])\n            .expect(\"compiled verify\"));\n\n        let single_compiled_proof = compiled_proof\n            .extract_proof::\u003cBlake2bHasher\u003e(vec![(key, value, true)])\n            .expect(\"compute one proof\");\n        assert!(single_compiled_proof\n            .verify::\u003cBlake2bHasher\u003e(tree.root(), vec![(key, value)])\n            .expect(\"verify compiled proof\"));\n    }\n}\n\nfn new_smt(pairs: Vec\u003c(H256, H256)\u003e) -\u003e SMT {\n    let mut smt = SMT::default();\n    for (key, value) in pairs {\n        smt.update(key, value).unwrap();\n    }\n    smt\n}\n\nfn leaves(\n    min_leaves: usize,\n    max_leaves: usize,\n) -\u003e impl Strategy\u003cValue = (Vec\u003c(H256, H256)\u003e, usize)\u003e {\n    prop::collection::vec(\n        prop::array::uniform2(prop::array::uniform32(0u8..)),\n        min_leaves..=max_leaves,\n    )\n    .prop_flat_map(|mut pairs| {\n        pairs.dedup_by_key(|[k, _v]| *k);\n        let len = pairs.len();\n        (\n            Just(\n                pairs\n                    .into_iter()\n                    .map(|[k, v]| (k.into(), v.into()))\n                    .collect(),\n            ),\n            core::cmp::min(1, len)..=len,\n        )\n    })\n}\n\nfn leaves_bitmap(max_leaves_bitmap: usize) -\u003e impl Strategy\u003cValue = Vec\u003cH256\u003e\u003e {\n    prop::collection::vec(prop::array::uniform32(0u8..), max_leaves_bitmap).prop_flat_map(\n        |leaves_bitmap| Just(leaves_bitmap.into_iter().map(|item| item.into()).collect()),\n    )\n}\n\nfn merkle_proof(max_proof: usize) -\u003e impl Strategy\u003cValue = Vec\u003cMergeValue\u003e\u003e {\n    prop::collection::vec(prop::array::uniform32(0u8..), max_proof).prop_flat_map(|proof| {\n        Just(\n            proof\n                .into_iter()\n                .map(|item| MergeValue::from_h256(item.into()))\n                .collect(),\n        )\n    })\n}\n\nproptest! {\n    #[test]\n    fn test_h256(key: [u8; 32], key2: [u8; 32]) {\n        let mut list1: Vec\u003cH256\u003e = vec![key.into() , key2.into()];\n        let mut list2 = list1.clone();\n        // sort H256\n        list1.sort_unstable_by_key(|k| *k);\n        // sort by high bits to lower bits\n        list2.sort_unstable_by(|k1, k2| {\n            for i in (0u8..=255).rev() {\n                let b1 = if k1.get_bit(i) { 1 } else { 0 };\n                let b2 = if k2.get_bit(i) { 1 } else { 0 };\n                let o = b1.cmp(\u0026b2);\n                if o != std::cmp::Ordering::Equal {\n                    return o;\n                }\n            }\n            std::cmp::Ordering::Equal\n        });\n        assert_eq!(list1, list2);\n    }\n\n    #[test]\n    fn test_h256_copy_bits(start: u8) {\n        let one: H256 = [255u8; 32].into();\n        let target = one.copy_bits(start);\n        for i in start..=core::u8::MAX {\n            assert_eq!(one.get_bit(i), target.get_bit(i));\n        }\n        for i in 0..start {\n            assert!(!target.get_bit(i));\n        }\n    }\n\n    #[test]\n    fn test_random_update(key: [u8; 32], value: [u8;32]) {\n        test_update(key.into(), value.into());\n    }\n\n    #[cfg(not(feature = \"trie\"))]\n    #[test]\n    fn test_random_update_tree_store(key: [u8;32], value: [u8;32], value2: [u8;32]) {\n        test_update_tree_store(key.into(), value.into(), value2.into());\n    }\n\n    #[test]\n    fn test_random_construct(key: [u8;32], value: [u8;32]) {\n        test_construct(key.into(), value.into());\n    }\n\n    #[test]\n    fn test_random_merkle_proof(key: [u8; 32], value: [u8;32]) {\n        test_merkle_proof(key.into(), value.into());\n    }\n\n    #[test]\n    fn test_smt_single_leaf_small((pairs, _n) in leaves(1, 50)){\n        let smt = new_smt(pairs.clone());\n        for (k, v) in pairs {\n            let proof = smt.merkle_proof(vec![k]).expect(\"gen proof\");\n            let compiled_proof = proof.clone().compile(vec![k]).expect(\"compile proof\");\n            assert!(proof.verify::\u003cBlake2bHasher\u003e(smt.root(), vec![(k, v)]).expect(\"verify proof\"));\n            assert!(compiled_proof.verify::\u003cBlake2bHasher\u003e(smt.root(), vec![(k, v)]).expect(\"verify compiled proof\"));\n\n            let single_compiled_proof = compiled_proof\n                .extract_proof::\u003cBlake2bHasher\u003e(vec![(k, v, true)])\n                .expect(\"compute one proof\");\n            assert!(single_compiled_proof.verify::\u003cBlake2bHasher\u003e(smt.root(), vec![(k, v)]).expect(\"verify compiled one proof\"));\n        }\n    }\n\n    #[test]\n    fn test_smt_single_leaf_large((pairs, _n) in leaves(50, 100)){\n        let smt = new_smt(pairs.clone());\n        for (k, v) in pairs {\n            let proof = smt.merkle_proof(vec![k]).expect(\"gen proof\");\n            let compiled_proof = proof.clone().compile(vec![k]).expect(\"compile proof\");\n            assert!(proof.verify::\u003cBlake2bHasher\u003e(smt.root(), vec![(k, v)]).expect(\"verify proof\"));\n            assert!(compiled_proof.verify::\u003cBlake2bHasher\u003e(smt.root(), vec![(k, v)]).expect(\"verify compiled proof\"));\n\n            let single_compiled_proof = compiled_proof\n                .extract_proof::\u003cBlake2bHasher\u003e(vec![(k, v, true)])\n                .expect(\"compute one proof\");\n            assert!(single_compiled_proof.verify::\u003cBlake2bHasher\u003e(smt.root(), vec![(k, v)]).expect(\"verify compiled one proof\"));\n        }\n    }\n\n    #[test]\n    fn test_smt_multi_leaves_small((pairs, n) in leaves(1, 50)){\n        let smt = new_smt(pairs.clone());\n        let keys: Vec\u003c_\u003e = pairs.iter().take(n).map(|(k, _v)| *k).collect();\n        let proof = smt.merkle_proof(keys.clone()).expect(\"gen proof\");\n        let data: Vec\u003c(H256, H256)\u003e = pairs.into_iter().take(n).collect();\n        let compiled_proof = proof.clone().compile(keys).expect(\"compile proof\");\n        assert!(proof.verify::\u003cBlake2bHasher\u003e(smt.root(), data.clone()).expect(\"verify proof\"));\n        assert!(compiled_proof.verify::\u003cBlake2bHasher\u003e(smt.root(), data.clone()).expect(\"verify compiled proof\"));\n\n        test_sub_proof(\u0026compiled_proof, \u0026smt, \u0026data, 20);\n    }\n\n    #[test]\n    fn test_smt_multi_leaves_large((pairs, _n) in leaves(50, 100)){\n        let n = 20;\n        let smt = new_smt(pairs.clone());\n        let keys: Vec\u003c_\u003e = pairs.iter().take(n).map(|(k, _v)| *k).collect();\n        let proof = smt.merkle_proof(keys.clone()).expect(\"gen proof\");\n        let data: Vec\u003c(H256, H256)\u003e = pairs.into_iter().take(n).collect();\n        let compiled_proof = proof.clone().compile(keys).expect(\"compile proof\");\n        assert!(proof.verify::\u003cBlake2bHasher\u003e(smt.root(), data.clone()).expect(\"verify proof\"));\n        assert!(compiled_proof.verify::\u003cBlake2bHasher\u003e(smt.root(), data.clone()).expect(\"verify compiled proof\"));\n\n        test_sub_proof(\u0026compiled_proof, \u0026smt, \u0026data, 20);\n    }\n\n    #[test]\n    fn test_smt_non_exists_leaves((pairs, _n) in leaves(1, 20), (pairs2, _n2) in leaves(1, 5)){\n        if pairs.iter().all(|(k, _v)| pairs2.iter().all(|(k2, _v2)| k2 != k)) {\n            let smt = new_smt(pairs);\n            let non_exists_keys: Vec\u003c_\u003e = pairs2.into_iter().map(|(k, _v)|k).collect();\n            let proof = smt.merkle_proof(non_exists_keys.clone()).expect(\"gen proof\");\n            let data: Vec\u003c(H256, H256)\u003e = non_exists_keys.iter().map(|k|(*k, H256::zero())).collect();\n            let compiled_proof = proof.clone().compile(non_exists_keys).expect(\"compile proof\");\n            assert!(proof.verify::\u003cBlake2bHasher\u003e(smt.root(), data.clone()).expect(\"verify proof\"));\n            assert!(compiled_proof.verify::\u003cBlake2bHasher\u003e(smt.root(), data.clone()).expect(\"verify compiled proof\"));\n\n            test_sub_proof(\u0026compiled_proof, \u0026smt, \u0026data, 20);\n        }\n    }\n\n    #[test]\n    fn test_smt_non_existssss_leaves_mix((pairs, _n) in leaves(1, 20), (pairs2, _n2) in leaves(1, 5)){\n        if pairs.iter().all(|(k, _v)| pairs2.iter().all(|(k2, _v2)| k2 != k)) {\n            let smt = new_smt(pairs.clone());\n            let exists_keys: Vec\u003c_\u003e = pairs.into_iter().map(|(k, _v)|k).collect();\n            let non_exists_keys: Vec\u003c_\u003e = pairs2.into_iter().map(|(k, _v)|k).collect();\n            let exists_keys_len = std::cmp::max(exists_keys.len() / 2, 1);\n            let non_exists_keys_len = std::cmp::max(non_exists_keys.len() / 2, 1);\n            let mut keys: Vec\u003c_\u003e = exists_keys.into_iter().take(exists_keys_len).chain(non_exists_keys.into_iter().take(non_exists_keys_len)).collect();\n            keys.dedup();\n            let proof = smt.merkle_proof(keys.clone()).expect(\"gen proof\");\n            let data: Vec\u003c(H256, H256)\u003e = keys.iter().map(|k|(*k, smt.get(k).expect(\"get\"))).collect();\n            let compiled_proof = proof.clone().compile(keys.clone()).expect(\"compile proof\");\n            assert!(proof.verify::\u003cBlake2bHasher\u003e(smt.root(), data.clone()).expect(\"verify proof\"));\n            assert!(compiled_proof.verify::\u003cBlake2bHasher\u003e(smt.root(), data.clone()).expect(\"verify compiled proof\"));\n\n            test_sub_proof(\u0026compiled_proof, \u0026smt, \u0026data, 20);\n        }\n    }\n\n    #[test]\n    fn test_update_smt_tree_store((pairs, n) in leaves(1, 20)) {\n        let smt = new_smt(pairs.clone());\n        for (k, v) in pairs.into_iter().take(n) {\n            assert_eq!(smt.get(\u0026k), Ok(v));\n        }\n    }\n\n    #[test]\n    fn test_from_store((pairs, _n) in leaves(1, 20)) {\n        let smt = new_smt(pairs.clone());\n        let smt2 = SMT::new_with_store(smt.store().clone()).expect(\"from store\");\n        assert_eq!(smt.root(), smt2.root());\n    }\n\n    #[test]\n    fn test_smt_update_all((pairs, _n) in leaves(1, 20), (pairs2, _n2) in leaves(1, 10)){\n        let mut smt = new_smt(pairs.clone());\n        for (k, v) in pairs2.clone().into_iter() {\n            smt.update(k, v).expect(\"update\");\n        }\n        let mut smt2 = new_smt(pairs);\n        smt2.update_all(pairs2).expect(\"update all\");\n        assert_eq!(smt.root(), smt2.root());\n    }\n\n    #[test]\n    fn test_smt_random_insert_order((pairs, _n) in leaves(5, 50)){\n        let smt = new_smt(pairs.clone());\n        let root = *smt.root();\n\n        let mut pairs = pairs;\n        let mut rng = rand::thread_rng();\n        for _i in 0..5 {\n            // shuffle\n            pairs.shuffle(\u0026mut rng);\n\n            // insert to smt in random order\n            let smt2 = new_smt(pairs.clone());\n            assert_eq!(root, *smt2.root());\n\n            // check leaves\n            for (k, v) in \u0026pairs {\n                assert_eq!(\u0026smt2.get(k).unwrap(), v, \"key value must be consisted\");\n\n                let origin_proof = smt.merkle_proof(vec![*k]).unwrap();\n                let proof = smt2.merkle_proof(vec![*k]).unwrap();\n                assert_eq!(origin_proof, proof, \"merkle proof must be consisted\");\n\n                let calculated_root = proof.compute_root::\u003cBlake2bHasher\u003e(vec![(*k, *v)]).unwrap();\n                assert_eq!(root, calculated_root, \"root must be consisted\");\n            }\n        }\n    }\n\n    #[test]\n    fn test_smt_update_with_zero_values((pairs, _n) in leaves(5, 30)){\n        let mut rng = rand::thread_rng();\n        let len =  rng.gen_range(0..pairs.len());\n        let mut smt = new_smt(pairs[..len].to_vec());\n        let root = *smt.root();\n\n        // insert zero values\n        for (k, _v) in pairs[len..].iter() {\n            smt.update(*k, H256::zero()).unwrap();\n        }\n        // check root\n        let current_root = *smt.root();\n        assert_eq!(root, current_root);\n        // check inserted pairs\n        for (k, v) in pairs[..len].iter() {\n            let value = smt.get(k).unwrap();\n            assert_eq!(v, \u0026value);\n        }\n    }\n\n    #[test]\n    fn test_zero_value_should_delete_branch((pairs, _n) in leaves(5, 30)){\n        let mut smt = new_smt(pairs.clone());\n        for (k, _v) in pairs {\n            smt.update(k, H256::zero()).unwrap();\n        }\n        assert_eq!(0, smt.store().branches_map().len());\n    }\n\n    #[test]\n    fn test_smt_not_crash(\n        (leaves, _n) in leaves(0, 30),\n        leaves_bitmap in leaves_bitmap(30),\n        proof in merkle_proof(50)\n    ){\n        let proof = MerkleProof::new(leaves_bitmap, proof);\n        // test compute_root not crash\n        let _result = proof.clone().compute_root::\u003cBlake2bHasher\u003e(leaves.clone());\n        // test compile not crash\n        let _result = proof.compile(leaves.iter().map(|(k, _v)| *k).collect());\n    }\n\n    #[test]\n    fn test_try_crash_compiled_merkle_proof((leaves, _n) in leaves(0, 30)) {\n        // construct cases to crush compiled merkle proof\n        let case1 = [0x50, 0x48, 0x4C].to_vec();\n        let case2 = [0x48, 0x4C].to_vec();\n        let case3 = [0x4C, 0x50].to_vec();\n        let case4 = [0x4C, 0x48].to_vec();\n        let case5 = [0x50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                     0, 0, 0, 0].to_vec();\n        let case6 = [0x48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                     0, 0, 0, 0].to_vec();\n        let case7 = [0x4C, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                     0, 0, 0, 0].to_vec();\n\n        for case in [case1, case2, case3, case4, case5, case6, case7].iter() {\n            let proof = CompiledMerkleProof(case.to_vec());\n            // test compute root not crash\n            let _result = proof.compute_root::\u003cBlake2bHasher\u003e(leaves.clone());\n        }\n    }\n}\n\nfn parse_h256(s: \u0026str) -\u003e H256 {\n    let data = hex::decode(s).unwrap();\n    let mut inner = [0u8; 32];\n    inner.copy_from_slice(\u0026data);\n    H256::from(inner)\n}\n\n#[test]\nfn test_v0_2_broken_sample() {\n    let keys = vec![\n        \"0000000000000000000000000000000000000000000000000000000000000000\",\n        \"0000000000000000000000000000000000000000000000000000000000000002\",\n        \"0000000000000000000000000000000000000000000000000000000000000003\",\n        \"0000000000000000000000000000000000000000000000000000000000000004\",\n        \"0000000000000000000000000000000000000000000000000000000000000005\",\n        \"0000000000000000000000000000000000000000000000000000000000000006\",\n        \"000000000000000000000000000000000000000000000000000000000000000e\",\n        \"f652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f\",\n        \"f652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d40\",\n        \"5eff886ea0ce6ca488a3d6e336d6c0f75f46d19b42c06ce5ee98e42c96d256c7\",\n        \"6d5257204ebe7d88fd91ae87941cb2dd9d8062b64ae5a2bd2d28ec40b9fbf6df\",\n    ]\n    .into_iter()\n    .map(parse_h256);\n\n    let values = vec![\n        \"000000000000000000000000c8328aabcd9b9e8e64fbc566c4385c3bdeb219d7\",\n        \"000000000000000000000001c8328aabcd9b9e8e64fbc566c4385c3bdeb219d7\",\n        \"0000384000001c2000000e1000000708000002580000012c000000780000003c\",\n        \"000000000000000000093a80000546000002a300000151800000e10000007080\",\n        \"000000000000000000000000000000000000000000000000000000000000000f\",\n        \"0000000000000000000000000000000000000000000000000000000000000001\",\n        \"00000000000000000000000000000000000000000000000000071afd498d0000\",\n        \"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",\n        \"0000000000000000000000000000000000000000000000000000000000000000\",\n        \"0000000000000000000000000000000000000000000000000000000000000001\",\n        \"0000000000000000000000000000000000000000000000000000000000000000\",\n    ]\n    .into_iter()\n    .map(parse_h256);\n\n    let mut pairs = keys.zip(values).collect::\u003cVec\u003c_\u003e\u003e();\n    let smt = new_smt(pairs.clone());\n    let base_root = *smt.root();\n\n    // insert in random order\n    let mut rng = rand::thread_rng();\n    for _i in 0..10 {\n        pairs.shuffle(\u0026mut rng);\n        let smt = new_smt(pairs.clone());\n        let current_root = *smt.root();\n        assert_eq!(base_root, current_root);\n    }\n}\n\n#[test]\nfn test_v0_3_broken_sample() {\n    let k1 = [\n        0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ];\n    let v1 = [\n        108, 153, 9, 238, 15, 28, 173, 182, 146, 77, 52, 203, 162, 151, 125, 76, 55, 176, 192, 104,\n        170, 5, 193, 174, 137, 255, 169, 176, 132, 64, 199, 115,\n    ];\n    let k2 = [\n        1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ];\n    let v2 = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ];\n    let k3 = [\n        1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ];\n    let v3 = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ];\n\n    let mut smt = SMT::default();\n    // inserted keys shouldn't interfere with each other\n    assert_ne!(k1, k2);\n    assert_ne!(k2, k3);\n    assert_ne!(k1, k3);\n    smt.update(k1.into(), v1.into()).unwrap();\n    smt.update(k2.into(), v2.into()).unwrap();\n    smt.update(k3.into(), v3.into()).unwrap();\n    assert_eq!(smt.get(\u0026k1.into()).unwrap(), v1.into());\n}\n\n#[test]\nfn test_trie_broken_sample() {\n    let keys = vec![\n        \"f652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d40\",\n        \"5eff886ea0ce6ca488a3d6e336d6c0f75f46d19b42c06ce5ee98e42c96d256c7\",\n        \"6d5257204ebe7d88fd91ae87941cb2dd9d8062b64ae5a2bd2d28ec40b9fbf6df\",\n    ]\n    .into_iter()\n    .map(parse_h256);\n\n    let values = vec![\n        \"0000000000000000000000000000000000000000000000000000000000000001\",\n        \"0000000000000000000000000000000000000000000000000000000000000002\",\n        \"0000000000000000000000000000000000000000000000000000000000000003\",\n    ]\n    .into_iter()\n    .map(parse_h256);\n\n    let mut pairs = keys.zip(values).collect::\u003cVec\u003c_\u003e\u003e();\n    let smt = new_smt(pairs.clone());\n    let base_branches = smt.store().branches_map();\n    pairs.reverse();\n    let smt = new_smt(pairs.clone());\n    let current_branches = smt.store().branches_map();\n    assert_eq!(base_branches, current_branches);\n}\n\n#[test]\nfn test_trie_broken_sample_02() {\n    let key1: H256 = [\n        1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n    let key2: H256 = [\n        2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n    let key3: H256 = [\n        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n\n    let pairs = vec![\n        (key1, [1; 32].into()),\n        (key2, [2; 32].into()),\n        (key3, [0u8; 32].into()),\n    ];\n    let smt = new_smt(pairs);\n    let kv_state: [([u8; 32], [u8; 32]); 1] = [(\n        [\n            3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ],\n        [0; 32],\n    )];\n\n    for (k, v) in kv_state {\n        assert_eq!(smt.get(\u0026k.into()).unwrap(), v.into());\n    }\n\n    let keys: Vec\u003cH256\u003e = kv_state.iter().map(|kv| kv.0.into()).collect();\n\n    let proof = smt\n        .merkle_proof(keys.clone())\n        .unwrap()\n        .compile(keys)\n        .unwrap();\n\n    let root1 = proof\n        .compute_root::\u003cBlake2bHasher\u003e(\n            kv_state\n                .iter()\n                .map(|(k, v)| (k.clone().into(), v.clone().into()))\n                .collect(),\n        )\n        .unwrap();\n    assert_eq!(smt.root(), \u0026root1);\n}\n\n#[test]\nfn test_trie_broken_sample_03() {\n    let mut smt = SMT::default();\n    smt.update(\n        [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]\n        .into(),\n        [\n            231, 17, 197, 236, 8, 0, 141, 194, 15, 253, 234, 189, 224, 53, 255, 173, 117, 8, 221,\n            5, 34, 5, 198, 250, 99, 32, 229, 13, 222, 40, 203, 90,\n        ]\n        .into(),\n    )\n    .unwrap();\n    smt.update(\n        [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]\n        .into(),\n        [\n            231, 17, 197, 236, 8, 0, 141, 194, 15, 253, 234, 189, 224, 53, 255, 173, 117, 8, 221,\n            5, 34, 5, 198, 250, 99, 32, 229, 13, 222, 40, 203, 90,\n        ]\n        .into(),\n    )\n    .unwrap();\n    smt.update(\n        [\n            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]\n        .into(),\n        [\n            105, 112, 48, 175, 83, 217, 158, 108, 243, 136, 9, 21, 192, 91, 211, 190, 218, 240, 89,\n            241, 63, 137, 128, 133, 65, 169, 51, 33, 49, 123, 118, 132,\n        ]\n        .into(),\n    )\n    .unwrap();\n    smt.update(\n        [\n            2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]\n        .into(),\n        [\n            189, 150, 22, 8, 143, 248, 180, 169, 68, 195, 31, 28, 34, 180, 182, 223, 195, 37, 117,\n            197, 229, 144, 229, 64, 230, 250, 21, 205, 225, 32, 135, 195,\n        ]\n        .into(),\n    )\n    .unwrap();\n    smt.update(\n        [\n            3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]\n        .into(),\n        [\n            153, 75, 31, 235, 146, 228, 224, 228, 237, 250, 34, 227, 139, 8, 213, 118, 25, 114, 82,\n            242, 215, 172, 184, 100, 205, 85, 47, 116, 140, 238, 175, 190,\n        ]\n        .into(),\n    )\n    .unwrap();\n    smt.update(\n        [\n            4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]\n        .into(),\n        [\n            242, 174, 6, 108, 205, 74, 137, 57, 15, 248, 35, 35, 255, 58, 93, 74, 183, 47, 194, 40,\n            134, 3, 215, 100, 80, 51, 28, 251, 96, 19, 201, 170,\n        ]\n        .into(),\n    )\n    .unwrap();\n    smt.update(\n        [\n            5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]\n        .into(),\n        [\n            88, 83, 226, 107, 201, 255, 207, 189, 197, 145, 113, 95, 209, 238, 110, 9, 82, 215,\n            232, 183, 203, 220, 194, 167, 21, 189, 239, 238, 178, 149, 153, 44,\n        ]\n        .into(),\n    )\n    .unwrap();\n    smt.update(\n        [\n            6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]\n        .into(),\n        [\n            80, 177, 52, 81, 182, 121, 67, 120, 77, 19, 201, 42, 75, 136, 19, 238, 112, 23, 204,\n            103, 20, 157, 53, 235, 80, 70, 126, 79, 9, 35, 11, 158,\n        ]\n        .into(),\n    )\n    .unwrap();\n    let key7 = H256::from([\n        7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]);\n    let v7 = H256::from([\n        103, 245, 93, 107, 47, 213, 28, 173, 216, 92, 109, 17, 151, 57, 101, 4, 44, 145, 116, 215,\n        185, 218, 144, 244, 131, 160, 148, 58, 247, 226, 240, 55,\n    ]);\n    let proof = smt\n        .merkle_proof(vec![key7])\n        .unwrap()\n        .compile(vec![key7])\n        .unwrap();\n    // Compute root with different value than actually in smt.\n    let root = proof\n        .compute_root::\u003cBlake2bHasher\u003e(vec![(key7, v7)])\n        .unwrap();\n    // Compute root by updating smt.\n    smt.update(key7, v7).unwrap();\n    // Expect them to be the same.\n    assert_eq!(*smt.root(), root);\n}\n\n#[test]\nfn test_replay_to_pass_proof() {\n    let key1: H256 = [\n        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n    let key2: H256 = [\n        2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n    let key3: H256 = [\n        3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n    let key4: H256 = [\n        4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n\n    let existing: H256 = [\n        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n    let non_existing: H256 = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n    let other_value: H256 = [\n        0, 0, 0xff, 0, 0, 0, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0xff,\n    ]\n    .into();\n    let pairs = vec![\n        (key1, existing),\n        (key2, non_existing),\n        (key3, non_existing),\n        (key4, non_existing),\n    ];\n    let smt = new_smt(pairs);\n    let leaf_a_bl = vec![(key1, H256::zero())];\n    let leaf_c = vec![(key3, non_existing)];\n    let leaf_other = vec![(key3, other_value)];\n    let proofc = smt\n        .merkle_proof(leaf_c.clone().into_iter().map(|(k, _)| k).collect())\n        .expect(\"gen proof\");\n    let compiled_proof = proofc.clone().compile(vec![key3]).expect(\"compile proof\");\n\n    println!(\"verify ok case\");\n    assert!(proofc\n        .clone()\n        .verify::\u003cBlake2bHasher\u003e(smt.root(), leaf_c.clone())\n        .expect(\"verify\"));\n    println!(\"verify not ok case\");\n    assert!(!proofc\n        .clone()\n        .verify::\u003cBlake2bHasher\u003e(smt.root(), leaf_other)\n        .expect(\"verify\"));\n\n    println!(\"merkle proof, leaf is faked\");\n    assert!(!proofc\n        .verify::\u003cBlake2bHasher\u003e(smt.root(), leaf_a_bl.clone())\n        .expect(\"verify\"));\n\n    println!(\"compiled merkle proof, leaf is faked\");\n    assert!(!compiled_proof\n        .verify::\u003cBlake2bHasher\u003e(smt.root(), leaf_a_bl)\n        .expect(\"verify compiled proof\"));\n\n    test_sub_proof(\u0026compiled_proof, \u0026smt, \u0026leaf_c, 20);\n}\n\n#[test]\nfn test_sibling_leaf() {\n    fn gen_rand_h256() -\u003e H256 {\n        let mut rng = rand::thread_rng();\n        let rand_data: [u8; 32] = rng.gen();\n        H256::from(rand_data)\n    }\n    let rand_key = gen_rand_h256();\n    let mut sibling_key = rand_key;\n    if rand_key.is_right(0) {\n        sibling_key.clear_bit(0);\n    } else {\n        sibling_key.set_bit(0);\n    }\n    let pairs = vec![(rand_key, gen_rand_h256()), (sibling_key, gen_rand_h256())];\n    let keys = vec![rand_key, sibling_key];\n    let smt = new_smt(pairs.clone());\n    let proof = smt.merkle_proof(keys).expect(\"gen proof\");\n    assert!(proof\n        .verify::\u003cBlake2bHasher\u003e(smt.root(), pairs)\n        .expect(\"verify\"));\n}\n\n#[test]\nfn test_max_stack_size() {\n    fn gen_h256(height: u8) -\u003e H256 {\n        // The key path is first go right `256 - height` times then go left `height` times.\n        let mut key = H256::zero();\n        for h in height..=255 {\n            key.set_bit(h);\n        }\n        key\n    }\n    let mut pairs: Vec\u003c_\u003e = (0..=255)\n        .map(|height| (gen_h256(height), gen_h256(1)))\n        .collect();\n    // Most left key\n    pairs.push((H256::zero(), gen_h256(1)));\n    {\n        // A pair of sibling keys in between\n        let mut left_key = H256::zero();\n        for h in 12..56 {\n            left_key.set_bit(h);\n        }\n        let mut right_key = left_key;\n        right_key.set_bit(0);\n        pairs.push((left_key, gen_h256(1)));\n        pairs.push((right_key, gen_h256(1)));\n    }\n\n    let keys: Vec\u003c_\u003e = pairs.iter().map(|(key, _)| *key).collect();\n    let smt = new_smt(pairs.clone());\n    let proof = smt.merkle_proof(keys.clone()).expect(\"gen proof\");\n    let compiled_proof = proof.compile(keys).expect(\"compile proof\");\n\n    assert!(compiled_proof\n        .verify::\u003cBlake2bHasher\u003e(smt.root(), pairs.clone())\n        .expect(\"verify\"));\n\n    test_sub_proof(\u0026compiled_proof, \u0026smt, \u0026pairs, 20);\n}\n\n#[test]\nfn test_simple_non_exists_sub_proof() {\n    let pairs = vec![(\n        H256::from([\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]),\n        H256::from([\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]),\n    )];\n    let pairs2 = vec![(\n        H256::from([\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 1,\n        ]),\n        H256::from([\n            120, 94, 121, 42, 43, 185, 121, 215, 19, 188, 112, 111, 16, 124, 59, 43, 189, 203, 55,\n            192, 159, 233, 56, 217, 126, 150, 113, 232, 27, 66, 255, 10,\n        ]),\n    )];\n    let smt = new_smt(pairs.clone());\n    let exists_keys: Vec\u003c_\u003e = pairs.into_iter().map(|(k, _v)| k).collect();\n    let non_exists_keys: Vec\u003c_\u003e = pairs2.into_iter().map(|(k, _v)| k).collect();\n    let exists_keys_len = std::cmp::max(exists_keys.len() / 2, 1);\n    let non_exists_keys_len = std::cmp::max(non_exists_keys.len() / 2, 1);\n    let mut keys: Vec\u003c_\u003e = exists_keys\n        .into_iter()\n        .take(exists_keys_len)\n        .chain(non_exists_keys.into_iter().take(non_exists_keys_len))\n        .collect();\n    keys.dedup();\n    let proof = smt.merkle_proof(keys.clone()).expect(\"gen proof\");\n    let data: Vec\u003c(H256, H256)\u003e = keys\n        .iter()\n        .map(|k| (*k, smt.get(k).expect(\"get\")))\n        .collect();\n    let compiled_proof = proof.compile(keys.clone()).expect(\"compile proof\");\n    test_sub_proof(\u0026compiled_proof, \u0026smt, \u0026data, 20);\n}\n\nfn test_sub_proof(\n    compiled_proof: \u0026CompiledMerkleProof,\n    smt: \u0026SMT,\n    data: \u0026[(H256, H256)],\n    test_multi_round: usize,\n) {\n    let mut keys = data.iter().map(|(k, _v)| *k).collect::\u003cVec\u003c_\u003e\u003e();\n\n    // test sub proof with single leaf\n    for key in \u0026keys {\n        let single_compiled_proof = compiled_proof\n            .extract_proof::\u003cBlake2bHasher\u003e(data.iter().map(|(k, v)| (*k, *v, k == key)).collect())\n            .expect(\"compiled one proof\");\n        let expected_compiled_proof = smt\n            .merkle_proof(vec![*key])\n            .unwrap()\n            .compile(vec![*key])\n            .unwrap();\n        assert_eq!(expected_compiled_proof.0, single_compiled_proof.0);\n\n        let value = smt.get(key).unwrap();\n        assert!(single_compiled_proof\n            .verify::\u003cBlake2bHasher\u003e(smt.root(), vec![(*key, value)])\n            .expect(\"verify compiled one proof\"));\n    }\n\n    if data.len() \u003c 2 {\n        return;\n    }\n\n    // test sub proof with multiple leaves\n    let mut rng = rand::thread_rng();\n    for _ in 0..test_multi_round {\n        keys.shuffle(\u0026mut rng);\n        let selected_number = rng.gen_range(2..=keys.len());\n        let selected_pairs: HashMap\u003c_, _\u003e = keys\n            .iter()\n            .take(selected_number)\n            .map(|key| (*key, smt.get(key).unwrap()))\n            .collect();\n\n        let sub_proof = compiled_proof\n            .extract_proof::\u003cBlake2bHasher\u003e(\n                data.iter()\n                    .map(|(k, v)| (*k, *v, selected_pairs.contains_key(k)))\n                    .collect(),\n            )\n            .expect(\"compiled sub proof\");\n        let selected_keys = selected_pairs.keys().cloned().collect::\u003cVec\u003c_\u003e\u003e();\n        let expected_compiled_proof = smt\n            .merkle_proof(selected_keys.clone())\n            .unwrap()\n            .compile(selected_keys)\n            .unwrap();\n        assert_eq!(expected_compiled_proof.0, sub_proof.0);\n\n        assert!(sub_proof\n            .verify::\u003cBlake2bHasher\u003e(smt.root(), selected_pairs.into_iter().collect())\n            .expect(\"verify compiled sub proof\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","traits.rs"],"content":"use crate::{\n    error::Error,\n    tree::{BranchKey, BranchNode},\n    H256,\n};\n\n/// Trait for customize hash function\npub trait Hasher {\n    fn write_h256(\u0026mut self, h: \u0026H256);\n    fn write_byte(\u0026mut self, b: u8);\n    fn finish(self) -\u003e H256;\n}\n\n/// Trait for define value structures\npub trait Value {\n    fn to_h256(\u0026self) -\u003e H256;\n    fn zero() -\u003e Self;\n}\n\nimpl Value for H256 {\n    fn to_h256(\u0026self) -\u003e H256 {\n        *self\n    }\n    fn zero() -\u003e Self {\n        H256::zero()\n    }\n}\n\n/// Traits for customize backend storage\npub trait StoreReadOps\u003cV\u003e {\n    fn get_branch(\u0026self, branch_key: \u0026BranchKey) -\u003e Result\u003cOption\u003cBranchNode\u003e, Error\u003e;\n    fn get_leaf(\u0026self, leaf_key: \u0026H256) -\u003e Result\u003cOption\u003cV\u003e, Error\u003e;\n}\n\npub trait StoreWriteOps\u003cV\u003e {\n    fn insert_branch(\u0026mut self, node_key: BranchKey, branch: BranchNode) -\u003e Result\u003c(), Error\u003e;\n    fn insert_leaf(\u0026mut self, leaf_key: H256, leaf: V) -\u003e Result\u003c(), Error\u003e;\n    fn remove_branch(\u0026mut self, node_key: \u0026BranchKey) -\u003e Result\u003c(), Error\u003e;\n    fn remove_leaf(\u0026mut self, leaf_key: \u0026H256) -\u003e Result\u003c(), Error\u003e;\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","tree.rs"],"content":"use crate::{\n    collections::VecDeque,\n    error::{Error, Result},\n    merge::{merge, MergeValue},\n    merkle_proof::MerkleProof,\n    traits::{Hasher, StoreReadOps, StoreWriteOps, Value},\n    vec::Vec,\n    H256, MAX_STACK_SIZE,\n};\nuse codec::{Decode, Encode};\nuse core::{cmp::Ordering, marker::PhantomData};\n/// The branch key\n#[derive(Debug, Clone, Eq, PartialEq, Hash, Encode, Decode)]\npub struct BranchKey {\n    pub height: u8,\n    pub node_key: H256,\n}\n\nimpl BranchKey {\n    pub fn new(height: u8, node_key: H256) -\u003e BranchKey {\n        BranchKey { height, node_key }\n    }\n}\n\nimpl PartialOrd for BranchKey {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        Some(self.cmp(other))\n    }\n}\nimpl Ord for BranchKey {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n        match self.height.cmp(\u0026other.height) {\n            Ordering::Equal =\u003e self.node_key.cmp(\u0026other.node_key),\n            ordering =\u003e ordering,\n        }\n    }\n}\n\n/// A branch in the SMT\n#[derive(Debug, Eq, PartialEq, Clone, Encode, Decode)]\npub struct BranchNode {\n    pub left: MergeValue,\n    pub right: MergeValue,\n}\n\nimpl BranchNode {\n    /// Create a new empty branch\n    pub fn new_empty() -\u003e BranchNode {\n        BranchNode {\n            left: MergeValue::zero(),\n            right: MergeValue::zero(),\n        }\n    }\n\n    /// Determine whether a node did not store any value\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.left.is_zero() \u0026\u0026 self.right.is_zero()\n    }\n}\n\n/// Sparse merkle tree\n#[derive(Default, Debug)]\npub struct SparseMerkleTree\u003cH, V, S\u003e {\n    store: S,\n    root: H256,\n    phantom: PhantomData\u003c(H, V)\u003e,\n}\n\nimpl\u003cH, V, S\u003e SparseMerkleTree\u003cH, V, S\u003e {\n    /// Build a merkle tree from root and store\n    pub fn new(root: H256, store: S) -\u003e SparseMerkleTree\u003cH, V, S\u003e {\n        SparseMerkleTree {\n            root,\n            store,\n            phantom: PhantomData,\n        }\n    }\n\n    /// Merkle root\n    pub fn root(\u0026self) -\u003e \u0026H256 {\n        \u0026self.root\n    }\n\n    /// Check empty of the tree\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.root.is_zero()\n    }\n\n    /// Destroy current tree and retake store\n    pub fn take_store(self) -\u003e S {\n        self.store\n    }\n\n    /// Get backend store\n    pub fn store(\u0026self) -\u003e \u0026S {\n        \u0026self.store\n    }\n\n    /// Get mutable backend store\n    pub fn store_mut(\u0026mut self) -\u003e \u0026mut S {\n        \u0026mut self.store\n    }\n}\n\nimpl\u003cH: Hasher + Default, V, S: StoreReadOps\u003cV\u003e\u003e SparseMerkleTree\u003cH, V, S\u003e {\n    /// Build a merkle tree from store, the root will be calculated automatically\n    pub fn new_with_store(store: S) -\u003e Result\u003cSparseMerkleTree\u003cH, V, S\u003e\u003e {\n        let root_branch_key = BranchKey::new(core::u8::MAX, H256::zero());\n        store\n            .get_branch(\u0026root_branch_key)\n            .map(|branch_node| {\n                branch_node\n                    .map(|n| {\n                        merge::\u003cH\u003e(core::u8::MAX, \u0026H256::zero(), \u0026n.left, \u0026n.right).hash::\u003cH\u003e()\n                    })\n                    .unwrap_or_default()\n            })\n            .map(|root| SparseMerkleTree::new(root, store))\n    }\n}\n\nimpl\u003cH: Hasher + Default, V: Value, S: StoreReadOps\u003cV\u003e + StoreWriteOps\u003cV\u003e\u003e\n    SparseMerkleTree\u003cH, V, S\u003e\n{\n    /// Update a leaf, return new merkle root\n    /// set to zero value to delete a key\n    pub fn update(\u0026mut self, key: H256, value: V) -\u003e Result\u003c\u0026H256\u003e {\n        // compute and store new leaf\n        let node = MergeValue::from_h256(value.to_h256());\n        // notice when value is zero the leaf is deleted, so we do not need to store it\n        if !node.is_zero() {\n            self.store.insert_leaf(key, value)?;\n        } else {\n            self.store.remove_leaf(\u0026key)?;\n        }\n\n        // recompute the tree from bottom to top\n        let mut current_key = key;\n        let mut current_node = node;\n        for height in 0..=core::u8::MAX {\n            let parent_key = current_key.parent_path(height);\n            let parent_branch_key = BranchKey::new(height, parent_key);\n            let (left, right) =\n                if let Some(parent_branch) = self.store.get_branch(\u0026parent_branch_key)? {\n                    if current_key.is_right(height) {\n                        (parent_branch.left, current_node)\n                    } else {\n                        (current_node, parent_branch.right)\n                    }\n                } else if current_key.is_right(height) {\n                    (MergeValue::zero(), current_node)\n                } else {\n                    (current_node, MergeValue::zero())\n                };\n\n            if !left.is_zero() || !right.is_zero() {\n                // insert or update branch\n                self.store.insert_branch(\n                    parent_branch_key,\n                    BranchNode {\n                        left: left.clone(),\n                        right: right.clone(),\n                    },\n                )?;\n            } else {\n                // remove empty branch\n                self.store.remove_branch(\u0026parent_branch_key)?;\n            }\n            // prepare for next round\n            current_key = parent_key;\n            current_node = merge::\u003cH\u003e(height, \u0026parent_key, \u0026left, \u0026right);\n        }\n\n        self.root = current_node.hash::\u003cH\u003e();\n        Ok(\u0026self.root)\n    }\n\n    /// Update multiple leaves at once\n    pub fn update_all(\u0026mut self, mut leaves: Vec\u003c(H256, V)\u003e) -\u003e Result\u003c\u0026H256\u003e {\n        // Dedup(only keep the last of each key) and sort leaves\n        leaves.reverse();\n        leaves.sort_by_key(|(a, _)| *a);\n        leaves.dedup_by_key(|(a, _)| *a);\n\n        let mut nodes = leaves\n            .into_iter()\n            .map(|(k, v)| {\n                let value = MergeValue::from_h256(v.to_h256());\n                if !value.is_zero() {\n                    self.store.insert_leaf(k, v)\n                } else {\n                    self.store.remove_leaf(\u0026k)\n                }\n                .map(|_| (k, value, 0))\n            })\n            .collect::\u003cResult\u003cVecDeque\u003c(H256, MergeValue, u8)\u003e\u003e\u003e()?;\n\n        while let Some((current_key, current_merge_value, height)) = nodes.pop_front() {\n            let parent_key = current_key.parent_path(height);\n            let parent_branch_key = BranchKey::new(height, parent_key);\n\n            // Test for neighbors\n            let mut right = None;\n            if !current_key.is_right(height) \u0026\u0026 !nodes.is_empty() {\n                let (neighbor_key, _, neighbor_height) = nodes.front().expect(\"nodes is not empty\");\n                if neighbor_height.eq(\u0026height) {\n                    let mut right_key = current_key;\n                    right_key.set_bit(height);\n                    if neighbor_key.eq(\u0026right_key) {\n                        let (_, neighbor_value, _) = nodes.pop_front().expect(\"nodes is not empty\");\n                        right = Some(neighbor_value);\n                    }\n                }\n            }\n\n            let (left, right) = if let Some(right_merge_value) = right {\n                (current_merge_value, right_merge_value)\n            } else {\n                // In case neighbor is not available, fetch from store\n                if let Some(parent_branch) = self.store.get_branch(\u0026parent_branch_key)? {\n                    if current_key.is_right(height) {\n                        (parent_branch.left, current_merge_value)\n                    } else {\n                        (current_merge_value, parent_branch.right)\n                    }\n                } else if current_key.is_right(height) {\n                    (MergeValue::zero(), current_merge_value)\n                } else {\n                    (current_merge_value, MergeValue::zero())\n                }\n            };\n\n            if !left.is_zero() || !right.is_zero() {\n                self.store.insert_branch(\n                    parent_branch_key,\n                    BranchNode {\n                        left: left.clone(),\n                        right: right.clone(),\n                    },\n                )?;\n            } else {\n                self.store.remove_branch(\u0026parent_branch_key)?;\n            }\n            if height == core::u8::MAX {\n                self.root = merge::\u003cH\u003e(height, \u0026parent_key, \u0026left, \u0026right).hash::\u003cH\u003e();\n                break;\n            } else {\n                nodes.push_back((\n                    parent_key,\n                    merge::\u003cH\u003e(height, \u0026parent_key, \u0026left, \u0026right),\n                    height + 1,\n                ));\n            }\n        }\n\n        Ok(\u0026self.root)\n    }\n}\n\nimpl\u003cH: Hasher + Default, V: Value, S: StoreReadOps\u003cV\u003e\u003e SparseMerkleTree\u003cH, V, S\u003e {\n    /// Get value of a leaf\n    /// return zero value if leaf not exists\n    pub fn get(\u0026self, key: \u0026H256) -\u003e Result\u003cV\u003e {\n        if self.is_empty() {\n            return Ok(V::zero());\n        }\n        Ok(self.store.get_leaf(key)?.unwrap_or_else(V::zero))\n    }\n\n    /// Generate merkle proof\n    pub fn merkle_proof(\u0026self, mut keys: Vec\u003cH256\u003e) -\u003e Result\u003cMerkleProof\u003e {\n        if keys.is_empty() {\n            return Err(Error::EmptyKeys);\n        }\n\n        // sort keys\n        keys.sort_unstable();\n\n        // Collect leaf bitmaps\n        let mut leaves_bitmap: Vec\u003cH256\u003e = Default::default();\n        for current_key in \u0026keys {\n            let mut bitmap = H256::zero();\n            for height in 0..=core::u8::MAX {\n                let parent_key = current_key.parent_path(height);\n                let parent_branch_key = BranchKey::new(height, parent_key);\n                if let Some(parent_branch) = self.store.get_branch(\u0026parent_branch_key)? {\n                    let sibling = if current_key.is_right(height) {\n                        parent_branch.left\n                    } else {\n                        parent_branch.right\n                    };\n                    if !sibling.is_zero() {\n                        bitmap.set_bit(height);\n                    }\n                } else {\n                    // The key is not in the tree (support non-inclusion proof)\n                }\n            }\n            leaves_bitmap.push(bitmap);\n        }\n\n        let mut proof: Vec\u003cMergeValue\u003e = Default::default();\n        let mut stack_fork_height = [0u8; MAX_STACK_SIZE]; // store fork height\n        let mut stack_top = 0;\n        let mut leaf_index = 0;\n        while leaf_index \u003c keys.len() {\n            let leaf_key = keys[leaf_index];\n            let fork_height = if leaf_index + 1 \u003c keys.len() {\n                leaf_key.fork_height(\u0026keys[leaf_index + 1])\n            } else {\n                core::u8::MAX\n            };\n            for height in 0..=fork_height {\n                if height == fork_height \u0026\u0026 leaf_index + 1 \u003c keys.len() {\n                    // If it's not final round, we don't need to merge to root (height=255)\n                    break;\n                }\n                let parent_key = leaf_key.parent_path(height);\n                let is_right = leaf_key.is_right(height);\n\n                // has non-zero sibling\n                if stack_top \u003e 0 \u0026\u0026 stack_fork_height[stack_top - 1] == height {\n                    stack_top -= 1;\n                } else if leaves_bitmap[leaf_index].get_bit(height) {\n                    let parent_branch_key = BranchKey::new(height, parent_key);\n                    if let Some(parent_branch) = self.store.get_branch(\u0026parent_branch_key)? {\n                        let sibling = if is_right {\n                            parent_branch.left\n                        } else {\n                            parent_branch.right\n                        };\n                        if !sibling.is_zero() {\n                            proof.push(sibling);\n                        } else {\n                            unreachable!();\n                        }\n                    } else {\n                        // The key is not in the tree (support non-inclusion proof)\n                    }\n                }\n            }\n            debug_assert!(stack_top \u003c MAX_STACK_SIZE);\n            stack_fork_height[stack_top] = fork_height;\n            stack_top += 1;\n            leaf_index += 1;\n        }\n        assert_eq!(stack_top, 1);\n        Ok(MerkleProof::new(leaves_bitmap, proof))\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":58667}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":363}},{"line":80,"address":[],"length":0,"stats":{"Line":123}},{"line":81,"address":[],"length":0,"stats":{"Line":123}},{"line":85,"address":[],"length":0,"stats":{"Line":118}},{"line":86,"address":[],"length":0,"stats":{"Line":118}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":363}},{"line":108,"address":[],"length":0,"stats":{"Line":363}},{"line":109,"address":[],"length":0,"stats":{"Line":363}},{"line":110,"address":[],"length":0,"stats":{"Line":363}},{"line":111,"address":[],"length":0,"stats":{"Line":726}},{"line":112,"address":[],"length":0,"stats":{"Line":363}},{"line":113,"address":[],"length":0,"stats":{"Line":692}},{"line":114,"address":[],"length":0,"stats":{"Line":329}},{"line":116,"address":[],"length":0,"stats":{"Line":363}},{"line":118,"address":[],"length":0,"stats":{"Line":1089}},{"line":127,"address":[],"length":0,"stats":{"Line":113}},{"line":129,"address":[],"length":0,"stats":{"Line":113}},{"line":131,"address":[],"length":0,"stats":{"Line":113}},{"line":132,"address":[],"length":0,"stats":{"Line":109}},{"line":134,"address":[],"length":0,"stats":{"Line":4}},{"line":138,"address":[],"length":0,"stats":{"Line":113}},{"line":139,"address":[],"length":0,"stats":{"Line":113}},{"line":140,"address":[],"length":0,"stats":{"Line":57969}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":28928}},{"line":144,"address":[],"length":0,"stats":{"Line":1174}},{"line":145,"address":[],"length":0,"stats":{"Line":1174}},{"line":146,"address":[],"length":0,"stats":{"Line":593}},{"line":148,"address":[],"length":0,"stats":{"Line":581}},{"line":150,"address":[],"length":0,"stats":{"Line":27754}},{"line":151,"address":[],"length":0,"stats":{"Line":13880}},{"line":153,"address":[],"length":0,"stats":{"Line":13874}},{"line":156,"address":[],"length":0,"stats":{"Line":14730}},{"line":158,"address":[],"length":0,"stats":{"Line":27904}},{"line":159,"address":[],"length":0,"stats":{"Line":27904}},{"line":160,"address":[],"length":0,"stats":{"Line":27904}},{"line":161,"address":[],"length":0,"stats":{"Line":27904}},{"line":162,"address":[],"length":0,"stats":{"Line":27904}},{"line":167,"address":[],"length":0,"stats":{"Line":1024}},{"line":170,"address":[],"length":0,"stats":{"Line":28928}},{"line":171,"address":[],"length":0,"stats":{"Line":28928}},{"line":174,"address":[],"length":0,"stats":{"Line":113}},{"line":175,"address":[],"length":0,"stats":{"Line":113}},{"line":179,"address":[],"length":0,"stats":{"Line":3}},{"line":181,"address":[],"length":0,"stats":{"Line":3}},{"line":182,"address":[],"length":0,"stats":{"Line":6}},{"line":183,"address":[],"length":0,"stats":{"Line":6}},{"line":185,"address":[],"length":0,"stats":{"Line":6}},{"line":187,"address":[],"length":0,"stats":{"Line":6}},{"line":188,"address":[],"length":0,"stats":{"Line":3}},{"line":189,"address":[],"length":0,"stats":{"Line":3}},{"line":190,"address":[],"length":0,"stats":{"Line":3}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":9}},{"line":198,"address":[],"length":0,"stats":{"Line":1536}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":366}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":1536}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":1024}},{"line":221,"address":[],"length":0,"stats":{"Line":256}},{"line":222,"address":[],"length":0,"stats":{"Line":134}},{"line":224,"address":[],"length":0,"stats":{"Line":122}},{"line":226,"address":[],"length":0,"stats":{"Line":512}},{"line":227,"address":[],"length":0,"stats":{"Line":268}},{"line":229,"address":[],"length":0,"stats":{"Line":244}},{"line":233,"address":[],"length":0,"stats":{"Line":402}},{"line":234,"address":[],"length":0,"stats":{"Line":768}},{"line":235,"address":[],"length":0,"stats":{"Line":768}},{"line":236,"address":[],"length":0,"stats":{"Line":768}},{"line":237,"address":[],"length":0,"stats":{"Line":768}},{"line":238,"address":[],"length":0,"stats":{"Line":768}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":768}},{"line":245,"address":[],"length":0,"stats":{"Line":3}},{"line":246,"address":[],"length":0,"stats":{"Line":3}},{"line":248,"address":[],"length":0,"stats":{"Line":765}},{"line":249,"address":[],"length":0,"stats":{"Line":765}},{"line":250,"address":[],"length":0,"stats":{"Line":765}},{"line":251,"address":[],"length":0,"stats":{"Line":765}},{"line":256,"address":[],"length":0,"stats":{"Line":3}},{"line":263,"address":[],"length":0,"stats":{"Line":118}},{"line":264,"address":[],"length":0,"stats":{"Line":118}},{"line":265,"address":[],"length":0,"stats":{"Line":8}},{"line":267,"address":[],"length":0,"stats":{"Line":220}},{"line":271,"address":[],"length":0,"stats":{"Line":109}},{"line":272,"address":[],"length":0,"stats":{"Line":109}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":109}},{"line":280,"address":[],"length":0,"stats":{"Line":109}},{"line":281,"address":[],"length":0,"stats":{"Line":327}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":55917}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":26892}},{"line":287,"address":[],"length":0,"stats":{"Line":53784}},{"line":288,"address":[],"length":0,"stats":{"Line":13456}},{"line":290,"address":[],"length":0,"stats":{"Line":13436}},{"line":292,"address":[],"length":0,"stats":{"Line":27594}},{"line":293,"address":[],"length":0,"stats":{"Line":702}},{"line":299,"address":[],"length":0,"stats":{"Line":109}},{"line":302,"address":[],"length":0,"stats":{"Line":109}},{"line":303,"address":[],"length":0,"stats":{"Line":109}},{"line":304,"address":[],"length":0,"stats":{"Line":109}},{"line":305,"address":[],"length":0,"stats":{"Line":109}},{"line":347,"address":[],"length":0,"stats":{"Line":109}},{"line":348,"address":[],"length":0,"stats":{"Line":109}}],"covered":100,"coverable":136},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","trie_tree.rs"],"content":"use crate::{\n    error::{Error, Result},\n    merge::{into_merge_value, merge, MergeValue},\n    merkle_proof::MerkleProof,\n    traits::{Hasher, StoreReadOps, StoreWriteOps, Value},\n    tree::{BranchKey, BranchNode},\n    vec::Vec,\n    H256, MAX_STACK_SIZE,\n};\nuse core::marker::PhantomData;\n\n/// Sparse merkle tree\n#[derive(Default, Debug)]\npub struct SparseMerkleTree\u003cH, V, S\u003e {\n    store: S,\n    root: H256,\n    phantom: PhantomData\u003c(H, V)\u003e,\n}\n\nimpl\u003cH, V, S\u003e SparseMerkleTree\u003cH, V, S\u003e {\n    /// Build a merkle tree from root and store\n    pub fn new(root: H256, store: S) -\u003e SparseMerkleTree\u003cH, V, S\u003e {\n        SparseMerkleTree {\n            root,\n            store,\n            phantom: PhantomData,\n        }\n    }\n\n    /// Merkle root\n    pub fn root(\u0026self) -\u003e \u0026H256 {\n        \u0026self.root\n    }\n\n    /// Check empty of the tree\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.root.is_zero()\n    }\n\n    /// Destroy current tree and retake store\n    pub fn take_store(self) -\u003e S {\n        self.store\n    }\n\n    /// Get backend store\n    pub fn store(\u0026self) -\u003e \u0026S {\n        \u0026self.store\n    }\n\n    /// Get mutable backend store\n    pub fn store_mut(\u0026mut self) -\u003e \u0026mut S {\n        \u0026mut self.store\n    }\n}\n\nimpl\u003cH: Hasher + Default, V, S: StoreReadOps\u003cV\u003e\u003e SparseMerkleTree\u003cH, V, S\u003e {\n    /// Build a merkle tree from store, the root will be calculated automatically\n    pub fn new_with_store(store: S) -\u003e Result\u003cSparseMerkleTree\u003cH, V, S\u003e\u003e {\n        let root_branch_key = BranchKey::new(core::u8::MAX, H256::zero());\n        store\n            .get_branch(\u0026root_branch_key)\n            .map(|branch_node| {\n                branch_node\n                    .map(|n| {\n                        merge::\u003cH\u003e(core::u8::MAX, \u0026H256::zero(), \u0026n.left, \u0026n.right).hash::\u003cH\u003e()\n                    })\n                    .unwrap_or_default()\n            })\n            .map(|root| SparseMerkleTree::new(root, store))\n    }\n}\n\nimpl\u003cH: Hasher + Default, V: Value, S: StoreReadOps\u003cV\u003e + StoreWriteOps\u003cV\u003e\u003e\n    SparseMerkleTree\u003cH, V, S\u003e\n{\n    /// Update a leaf, return new merkle root\n    /// set to zero value to delete a key\n    pub fn update(\u0026mut self, key: H256, value: V) -\u003e Result\u003c\u0026H256\u003e {\n        let value_h256 = value.to_h256();\n        let is_delete = value_h256.is_zero();\n        // notice when value is zero the leaf is deleted, so we do not need to store it\n        if is_delete {\n            self.store.remove_leaf(\u0026key)?;\n        } else {\n            self.store.insert_leaf(key, value)?;\n        }\n\n        let mut last_height = core::u8::MAX;\n        loop {\n            // walk from top to bottom\n            let node_key = key.parent_path(last_height);\n            let branch_key = BranchKey::new(last_height, node_key); // this represents a position in the tree\n            if let Some(branch) = self.store.get_branch(\u0026branch_key)? {\n                // if we we found a record in here\n                // we need to determine whether is it a shortcut\n                let (target, another) = if key.is_right(last_height) {\n                    (branch.right, branch.left)\n                } else {\n                    (branch.left, branch.right)\n                };\n\n                match target {\n                    MergeValue::ShortCut {\n                        key: this_key,\n                        value,\n                        height: h,\n                    } =\u003e {\n                        if this_key.eq(\u0026key) {\n                            // we update its value\n                            if is_delete \u0026\u0026 another.is_zero() {\n                                self.store.remove_branch(\u0026branch_key)?;\n                            } else {\n                                let target = MergeValue::shortcut_or_value(key, value_h256, h);\n                                let new_branch = if key.is_right(last_height) {\n                                    BranchNode {\n                                        left: another,\n                                        right: target,\n                                    }\n                                } else {\n                                    BranchNode {\n                                        left: target,\n                                        right: another,\n                                    }\n                                };\n\n                                // update this shortcut's value\n                                self.store.insert_branch(branch_key, new_branch)?;\n                            }\n                            break;\n                        } else if !is_delete {\n                            // we need to move this shortcut down\n\n                            // OPTIMIZATION: the shortcut must dropping to the level where [shortcut's new_height + 1] = [insert/delete key's shortcut height + 1]\n                            // check definition of H256.fork_height()\n                            last_height = this_key.fork_height(\u0026key);\n\n                            let (next_left, next_right) = if key.is_right(last_height) {\n                                (\n                                    MergeValue::shortcut_or_value(this_key, value, last_height),\n                                    MergeValue::shortcut_or_value(key, value_h256, last_height),\n                                )\n                            } else {\n                                (\n                                    MergeValue::shortcut_or_value(key, value_h256, last_height),\n                                    MergeValue::shortcut_or_value(this_key, value, last_height),\n                                )\n                            };\n\n                            let next_branch_key =\n                                BranchKey::new(last_height, this_key.parent_path(last_height));\n\n                            self.store.insert_branch(\n                                next_branch_key,\n                                BranchNode {\n                                    left: next_left,\n                                    right: next_right,\n                                },\n                            )?;\n                            break; // go next round\n                        } else {\n                            // zero insertion meets shortcut, skip\n                            break; // go next round\n                        }\n                    }\n                    _ =\u003e {\n                        if target.is_zero() || last_height == 0 {\n                            let insert_value =\n                                MergeValue::shortcut_or_value(key, value_h256, last_height);\n                            let (left, right) = if key.is_right(last_height) {\n                                (another, insert_value)\n                            } else {\n                                (insert_value, another)\n                            };\n                            self.store\n                                .insert_branch(branch_key, BranchNode { left, right })?;\n                            break;\n                        } else {\n                            // walk down\n                            last_height -= 1;\n                            continue;\n                        }\n                    }\n                }\n            } else if !is_delete {\n                let target_node = MergeValue::shortcut_or_value(key, value_h256, last_height);\n                let (left, right) = if key.is_right(last_height) {\n                    (MergeValue::zero(), target_node)\n                } else {\n                    (target_node, MergeValue::zero())\n                };\n                self.store\n                    .insert_branch(branch_key, BranchNode { left, right })?;\n                break; // stop walking\n            } else if last_height != 0 {\n                last_height -= 1;\n            } else {\n                // do nothing with a zero insertion\n                break;\n            }\n        }\n\n        for height in last_height..=core::u8::MAX {\n            // update tree hash from insert pos to top\n            let node_key = key.parent_path(height);\n            let branch_key = BranchKey::new(height, node_key);\n\n            let new_merge = if let Some(branch) = self.store.get_branch(\u0026branch_key)? {\n                merge::\u003cH\u003e(height, \u0026node_key, \u0026branch.left, \u0026branch.right)\n            } else {\n                MergeValue::zero()\n            };\n            if height == core::u8::MAX {\n                // updating root\n                self.root = new_merge.hash::\u003cH\u003e();\n            } else {\n                // updates parent branch\n                let parent_key = key.parent_path(height + 1);\n                let parent_branch_key = BranchKey::new(height + 1, parent_key);\n                if new_merge.is_shortcut() {\n                    // move up\n                    self.store.remove_branch(\u0026branch_key)?;\n                }\n                if let Some(parent_branch) = self.store.get_branch(\u0026parent_branch_key)? {\n                    let (left, right) = if key.is_right(height + 1) {\n                        (parent_branch.left, new_merge)\n                    } else {\n                        (new_merge, parent_branch.right)\n                    };\n                    if left.is_zero() \u0026\u0026 right.is_zero() {\n                        self.store.remove_branch(\u0026parent_branch_key)?;\n                    } else {\n                        let new_parent_branch = BranchNode { left, right };\n                        self.store\n                            .insert_branch(parent_branch_key, new_parent_branch)?;\n                    }\n                } else if !new_merge.is_zero() {\n                    let new_parent_branch = if key.is_right(height + 1) {\n                        BranchNode {\n                            left: MergeValue::zero(),\n                            right: new_merge,\n                        }\n                    } else {\n                        BranchNode {\n                            left: new_merge,\n                            right: MergeValue::zero(),\n                        }\n                    };\n                    self.store\n                        .insert_branch(parent_branch_key, new_parent_branch)?;\n                }\n            }\n        }\n\n        Ok(\u0026self.root)\n    }\n\n    /// Update multiple leaves at once\n    pub fn update_all(\u0026mut self, mut leaves: Vec\u003c(H256, V)\u003e) -\u003e Result\u003c\u0026H256\u003e {\n        // Dedup(only keep the last of each key) and sort leaves\n        leaves.reverse();\n        leaves.sort_by_key(|(a, _)| *a);\n        leaves.dedup_by_key(|(a, _)| *a);\n\n        for (key, value) in leaves {\n            self.update(key, value)?;\n        }\n\n        Ok(\u0026self.root)\n    }\n}\n\nimpl\u003cH: Hasher + Default, V: Value, S: StoreReadOps\u003cV\u003e\u003e SparseMerkleTree\u003cH, V, S\u003e {\n    /// Get value of a leaf\n    /// return zero value if leaf not exists\n    pub fn get(\u0026self, key: \u0026H256) -\u003e Result\u003cV\u003e {\n        if self.is_empty() {\n            return Ok(V::zero());\n        }\n        Ok(self.store.get_leaf(key)?.unwrap_or_else(V::zero))\n    }\n\n    /// Generate merkle proof\n    pub fn merkle_proof(\u0026self, mut keys: Vec\u003cH256\u003e) -\u003e Result\u003cMerkleProof\u003e {\n        if keys.is_empty() {\n            return Err(Error::EmptyKeys);\n        }\n\n        // sort keys\n        keys.sort_unstable();\n\n        // Collect leaf bitmaps\n        let mut leaves_bitmap: Vec\u003cH256\u003e = Default::default();\n        for current_key in \u0026keys {\n            let mut bitmap = H256::zero();\n            for height in (0..=core::u8::MAX).rev() {\n                let parent_key = current_key.parent_path(height);\n                let parent_branch_key = BranchKey::new(height, parent_key);\n                if let Some(parent_branch) = self.store.get_branch(\u0026parent_branch_key)? {\n                    let (sibling, target) = if current_key.is_right(height) {\n                        (parent_branch.left, parent_branch.right)\n                    } else {\n                        (parent_branch.right, parent_branch.left)\n                    };\n\n                    if !sibling.is_zero() {\n                        bitmap.set_bit(height);\n                    }\n                    if let MergeValue::ShortCut { key, .. } = target {\n                        if !key.eq(current_key) {\n                            let fork_height = key.fork_height(current_key);\n                            bitmap.set_bit(fork_height);\n                            break;\n                        }\n                    }\n                }\n            }\n            leaves_bitmap.push(bitmap);\n        }\n\n        let mut proof: Vec\u003cMergeValue\u003e = Default::default();\n        let mut stack_fork_height = [0u8; MAX_STACK_SIZE]; // store fork height\n        let mut stack_top = 0;\n        let mut leaf_index = 0;\n\n        while leaf_index \u003c keys.len() {\n            let leaf_key = keys[leaf_index];\n            let fork_height = if leaf_index + 1 \u003c keys.len() {\n                leaf_key.fork_height(\u0026keys[leaf_index + 1])\n            } else {\n                core::u8::MAX\n            };\n\n            let heights = (0..=fork_height)\n                .into_iter()\n                .filter(|height| {\n                    if stack_top \u003e 0 \u0026\u0026 stack_fork_height[stack_top - 1] == *height {\n                        stack_top -= 1;\n                        false\n                    } else {\n                        true\n                    }\n                })\n                .collect::\u003cVec\u003c_\u003e\u003e();\n\n            let mut proof_result = Vec::new();\n            for height in heights.iter().copied().rev() {\n                if height == fork_height \u0026\u0026 leaf_index + 1 \u003c keys.len() {\n                    // If it's not final round, we don't need to merge to root (height=255)\n                    continue;\n                }\n\n                if leaves_bitmap[leaf_index].get_bit(height) {\n                    let parent_key = leaf_key.parent_path(height);\n                    let is_right = leaf_key.is_right(height);\n                    let parent_branch_key = BranchKey::new(height, parent_key);\n                    if let Some(parent_branch) = self.store.get_branch(\u0026parent_branch_key)? {\n                        let (sibling, current) = if is_right {\n                            (parent_branch.left, parent_branch.right)\n                        } else {\n                            (parent_branch.right, parent_branch.left)\n                        };\n                        push_sibling::\u003cH\u003e(\u0026mut proof_result, sibling);\n                        if let MergeValue::ShortCut { key, value, .. } = current {\n                            if !key.eq(\u0026leaf_key) {\n                                // this means key does not exist\n                                let fork_height = key.fork_height(\u0026leaf_key);\n                                if leaves_bitmap[leaf_index].get_bit(fork_height)\n                                    \u0026\u0026 heights.contains(\u0026fork_height)\n                                {\n                                    proof_result.push(into_merge_value::\u003cH\u003e(\n                                        key,\n                                        value,\n                                        fork_height,\n                                    ))\n                                }\n                            }\n                            break;\n                        }\n                    } else {\n                        // Maybe we've skipped shortcut node, find from up to down\n                        for i in (height..=core::u8::MAX).rev() {\n                            let parent_key = leaf_key.parent_path(i);\n                            let is_right = leaf_key.is_right(i);\n                            let parent_branch_key = BranchKey::new(i, parent_key);\n                            if let Some(parent_branch) =\n                                self.store.get_branch(\u0026parent_branch_key)?\n                            {\n                                let current = if is_right {\n                                    parent_branch.right\n                                } else {\n                                    parent_branch.left\n                                };\n\n                                match current {\n                                    MergeValue::ShortCut { key, value, .. } =\u003e {\n                                        if !key.eq(\u0026leaf_key) {\n                                            let fork_at = key.fork_height(\u0026leaf_key);\n                                            if fork_at == height {\n                                                proof_result.push(into_merge_value::\u003cH\u003e(\n                                                    key, value, fork_at,\n                                                ));\n                                            }\n                                        }\n                                        break;\n                                    }\n                                    _ =\u003e {\n                                        continue;\n                                    }\n                                }\n                            }\n                        }\n                        break; // we should stop further looping\n                    }\n                }\n            }\n\n            proof_result.reverse();\n            proof.append(\u0026mut proof_result);\n            debug_assert!(stack_top \u003c MAX_STACK_SIZE);\n            stack_fork_height[stack_top] = fork_height;\n            stack_top += 1;\n            leaf_index += 1;\n        }\n        Ok(MerkleProof::new(leaves_bitmap, proof))\n    }\n}\n\n// Helper function for a merkle_path insertion\nfn push_sibling\u003cH: Hasher + Default\u003e(proof_result: \u0026mut Vec\u003cMergeValue\u003e, sibling: MergeValue) {\n    match sibling {\n        MergeValue::ShortCut { key, value, height } =\u003e {\n            proof_result.push(into_merge_value::\u003cH\u003e(key, value, height))\n        }\n        _ =\u003e proof_result.push(sibling),\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":212}]};
        var previousData = {"files":[{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","cli.rs"],"content":"use clap::Parser;\n\n#[derive(Parser, Debug)]\n#[command(version, about, long_about = None)]\npub struct Args {\n    #[arg(short, long, help = \"paritydb or rocksdb\")]\n    pub database: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","common-backend","parity_backend.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! An SMT backend based on Actix and Swagger-UI, providing RPC for external service calls.\n//! A single database can create multiple Merkle trees.\n\n#![allow(dead_code)]\n#![allow(unused_imports)]\n#![allow(unused_mut)]\n\nuse actix_web::middleware::Logger as ALogger;\n// use serde_json;\nuse actix_web::{\n    cookie::time::util::weeks_in_year, get, post, web, App, HttpResponse, HttpServer, Responder,\n    ResponseError,\n};\nuse clap::Parser;\nuse codec::{Decode, Encode};\nuse dotenv::dotenv;\nuse ethers::utils::keccak256;\nuse flexi_logger::{Age, Cleanup, Criterion, Logger, Naming, WriteMode};\nuse http::status::{InvalidStatusCode, StatusCode};\nuse log::{error, info};\nuse serde::{Deserialize, Serialize};\nuse serde_with::serde_as;\nuse smt_backend_lib::cli::Args;\nuse smt_backend_lib::{\n    error::Error,\n    parity_apis::MultiSMTParityStore,\n    parity_req::{KVPair, ReqByKVs, ReqByKey, ReqByPrefix, ReqUpdate},\n};\nuse smt_primitives::{\n    keccak_hasher::Keccak256Hasher,\n    kv::*,\n    verify::{verify as smt_verify, Proof},\n};\nuse sparse_merkle_tree::{traits::Value, H256};\nuse std::env;\nuse std::{future, path::Path, result::Result, sync::Mutex};\nuse thiserror::Error as ThisError;\nuse tokio::signal::ctrl_c;\nuse utoipa::{IntoParams, OpenApi, ToSchema};\nuse utoipa_actix_web::AppExt;\nuse utoipa_redoc::Redoc;\nuse utoipa_swagger_ui::SwaggerUi;\n\nconst SMT_API: \u0026str = \"SMT API (ParityDb)\";\n\n#[derive(OpenApi)]\n#[openapi(\n        tags(\n            (name = \"SMT API\", description = \"Provides sparse Merkel tree related APIs\")\n        ),\n    )]\nstruct ApiDoc;\n\n/// Insert a value into a specific Merkle tree.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Insert a value into a specific Merkle tree.\", body = [H256])\n    )\n)]\n#[post(\"/update\")]\nasync fn update_value(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTParityStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqUpdate\u003cSMTKey, SMTValue\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let mut multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let root = multi_tree\n        .update(info.prefix, info.key.clone(), info.value.clone())\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:#?}\",\n        format!(\"[Update] info: {:#?}, root: {:?}\", info, root)\n    );\n    Ok(HttpResponse::Ok().json(root))\n}\n\n/// Remove a value by key\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Remove a value by key\", body = [H256])\n    )\n)]\n#[post(\"/remove\")]\nasync fn remove_value(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTParityStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByKey\u003cSMTKey\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let mut multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let root = multi_tree\n        .update(info.prefix, info.key.clone(), Default::default())\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:#?}\",\n        format!(\"[Remove] info: {:#?}, root: {:?}\", info, root)\n    );\n    Ok(HttpResponse::Ok().json(root))\n}\n\n/// Get the Merkle proof.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Get the Merkle proof.\", body = [Proof\u003cSMTKey, SMTValue\u003e])\n    )\n)]\n#[post(\"/merkle_proof\")]\nasync fn get_merkle_proof(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTParityStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByKey\u003cSMTKey\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let proof = multi_tree\n        .get_merkle_proof(info.prefix, info.key.clone())\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:?}\",\n        format!(\"[Get Merkle Proof] info: {:?}, proof: {:?}\", info, proof)\n    );\n    Ok(HttpResponse::Ok().json(proof))\n}\n\n/// Before data is updated, the future value of the root hash can be calculated in advance.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Before data is updated, the future value of the root hash can be calculated in advance.\", body = [H256])\n    )\n)]\n#[post(\"/next_root\")]\nasync fn get_next_root(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTParityStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByKVs\u003cKVPair\u003cSMTKey, SMTValue\u003e\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let old_proof = multi_tree\n        .get_merkle_proof_old(info.prefix, vec![info.kv.key.clone()])\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let next_root = multi_tree\n        .get_next_root(\n            old_proof,\n            vec![(info.kv.key.clone(), info.kv.value.clone())],\n        )\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:?}\",\n        format!(\n            \"[Get Next Root] info: {:?}, next root: {:?}\",\n            info, next_root\n        )\n    );\n    Ok(HttpResponse::Ok().json(next_root))\n}\n\n/// Get the root hash.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Get the root hash.\", body = [H256])\n    )\n)]\n#[post(\"/root\")]\nasync fn get_root(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTParityStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByPrefix\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let root = multi_tree\n        .get_root(info.prefix)\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:?}\",\n        format!(\n            \"[Get Root] info: {:?}, root: {:?}\",\n            info,\n            serde_json::to_string(\u0026root)\n        )\n    );\n    Ok(HttpResponse::Ok().json(root))\n}\n\n/// Get the value of a specific key in a particular tree.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Get the value of a specific key in a particular tree.\", body = [SMTValue])\n    )\n)]\n#[post(\"/value\")]\nasync fn get_value(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTParityStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByKey\u003cSMTKey\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let value = multi_tree\n        .get_value(info.prefix, info.key.clone())\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:?}\",\n        format!(\"[Get Value] info: {:?}, value: {:?}\", info, value)\n    );\n    Ok(HttpResponse::Ok().json(value))\n}\n\n/// Verify the Merkle proof.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Verify the Merkle proof.\", body = [bool])\n    )\n)]\n#[post(\"/verify\")]\nasync fn verify(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTParityStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cProof\u003cSMTKey, SMTValue\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let res = multi_tree.verify(Proof {\n        key: info.key.clone(),\n        value: info.value.clone(),\n        path: info.key.to_h256(),\n        value_hash: info.value.to_h256(),\n        leave_bitmap: info.leave_bitmap,\n        siblings: info.siblings.clone(),\n        root: info.root,\n    });\n    log::info!(\"{:?}\", format!(\"[Verify] info: {:?}, res: {:?}\", info, res));\n    Ok(HttpResponse::Ok().json(res))\n}\n\n/// Delete a specific Merkle tree.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Delete a specific Merkle tree.\", body = [H256])\n    )\n)]\n#[post(\"/clear\")]\nasync fn clear(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTParityStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByPrefix\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n\n    multi_tree.clear(info.prefix).unwrap();\n    let root = multi_tree\n        .get_root(info.prefix)\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\"{:?}\", format!(\"[Clear] info: {:?}, res: {:?}\", info, root));\n    Ok(HttpResponse::Ok().json(root))\n}\n\n#[actix_web::main]\nasync fn main() -\u003e std::io::Result\u003c()\u003e {\n    // fixme\n    // let args = Args::parse();\n    // let database: String = args.database;\n    dotenv().ok();\n    let base_path = env::var(\"DB_PATH\").unwrap();\n    let log_path = env::var(\"LOG_PATH\").unwrap();\n    let multi_tree = web::Data::new(Mutex::new(\n        MultiSMTParityStore::\u003cSMTKey, SMTValue, Keccak256Hasher\u003e::open(\n            Path::new(\u0026format!(\"{}/paritydb\", base_path)),\n            20,\n        )\n        .unwrap(),\n    ));\n    print!(\"log path: {:?}\", log_path);\n\n    // let l = async {\n    Logger::try_with_str(\"info\")\n        .unwrap()\n        .log_to_file(flexi_logger::FileSpec::default().directory(log_path))\n        // .write_mode(WriteMode::BufferAndFlush)\n        .rotate(\n            flexi_logger::Criterion::Age(Age::Day),\n            Naming::TimestampsDirect,\n            Cleanup::Never,\n        )\n        .append()\n        .log_to_stdout()\n        .start()\n        .unwrap();\n    // std::future::pending::\u003c()\u003e().await;\n    // };\n\n    let app = HttpServer::new(move || {\n        App::new()\n            .into_utoipa_app()\n            .openapi(ApiDoc::openapi())\n            .service(update_value)\n            .service(get_value)\n            .service(get_merkle_proof)\n            .service(get_next_root)\n            .service(get_root)\n            .service(verify)\n            .service(remove_value)\n            .service(clear)\n            .app_data(multi_tree.clone())\n            .openapi_service(|api| {\n                SwaggerUi::new(\"/swagger-ui/{_:.*}\").url(\"/api-docs/openapi.json\", api)\n            })\n            .into_app()\n    })\n    .shutdown_timeout(30)\n    .bind((\"0.0.0.0\", 8081))?\n    .run();\n\n    let graceful_shutdown = async {\n        ctrl_c().await.expect(\"Failed to listen for event\");\n        println!(\"Received CTRL-C, shutting down gracefully...\");\n    };\n\n    let graceful_shutdown_task = tokio::spawn(graceful_shutdown);\n\n    let result = tokio::select! {\n        _ = app =\u003e Ok(()),\n        _ = graceful_shutdown_task =\u003e Ok(()),\n        // _ = l =\u003e Ok(()),\n    };\n\n    result\n}\n","traces":[{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":86},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","common-backend","rocks_backend.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! An SMT backend based on Actix and Swagger-UI, providing RPC for external service calls.\n//! A single database can create multiple Merkle trees.\n\n#![allow(dead_code)]\n#![allow(unused_imports)]\n#![allow(unused_mut)]\n\nuse actix_web::middleware::Logger as ALogger;\n// use serde_json;\nuse actix_web::{\n    cookie::time::util::weeks_in_year, get, post, web, App, HttpResponse, HttpServer, Responder,\n    ResponseError,\n};\nuse clap::Parser;\nuse codec::{Decode, Encode};\nuse dotenv::dotenv;\nuse ethers::utils::keccak256;\nuse flexi_logger::{Age, Cleanup, Criterion, Logger, Naming, WriteMode};\nuse http::status::{InvalidStatusCode, StatusCode};\nuse log::{error, info};\nuse serde::{Deserialize, Serialize};\nuse serde_with::serde_as;\nuse smt_backend_lib::cli::Args;\nuse smt_backend_lib::{\n    apis::MultiSMTStore,\n    error::Error,\n    req::{KVPair, ReqByKVs, ReqByKey, ReqByPrefix, ReqUpdate},\n};\nuse smt_primitives::{\n    keccak_hasher::Keccak256Hasher,\n    kv::*,\n    verify::{verify as smt_verify, Proof},\n};\nuse sparse_merkle_tree::{traits::Value, H256};\nuse std::env;\nuse std::{future, path::Path, result::Result, sync::Mutex};\nuse thiserror::Error as ThisError;\nuse tokio::signal::ctrl_c;\nuse utoipa::{IntoParams, OpenApi, ToSchema};\nuse utoipa_actix_web::AppExt;\nuse utoipa_redoc::Redoc;\nuse utoipa_swagger_ui::SwaggerUi;\n\nconst SMT_API: \u0026str = \"SMT API (RocksDB)\";\n\n#[derive(OpenApi)]\n#[openapi(\n        tags(\n            (name = \"SMT API\", description = \"Provides sparse Merkel tree related APIs\")\n        ),\n    )]\nstruct ApiDoc;\n\n/// Insert a value into a specific Merkle tree.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Insert a value into a specific Merkle tree.\", body = [H256])\n    )\n)]\n#[post(\"/update\")]\nasync fn update_value(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqUpdate\u003cSMTKey, SMTValue\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let mut multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let root = multi_tree\n        .update(info.prefix.clone(), info.key.clone(), info.value.clone())\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:#?}\",\n        format!(\"[Update] info: {:#?}, root: {:?}\", info, root)\n    );\n    Ok(HttpResponse::Ok().json(root))\n}\n\n/// Remove a value by key\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Remove a value by key\", body = [H256])\n    )\n)]\n#[post(\"/remove\")]\nasync fn remove_value(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByKey\u003cSMTKey\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let mut multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let root = multi_tree\n        .update(\n            info.prefix.to_string(),\n            info.key.clone(),\n            Default::default(),\n        )\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:#?}\",\n        format!(\"[Remove] info: {:#?}, root: {:?}\", info, root)\n    );\n    Ok(HttpResponse::Ok().json(root))\n}\n\n/// Get the Merkle proof.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Get the Merkle proof.\", body = [Proof\u003cSMTKey, SMTValue\u003e])\n    )\n)]\n#[post(\"/merkle_proof\")]\nasync fn get_merkle_proof(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByKey\u003cSMTKey\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let proof = multi_tree\n        .get_merkle_proof(info.prefix.to_string(), info.key.clone())\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:?}\",\n        format!(\"[Get Merkle Proof] info: {:?}, proof: {:?}\", info, proof)\n    );\n    Ok(HttpResponse::Ok().json(proof))\n}\n\n/// Before data is updated, the future value of the root hash can be calculated in advance.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Before data is updated, the future value of the root hash can be calculated in advance.\", body = [H256])\n    )\n)]\n#[post(\"/next_root\")]\nasync fn get_next_root(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByKVs\u003cKVPair\u003cSMTKey, SMTValue\u003e\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let old_proof = multi_tree\n        .get_merkle_proof_old(info.prefix.to_string(), vec![info.kv.key.clone()])\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let next_root = multi_tree\n        .get_next_root(\n            old_proof,\n            vec![(info.kv.key.clone(), info.kv.value.clone())],\n        )\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:?}\",\n        format!(\n            \"[Get Next Root] info: {:?}, next root: {:?}\",\n            info, next_root\n        )\n    );\n    Ok(HttpResponse::Ok().json(next_root))\n}\n\n/// Get the root hash.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Get the root hash.\", body = [H256])\n    )\n)]\n#[post(\"/root\")]\nasync fn get_root(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByPrefix\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let root = multi_tree\n        .get_root(info.prefix.to_string())\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:?}\",\n        format!(\n            \"[Get Root] info: {:?}, root: {:?}\",\n            info,\n            serde_json::to_string(\u0026root)\n        )\n    );\n    Ok(HttpResponse::Ok().json(root))\n}\n\n/// Get the value of a specific key in a particular tree.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Get the value of a specific key in a particular tree.\", body = [SMTValue])\n    )\n)]\n#[post(\"/value\")]\nasync fn get_value(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByKey\u003cSMTKey\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let value = multi_tree\n        .get_value(info.prefix.to_string(), info.key.clone())\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\n        \"{:?}\",\n        format!(\"[Get Value] info: {:?}, value: {:?}\", info, value)\n    );\n    Ok(HttpResponse::Ok().json(value))\n}\n\n/// Verify the Merkle proof.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Verify the Merkle proof.\", body = [bool])\n    )\n)]\n#[post(\"/verify\")]\nasync fn verify(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cProof\u003cSMTKey, SMTValue\u003e\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    let res = multi_tree.verify(Proof {\n        key: info.key.clone(),\n        value: info.value.clone(),\n        path: info.key.to_h256(),\n        value_hash: info.value.to_h256(),\n        leave_bitmap: info.leave_bitmap,\n        siblings: info.siblings.clone(),\n        root: info.root,\n    });\n    log::info!(\"{:?}\", format!(\"[Verify] info: {:?}, res: {:?}\", info, res));\n    Ok(HttpResponse::Ok().json(res))\n}\n\n/// Delete a specific Merkle tree.\n#[utoipa::path(\n    tag = SMT_API,\n    params(\n    ),\n    responses(\n        (status = 200, description = \"Delete a specific Merkle tree.\", body = [H256])\n    )\n)]\n#[post(\"/clear\")]\nasync fn clear(\n    multi_tree: web::Data\u003cMutex\u003cMultiSMTStore\u003cSMTKey, SMTValue, Keccak256Hasher\u003e\u003e\u003e,\n    info: web::Json\u003cReqByPrefix\u003e,\n) -\u003e Result\u003cHttpResponse, Error\u003e {\n    let multi_tree = multi_tree\n        .lock()\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n\n    multi_tree.clear(info.prefix.to_string());\n    let root = multi_tree\n        .get_root(info.prefix.to_string())\n        .map_err(|e| Error::InternalError(e.to_string()))?;\n    log::info!(\"{:?}\", format!(\"[Clear] info: {:?}, res: {:?}\", info, root));\n    Ok(HttpResponse::Ok().json(root))\n}\n\n#[actix_web::main]\nasync fn main() -\u003e std::io::Result\u003c()\u003e {\n    // fixme\n    // let args = Args::parse();\n    // let database: String = args.database;\n    dotenv().ok();\n    let base_path = env::var(\"DB_PATH\").unwrap();\n    let log_path = env::var(\"LOG_PATH\").unwrap();\n    let multi_tree = web::Data::new(Mutex::new(\n        MultiSMTStore::\u003cSMTKey, SMTValue, Keccak256Hasher\u003e::open(Path::new(\u0026format!(\n            \"{}/rocksdb\",\n            base_path\n        )))\n        .unwrap(),\n    ));\n    print!(\"log path: {:?}\", log_path);\n\n    // let l = async {\n    Logger::try_with_str(\"info\")\n        .unwrap()\n        .log_to_file(flexi_logger::FileSpec::default().directory(log_path))\n        // .write_mode(WriteMode::BufferAndFlush)\n        .rotate(\n            flexi_logger::Criterion::Age(Age::Day),\n            Naming::TimestampsDirect,\n            Cleanup::Never,\n        )\n        .append()\n        .log_to_stdout()\n        .start()\n        .unwrap();\n    // std::future::pending::\u003c()\u003e().await;\n    // };\n\n    let app = HttpServer::new(move || {\n        App::new()\n            .into_utoipa_app()\n            .openapi(ApiDoc::openapi())\n            .service(update_value)\n            .service(get_value)\n            .service(get_merkle_proof)\n            .service(get_next_root)\n            .service(get_root)\n            .service(verify)\n            .service(remove_value)\n            .service(clear)\n            .app_data(multi_tree.clone())\n            .openapi_service(|api| {\n                SwaggerUi::new(\"/swagger-ui/{_:.*}\").url(\"/api-docs/openapi.json\", api)\n            })\n            .into_app()\n    })\n    .shutdown_timeout(30)\n    .bind((\"0.0.0.0\", 8080))?\n    .run();\n\n    let graceful_shutdown = async {\n        ctrl_c().await.expect(\"Failed to listen for event\");\n        println!(\"Received CTRL-C, shutting down gracefully...\");\n    };\n\n    let graceful_shutdown_task = tokio::spawn(graceful_shutdown);\n\n    let result = tokio::select! {\n        _ = app =\u003e Ok(()),\n        _ = graceful_shutdown_task =\u003e Ok(()),\n        // _ = l =\u003e Ok(()),\n    };\n\n    result\n}\n","traces":[{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":86},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","error.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#![allow(unused_imports)]\nuse actix_web::{\n    cookie::time::util::weeks_in_year, get, post, web, App, HttpResponse, HttpServer, Responder,\n    ResponseError,\n};\nuse thiserror::Error as ThisError;\n#[derive(Debug, ThisError)]\npub enum Error {\n    #[error(\"Internal server error: {0}\")]\n    InternalError(String),\n\n    #[error(\"Unexpected error occurred\")]\n    UnexpectedError,\n}\n\nimpl ResponseError for Error {\n    fn error_response(\u0026self) -\u003e HttpResponse\u003cactix_web::body::BoxBody\u003e {\n        match self {\n            Error::InternalError(e) =\u003e HttpResponse::BadRequest().body(e.to_string()),\n            _ =\u003e HttpResponse::BadRequest().body(\"Unexpected error occurred\"),\n        }\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","lib.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Provide APIs related to SMT (Sparse Merkle Tree).  \n//! Implement persistent storage for SMT.  \n//! A single database can store multiple Merkle trees, and they do not interfere with each other.\n\npub mod cli;\npub mod error;\npub mod parity;\npub mod rocks;\npub use parity::*;\npub use rocks::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","parity","mod.rs"],"content":"pub mod parity_apis;\npub mod parity_db;\npub mod parity_req;\npub mod parity_store;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","parity","parity_apis.rs"],"content":"use crate::parity_db::ParityDb;\nuse crate::parity_store::SMTParityStore;\nuse scale_info::TypeInfo;\nuse serde::{Deserialize, Serialize};\nuse smt_primitives::{\n    // keccak_hasher::Keccak256Hasher,\n    verify::{verify as smt_verify, Proof},\n};\nuse sparse_merkle_tree::{\n    error::{Error, Result as SMTResult},\n    // merge::MergeValue,\n    traits::{Hasher, Value},\n    CompiledMerkleProof,\n    SparseMerkleTree,\n    H256,\n};\nuse std::{fmt::Debug, marker::PhantomData, path::Path, sync::Arc};\nuse utoipa::{ToSchema, __dev::ComposeSchema};\n\ntype MultiSMT\u003cV, H\u003e = SparseMerkleTree\u003cH, V, SMTParityStore\u003e;\n\n/// Multiple Merkle trees are stored in a ParityDb database\npub struct MultiSMTParityStore\u003cK, V, H\u003e {\n    store: Arc\u003cParityDb\u003e,\n    v: PhantomData\u003c(K, V, H)\u003e,\n}\n\nimpl\u003c\n        K: Value\n            + Clone\n            + Serialize\n            + ToSchema\n            + Deserialize\u003c'static\u003e\n            + ComposeSchema\n            + Debug\n            + TypeInfo,\n        V: Default\n            + Value\n            + Into\u003cVec\u003cu8\u003e\u003e\n            + From\u003cVec\u003cu8\u003e\u003e\n            + ToSchema\n            + Serialize\n            + Deserialize\u003c'static\u003e\n            + ComposeSchema\n            + PartialEq\n            + Clone\n            + Debug\n            + TypeInfo,\n        H: Hasher + Default,\n    \u003e MultiSMTParityStore\u003cK, V, H\u003e\n{\n    /// Open the ParityDb database, create it if it does not exist.\n    pub fn open\u003cP: AsRef\u003cPath\u003e\u003e(path: P, num_columns: u8) -\u003e std::io::Result\u003cSelf\u003e {\n        let db = ParityDb::new(path.as_ref(), num_columns);\n        Ok(Self {\n            store: Arc::new(db),\n            v: Default::default(),\n        })\n    }\n\n    /// Create or open a new tree with specified column\n    pub fn new_tree_with_store(\u0026self, col: u8) -\u003e Result\u003cMultiSMT\u003cV, H\u003e, Error\u003e {\n        let db = SMTParityStore::new(self.store.clone(), col);\n        MultiSMT::new_with_store(db)\n    }\n\n    /// Insert a value into a specific Merkle tree\n    pub fn update(\u0026self, col: u8, key: K, value: V) -\u003e SMTResult\u003cH256\u003e {\n        let mut tree = self.new_tree_with_store(col)?;\n        let h = tree.update(key.to_h256(), value)?;\n        Ok(*h)\n    }\n\n    /// Insert multiple values into a Merkle tree at once\n    pub fn update_all(\u0026self, col: u8, kvs: Vec\u003c(K, V)\u003e) -\u003e SMTResult\u003cH256\u003e {\n        let kvs = kvs\n            .into_iter()\n            .map(|(k, v)| Ok((k.to_h256(), v)))\n            .collect::\u003cResult\u003cVec\u003c(H256, V)\u003e, Error\u003e\u003e()?;\n\n        let mut tree = self.new_tree_with_store(col)?;\n        let root = tree.update_all(kvs)?;\n        Ok(*root)\n    }\n\n    /// Get the root hash\n    pub fn get_root(\u0026self, col: u8) -\u003e Result\u003cH256, Error\u003e {\n        let tree = self.new_tree_with_store(col)?;\n        Ok(*tree.root())\n    }\n\n    /// Get the value of a specific key in a particular tree\n    pub fn get_value(\u0026self, col: u8, key: K) -\u003e Result\u003cV, Error\u003e {\n        let tree = self.new_tree_with_store(col)?;\n        let value = tree.get(\u0026key.to_h256())?;\n        Ok(value)\n    }\n\n    /// Get the Merkle proof\n    pub fn get_merkle_proof(\u0026self, col: u8, key: K) -\u003e Result\u003cProof\u003cK, V\u003e, Error\u003e {\n        let tree = self.new_tree_with_store(col)?;\n        let proof = tree.merkle_proof(vec![key.to_h256()])?;\n        let leaves_bitmap = proof.leaves_bitmap();\n        let siblings = proof.merkle_path();\n        let leave_bitmap = leaves_bitmap[0];\n        let value = self.get_value(col, key.clone())?;\n\n        Ok(Proof {\n            key: key.clone(),\n            value: value.clone(),\n            path: key.to_h256(),\n            value_hash: value.to_h256(),\n            root: *tree.root(),\n            leave_bitmap,\n            siblings: siblings.clone(),\n        })\n    }\n\n    /// Get the Merkle proof, the return value is `Vec\u003cu8\u003e`\n    pub fn get_merkle_proof_old(\u0026self, col: u8, keys: Vec\u003cK\u003e) -\u003e SMTResult\u003cVec\u003cu8\u003e\u003e {\n        let tree = self.new_tree_with_store(col)?;\n        let keys = keys\n            .into_iter()\n            .map(|k| Ok(k.to_h256()))\n            .collect::\u003cResult\u003cVec\u003cH256\u003e, Error\u003e\u003e()?;\n\n        let proof = tree.merkle_proof(keys.clone())?;\n        let proof = proof.compile(keys)?;\n        Ok(proof.0)\n    }\n\n    /// Before data is updated, the future value of the root hash can be calculated in advance\n    pub fn get_next_root(\u0026self, old_proof: Vec\u003cu8\u003e, next_kvs: Vec\u003c(K, V)\u003e) -\u003e Result\u003cH256, Error\u003e {\n        let p = CompiledMerkleProof(old_proof);\n        let kvs = next_kvs\n            .into_iter()\n            .map(|(k, v)| Ok((k.to_h256(), v.to_h256())))\n            .collect::\u003cResult\u003cVec\u003c(H256, H256)\u003e, Error\u003e\u003e()?;\n\n        let next_root = p.compute_root::\u003cH\u003e(kvs)?;\n        Ok(next_root)\n    }\n\n    /// Delete a specific Merkle tree by clearing its column\n    pub fn clear(\u0026self, col: u8) -\u003e Result\u003c(), Error\u003e {\n        self.store\n            .clear_column(col)\n            .map_err(|e| Error::Store(e.to_string()))?;\n        Ok(())\n    }\n\n    /// Verify the Merkle proof\n    pub fn verify(\u0026self, proof: Proof\u003cK, V\u003e) -\u003e bool {\n        let mut res = false;\n        if proof.value != V::default() {\n            res = smt_verify::\u003cH\u003e(\n                proof.path,\n                proof.value_hash,\n                proof.leave_bitmap,\n                proof.siblings,\n                proof.root,\n            )\n        }\n        res\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use smt_primitives::{kv::{SMTKey, SMTValue}, keccak_hasher::Keccak256Hasher};\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_apis() {\n        // Create multi_tree\n        let temp_dir = tempdir().unwrap();\n        let multi_tree =\n            MultiSMTParityStore::\u003cSMTKey, SMTValue, Keccak256Hasher\u003e::open(temp_dir.path(), 2)\n                .unwrap();\n\n        let tree1_col: u8 = 0;\n        let tree2_col: u8 = 1;\n        multi_tree.clear(tree1_col).unwrap();\n        multi_tree.clear(tree2_col).unwrap();\n        multi_tree.new_tree_with_store(tree1_col).unwrap();\n        multi_tree.new_tree_with_store(tree2_col).unwrap();\n\n        // Get roots from both trees\n        assert_eq!(multi_tree.get_root(tree1_col).unwrap(), H256::zero());\n        assert_eq!(multi_tree.get_root(tree2_col).unwrap(), H256::zero());\n\n        // Insert data into tree1\n        let tree1_key1 = SMTKey {\n            address: \"1\".to_string(),\n        };\n        let tree1_value1 = SMTValue {\n            nonce: 1,\n            balance: 99,\n        };\n        let tree1_key2 = SMTKey {\n            address: \"2\".to_string(),\n        };\n        let tree1_value2 = SMTValue {\n            nonce: 2,\n            balance: 97,\n        };\n\n        assert_eq!(\n            multi_tree.get_value(tree1_col, tree1_key1.clone()).unwrap(),\n            SMTValue::default()\n        );\n        assert_eq!(multi_tree.get_root(tree1_col).unwrap(), H256::zero());\n\n        // Update and verify\n        multi_tree\n            .update(tree1_col, tree1_key1.clone(), tree1_value1.clone())\n            .unwrap();\n        assert_eq!(\n            multi_tree.get_value(tree1_col, tree1_key1.clone()).unwrap(),\n            tree1_value1.clone()\n        );\n\n        let proof = multi_tree\n            .get_merkle_proof(tree1_col, tree1_key1.clone())\n            .unwrap();\n        assert!(multi_tree.verify(proof));\n\n        // Test remove\n        multi_tree\n            .update(tree1_col, tree1_key1.clone(), SMTValue::default())\n            .unwrap();\n        assert_eq!(\n            multi_tree.get_value(tree1_col, tree1_key1.clone()).unwrap(),\n            SMTValue::default()\n        );\n\n        // Test multiple updates\n        multi_tree\n            .update(tree1_col, tree1_key1.clone(), tree1_value1.clone())\n            .unwrap();\n        let _tree1_root1 = multi_tree.get_root(tree1_col).unwrap();\n\n        let old_proof = multi_tree\n            .get_merkle_proof_old(tree1_col, vec![tree1_key2.clone()])\n            .unwrap();\n        let _next_root = multi_tree\n            .get_next_root(old_proof, vec![(tree1_key2.clone(), tree1_value2.clone())])\n            .unwrap();\n\n        let tree2_root1 = multi_tree\n            .update(tree1_col, tree1_key2.clone(), tree1_value2.clone())\n            .unwrap();\n\n        assert_eq!(_next_root, tree2_root1);\n\n        // Test clear\n        multi_tree.clear(tree1_col).unwrap();\n        assert_eq!(\n            multi_tree.get_value(tree1_col, tree1_key1.clone()).unwrap(),\n            SMTValue::default()\n        );\n\n        // Test batch update\n        let mut kvs: Vec\u003c(SMTKey, SMTValue)\u003e = vec![];\n        for i in 1..2 {\n            kvs.push((\n                SMTKey {\n                    address: i.to_string(),\n                },\n                SMTValue {\n                    nonce: i as u64,\n                    balance: i as u128,\n                },\n            ));\n        }\n\n        multi_tree.update_all(tree1_col, kvs.clone()).unwrap();\n    }\n}\n","traces":[{"line":53,"address":[],"length":0,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":62,"address":[],"length":0,"stats":{"Line":18}},{"line":63,"address":[],"length":0,"stats":{"Line":18}},{"line":64,"address":[],"length":0,"stats":{"Line":18}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":8}},{"line":70,"address":[],"length":0,"stats":{"Line":4}},{"line":71,"address":[],"length":0,"stats":{"Line":4}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":3}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":87,"address":[],"length":0,"stats":{"Line":4}},{"line":88,"address":[],"length":0,"stats":{"Line":8}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":5}},{"line":94,"address":[],"length":0,"stats":{"Line":10}},{"line":95,"address":[],"length":0,"stats":{"Line":5}},{"line":96,"address":[],"length":0,"stats":{"Line":5}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":1}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":129,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":137,"address":[],"length":0,"stats":{"Line":3}},{"line":140,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":145,"address":[],"length":0,"stats":{"Line":3}},{"line":146,"address":[],"length":0,"stats":{"Line":3}},{"line":147,"address":[],"length":0,"stats":{"Line":3}},{"line":148,"address":[],"length":0,"stats":{"Line":6}},{"line":149,"address":[],"length":0,"stats":{"Line":3}},{"line":153,"address":[],"length":0,"stats":{"Line":1}},{"line":154,"address":[],"length":0,"stats":{"Line":1}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":1}}],"covered":64,"coverable":68},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","parity","parity_db.rs"],"content":"use parity_db::{clear_column, Db, Options};\nuse std::{fmt, path::PathBuf};\n\npub struct ParityDb {\n    path: PathBuf,\n    num_columns: u8,\n}\n\n#[derive(Debug)]\npub enum StoreError {\n    DbError(parity_db::Error),\n    InvalidColumnId,\n}\n\n//  Display trait\nimpl fmt::Display for StoreError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            StoreError::DbError(e) =\u003e write!(f, \"Database error: {:?}\", e),\n            StoreError::InvalidColumnId =\u003e write!(f, \"Invalid column ID\"),\n        }\n    }\n}\n\nimpl From\u003cparity_db::Error\u003e for StoreError {\n    fn from(error: parity_db::Error) -\u003e Self {\n        StoreError::DbError(error)\n    }\n}\n\nimpl ParityDb {\n    /// create a new ParityDb instance\n    pub fn new(path: impl Into\u003cPathBuf\u003e, num_columns: u8) -\u003e Self {\n        Self {\n            path: path.into(),\n            num_columns,\n        }\n    }\n\n    /// Opens an existing database or creates a new one if it doesn't exist\n    pub fn open_or_create(\u0026self) -\u003e Result\u003cDb, StoreError\u003e {\n        let options = Options::with_columns(\u0026self.path, self.num_columns);\n        let db = Db::open_or_create(\u0026options)?;\n        Ok(db)\n    }\n\n    fn check_column(\u0026self, column: u8) -\u003e Result\u003c(), StoreError\u003e {\n        if column \u003e= self.num_columns {\n            return Err(StoreError::InvalidColumnId);\n        }\n        Ok(())\n    }\n\n    /// Insert a value into the specified column\n    pub fn insert(\u0026self, column: u8, key: \u0026[u8], value: \u0026[u8]) -\u003e Result\u003c(), StoreError\u003e {\n        self.check_column(column)?;\n        let db = self.open_or_create()?;\n        db.commit(vec![(column, key.to_vec(), Some(value.to_vec()))])?;\n        Ok(())\n    }\n\n    /// Delete a value from the specified column\n    pub fn delete(\u0026self, column: u8, key: \u0026[u8]) -\u003e Result\u003c(), StoreError\u003e {\n        self.check_column(column)?;\n        let db = self.open_or_create()?;\n        db.commit(vec![(column, key.to_vec(), None)])?;\n        Ok(())\n    }\n\n    /// Get a value from the specified column\n    pub fn get(\u0026self, column: u8, key: \u0026[u8]) -\u003e Result\u003cOption\u003cVec\u003cu8\u003e\u003e, StoreError\u003e {\n        self.check_column(column)?;\n        let db = self.open_or_create()?;\n        Ok(db.get(column, key)?)\n    }\n\n    /// Delete the entire database by removing all files\n    pub fn destroy(self) -\u003e Result\u003c(), StoreError\u003e {\n        if self.path.exists() {\n            std::fs::remove_dir_all(\u0026self.path)\n                .map_err(|e| StoreError::DbError(parity_db::Error::Io(e)))?;\n        }\n\n        Ok(())\n    }\n\n    /// Ensure the database is properly closed before operations like clear_column\n    fn ensure_closed(\u0026self) -\u003e Result\u003c(), StoreError\u003e {\n        let db = self.open_or_create()?;\n        drop(db);\n        Ok(())\n    }\n\n    /// Clear all data in a column without recreating it\n    pub fn clear_column(\u0026self, column: u8) -\u003e Result\u003c(), StoreError\u003e {\n        self.check_column(column)?;\n        self.ensure_closed()?;\n        clear_column(\u0026self.path, column)?;\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_basic_operations() {\n        let temp_dir = tempdir().unwrap();\n        let store = ParityDb::new(temp_dir.path(), 2);\n\n        // Test insert\n        let key = b\"test_key\";\n        let value = b\"test_value\";\n        store.insert(0, key, value).unwrap();\n\n        // Test get\n        let retrieved = store.get(0, key).unwrap();\n        assert_eq!(retrieved, Some(value.to_vec()));\n\n        // Test delete\n        store.delete(0, key).unwrap();\n        let retrieved = store.get(0, key).unwrap();\n        assert_eq!(retrieved, None);\n\n        // Test destroy\n        store.destroy().unwrap();\n        assert!(!temp_dir.path().exists());\n    }\n\n    #[test]\n    fn test_reset_column() {\n        let temp_dir = tempdir().unwrap();\n        let store = ParityDb::new(temp_dir.path(), 2);\n\n        // Insert data in both columns\n        store.insert(0, b\"key1\", b\"value1\").unwrap();\n        store.insert(1, b\"key2\", b\"value2\").unwrap();\n\n        // Clear column 0\n        store.clear_column(0).unwrap();\n\n        // Verify data\n        assert_eq!(store.get(0, b\"key1\").unwrap(), None);\n        assert_eq!(store.get(1, b\"key2\").unwrap(), Some(b\"value2\".to_vec()));\n    }\n\n    #[test]\n    fn test_clear_column() {\n        let temp_dir = tempdir().unwrap();\n        let store = ParityDb::new(temp_dir.path(), 2);\n\n        // Insert some test data\n        for i in 0..100 {\n            let key = format!(\"key{}\", i).into_bytes();\n            let value = format!(\"value{}\", i).into_bytes();\n            store.insert(0, \u0026key, \u0026value).unwrap();\n            store.insert(1, \u0026key, \u0026value).unwrap();\n        }\n\n        // Clear column 0\n        store.clear_column(0).unwrap();\n\n        // Verify column 0 is empty but column 1 still has data\n        for i in 0..100 {\n            let key = format!(\"key{}\", i).into_bytes();\n            assert_eq!(store.get(0, \u0026key).unwrap(), None);\n            assert!(store.get(1, \u0026key).unwrap().is_some());\n        }\n    }\n\n    #[test]\n    fn test_column_bounds() {\n        let temp_dir = tempdir().unwrap();\n        let store = ParityDb::new(temp_dir.path(), 2);\n\n        // Test inserting to invalid column\n        let result = store.insert(2, b\"key\", b\"value\");\n        assert!(result.is_err());\n\n        // Test getting from invalid column\n        let result = store.get(2, b\"key\");\n        assert!(result.is_err());\n\n        // Test deleting from invalid column\n        let result = store.delete(2, b\"key\");\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":6}},{"line":35,"address":[],"length":0,"stats":{"Line":6}},{"line":41,"address":[],"length":0,"stats":{"Line":3521}},{"line":42,"address":[],"length":0,"stats":{"Line":3521}},{"line":43,"address":[],"length":0,"stats":{"Line":7042}},{"line":47,"address":[],"length":0,"stats":{"Line":3524}},{"line":48,"address":[],"length":0,"stats":{"Line":3524}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":51,"address":[],"length":0,"stats":{"Line":3521}},{"line":55,"address":[],"length":0,"stats":{"Line":1234}},{"line":56,"address":[],"length":0,"stats":{"Line":1235}},{"line":57,"address":[],"length":0,"stats":{"Line":2466}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":1233}},{"line":63,"address":[],"length":0,"stats":{"Line":261}},{"line":64,"address":[],"length":0,"stats":{"Line":262}},{"line":65,"address":[],"length":0,"stats":{"Line":520}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":260}},{"line":71,"address":[],"length":0,"stats":{"Line":2024}},{"line":72,"address":[],"length":0,"stats":{"Line":2025}},{"line":73,"address":[],"length":0,"stats":{"Line":4046}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":5}},{"line":89,"address":[],"length":0,"stats":{"Line":10}},{"line":95,"address":[],"length":0,"stats":{"Line":5}},{"line":96,"address":[],"length":0,"stats":{"Line":5}},{"line":97,"address":[],"length":0,"stats":{"Line":5}},{"line":98,"address":[],"length":0,"stats":{"Line":5}},{"line":99,"address":[],"length":0,"stats":{"Line":5}}],"covered":32,"coverable":41},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","parity","parity_req.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#![allow(unused_imports)]\nuse serde::{self, Deserialize, Serialize};\nuse smt_primitives::kv::{SMTKey, SMTValue};\nuse std::{fmt::Debug, marker::PhantomData};\nuse utoipa::{IntoParams, ToSchema, __dev::ComposeSchema};\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct ReqUpdate\u003cK, V\u003e {\n    pub prefix: u8,\n    #[serde(flatten)]\n    pub key: K,\n    #[serde(flatten)]\n    pub value: V,\n}\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct ReqByKey\u003cK\u003e {\n    pub prefix: u8,\n    #[serde(flatten)]\n    pub key: K,\n}\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct ReqByKVs\u003cKVPair\u003e {\n    pub prefix: u8,\n    #[serde(flatten)]\n    pub kv: KVPair,\n}\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct KVPair\u003cK, V\u003e {\n    #[serde(flatten)]\n    pub key: K,\n    #[serde(flatten)]\n    pub value: V,\n}\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct ReqByPrefix {\n    pub prefix: u8,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","parity","parity_store.rs"],"content":"use codec::{Decode, Encode};\nuse sparse_merkle_tree::{\n    error::Error,\n    traits::{StoreReadOps, StoreWriteOps, Value},\n    BranchKey, BranchNode, H256,\n};\nuse std::sync::Arc;\n\nuse crate::parity_db::ParityDb;\n\npub struct SMTParityStore {\n    inner: Arc\u003cParityDb\u003e,\n    col: u8,\n}\n\nimpl SMTParityStore {\n    pub fn new(db: Arc\u003cParityDb\u003e, col: u8) -\u003e Self {\n        SMTParityStore { inner: db, col }\n    }\n}\n\nimpl\u003cV\u003e StoreWriteOps\u003cV\u003e for SMTParityStore\nwhere\n    V: Value + Into\u003cVec\u003cu8\u003e\u003e,\n{\n    fn insert_branch(\u0026mut self, node_key: BranchKey, branch: BranchNode) -\u003e Result\u003c(), Error\u003e {\n        self.inner\n            .insert(self.col, \u0026node_key.encode(), \u0026branch.encode())\n            .map_err(|e| Error::Store(e.to_string()))\n    }\n\n    fn insert_leaf(\u0026mut self, leaf_key: H256, leaf: V) -\u003e Result\u003c(), Error\u003e {\n        self.inner\n            .insert(self.col, \u0026leaf_key.encode(), \u0026leaf.into())\n            .map_err(|e| Error::Store(e.to_string()))\n    }\n\n    fn remove_branch(\u0026mut self, node_key: \u0026BranchKey) -\u003e Result\u003c(), Error\u003e {\n        self.inner\n            .delete(self.col, \u0026node_key.encode())\n            .map_err(|e| Error::Store(e.to_string()))\n    }\n\n    fn remove_leaf(\u0026mut self, leaf_key: \u0026H256) -\u003e Result\u003c(), Error\u003e {\n        self.inner\n            .delete(self.col, \u0026leaf_key.encode())\n            .map_err(|e| Error::Store(e.to_string()))\n    }\n}\n\nimpl\u003cV\u003e StoreReadOps\u003cV\u003e for SMTParityStore\nwhere\n    V: Value + From\u003cVec\u003cu8\u003e\u003e,\n{\n    fn get_branch(\u0026self, branch_key: \u0026BranchKey) -\u003e Result\u003cOption\u003cBranchNode\u003e, Error\u003e {\n        self.inner\n            .get(self.col, \u0026branch_key.encode())\n            .map_err(|e| Error::Store(e.to_string()))?\n            .map(|v| BranchNode::decode(\u0026mut v.as_slice()).unwrap())\n            .map_or(Ok(None), |v| Ok(Some(v)))\n    }\n\n    fn get_leaf(\u0026self, leaf_key: \u0026H256) -\u003e Result\u003cOption\u003cV\u003e, Error\u003e {\n        self.inner\n            .get(self.col, \u0026leaf_key.encode())\n            .map_err(|e| Error::Store(e.to_string()))?\n            .map(|v| v.into())\n            .map_or(Ok(None), |v| Ok(Some(v)))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use smt_primitives::kv::{SMTValue};\n    use sparse_merkle_tree::{merge::MergeValue};\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_store() {\n        // \n        let temp_dir = tempdir().unwrap();\n        let db = ParityDb::new(temp_dir.path(), 2);\n        let mut store = SMTParityStore::new(Arc::new(db), 0);\n\n        // \n        let leaf1_key: H256 = [1u8; 32].to_vec().into();\n        let leaf1 = SMTValue {\n            nonce: 1,\n            balance: 99,\n        };\n        assert_eq!(store.get_leaf(\u0026leaf1_key).unwrap(), None::\u003cSMTValue\u003e);\n        store.insert_leaf(leaf1_key, leaf1.clone()).unwrap();\n        assert_eq!(store.get_leaf(\u0026leaf1_key).unwrap(), Some(leaf1));\n        \u003cSMTParityStore as StoreWriteOps\u003cSMTValue\u003e\u003e::remove_leaf(\u0026mut store, \u0026leaf1_key).unwrap();\n        assert_eq!(store.get_leaf(\u0026leaf1_key).unwrap(), None::\u003cSMTValue\u003e);\n\n        // \n        let node1_key: BranchKey = BranchKey::new(100, [2u8; 32].into());\n        let node1: BranchNode = BranchNode {\n            left: MergeValue::from_h256([3u8; 32].into()),\n            right: MergeValue::from_h256([4u8; 32].into()),\n        };\n        assert_eq!(\n            \u003cSMTParityStore as StoreReadOps\u003cSMTValue\u003e\u003e::get_branch(\u0026store, \u0026node1_key).unwrap(),\n            None::\u003cBranchNode\u003e\n        );\n        \u003cSMTParityStore as StoreWriteOps\u003cSMTValue\u003e\u003e::insert_branch(\n            \u0026mut store,\n            node1_key.clone(),\n            node1.clone(),\n        )\n        .unwrap();\n        assert_eq!(\n            \u003cSMTParityStore as StoreReadOps\u003cSMTValue\u003e\u003e::get_branch(\u0026store, \u0026node1_key).unwrap(),\n            Some(node1.clone())\n        );\n        \u003cSMTParityStore as StoreWriteOps\u003cSMTValue\u003e\u003e::remove_branch(\u0026mut store, \u0026node1_key).unwrap();\n        assert_eq!(\n            \u003cSMTParityStore as StoreReadOps\u003cSMTValue\u003e\u003e::get_branch(\u0026store, \u0026node1_key).unwrap(),\n            None::\u003cBranchNode\u003e\n        );\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":19}},{"line":26,"address":[],"length":0,"stats":{"Line":1025}},{"line":27,"address":[],"length":0,"stats":{"Line":1025}},{"line":28,"address":[],"length":0,"stats":{"Line":1025}},{"line":29,"address":[],"length":0,"stats":{"Line":2050}},{"line":32,"address":[],"length":0,"stats":{"Line":5}},{"line":33,"address":[],"length":0,"stats":{"Line":5}},{"line":34,"address":[],"length":0,"stats":{"Line":5}},{"line":35,"address":[],"length":0,"stats":{"Line":10}},{"line":38,"address":[],"length":0,"stats":{"Line":257}},{"line":39,"address":[],"length":0,"stats":{"Line":257}},{"line":40,"address":[],"length":0,"stats":{"Line":257}},{"line":41,"address":[],"length":0,"stats":{"Line":514}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":55,"address":[],"length":0,"stats":{"Line":1814}},{"line":56,"address":[],"length":0,"stats":{"Line":1814}},{"line":57,"address":[],"length":0,"stats":{"Line":1814}},{"line":58,"address":[],"length":0,"stats":{"Line":3628}},{"line":59,"address":[],"length":0,"stats":{"Line":2339}},{"line":60,"address":[],"length":0,"stats":{"Line":525}},{"line":63,"address":[],"length":0,"stats":{"Line":5}},{"line":64,"address":[],"length":0,"stats":{"Line":5}},{"line":65,"address":[],"length":0,"stats":{"Line":5}},{"line":66,"address":[],"length":0,"stats":{"Line":10}},{"line":67,"address":[],"length":0,"stats":{"Line":8}},{"line":68,"address":[],"length":0,"stats":{"Line":3}}],"covered":29,"coverable":29},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","rocks","apis.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Provide APIs, including database creation, creation of multiple Merkle trees, and Merkle tree-related operations.\n\n#![allow(dead_code)]\n#![allow(unused_imports)]\n\nuse crate::store::SMTStore;\nuse ethers::core::k256::sha2::digest::Key;\nuse kvdb_rocksdb::Database;\nuse smt_primitives::{\n    keccak_hasher::Keccak256Hasher,\n    verify::{verify as smt_verify, Proof},\n};\nuse sparse_merkle_tree::{\n    merge::MergeValue,\n    traits::{Hasher, Value},\n    SparseMerkleTree, H256,\n};\nuse std::{fmt::Debug, io, marker::PhantomData, path::Path};\n\nuse scale_info::TypeInfo;\nuse serde::{Deserialize, Serialize};\nuse serde_with::serde_as;\nuse sparse_merkle_tree::{\n    error::{Error, Result, Result as SMTResult},\n    CompiledMerkleProof,\n};\nuse std::{convert::AsRef, sync::Arc};\nuse utoipa::{ToSchema, __dev::ComposeSchema};\n// use crate::traits::MSS;\n\ntype MultiSMT\u003cV, H\u003e = SparseMerkleTree\u003cH, V, SMTStore\u003e;\n\n/// Multiple Merkle trees are stored in a KV database.\npub struct MultiSMTStore\u003cK, V, H\u003e {\n    store: Arc\u003cDatabase\u003e,\n    v: PhantomData\u003c(K, V, H)\u003e,\n}\n\nimpl\u003cK, V, H\u003e MultiSMTStore\u003cK, V, H\u003e\nwhere\n    K: Value\n        + Clone\n        + Serialize\n        + ToSchema\n        + Deserialize\u003c'static\u003e\n        + ComposeSchema\n        + Debug\n        + TypeInfo,\n    V: Default\n        + Value\n        + Into\u003cVec\u003cu8\u003e\u003e\n        + From\u003cVec\u003cu8\u003e\u003e\n        + ToSchema\n        + Serialize\n        + Deserialize\u003c'static\u003e\n        + ComposeSchema\n        + PartialEq\n        + Clone\n        + Debug\n        + TypeInfo,\n    H: Hasher + Default,\n{\n    /// Open the KV database, create it if it does not exist.\n    pub fn open\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e io::Result\u003cSelf\u003e {\n        let db = Database::open(\u0026Default::default(), path)?;\n        Ok(Self {\n            store: Arc::new(db),\n            v: PhantomData,\n        })\n    }\n\n    /// Create or open a new tree.\n    pub fn new_tree_with_store(\u0026self, prefix: String) -\u003e Result\u003cMultiSMT\u003cV, H\u003e\u003e {\n        let db = SMTStore::new(self.store.clone(), prefix);\n        MultiSMT::new_with_store(db)\n    }\n\n    /// Insert a value into a specific Merkle tree.\n    pub fn update(\u0026self, prefix: String, key: K, value: V) -\u003e SMTResult\u003cH256\u003e {\n        let mut tree = self.new_tree_with_store(prefix)?;\n        let h = tree.update(key.to_h256(), value)?;\n        Ok(*h)\n    }\n\n    /// Insert multiple values into a Merkle tree at once.\n    pub fn update_all(\u0026self, prefix: String, kvs: Vec\u003c(K, V)\u003e) -\u003e SMTResult\u003cH256\u003e {\n        let kvs = kvs\n            .into_iter()\n            .map(|(k, v)| Ok((k.to_h256(), v)))\n            .collect::\u003cResult\u003cVec\u003c(H256, V)\u003e\u003e\u003e()?;\n\n        let mut tree = self.new_tree_with_store(prefix)?;\n        let root = tree.update_all(kvs)?;\n        Ok(*root)\n    }\n\n    /// Get the root hash.\n    pub fn get_root(\u0026self, prefix: String) -\u003e Result\u003cH256\u003e {\n        let tree = self.new_tree_with_store(prefix)?;\n        Ok(*tree.root())\n    }\n\n    /// Get the value of a specific key in a particular tree.\n    pub fn get_value(\u0026self, prefix: String, key: K) -\u003e Result\u003cV\u003e {\n        let tree = self.new_tree_with_store(prefix)?;\n        let value = tree.get(\u0026key.to_h256())?;\n        Ok(value)\n    }\n\n    /// Get the Merkle proof.\n    pub fn get_merkle_proof(\u0026self, prefix: String, key: K) -\u003e Result\u003cProof\u003cK, V\u003e\u003e {\n        let tree = self.new_tree_with_store(prefix.clone())?;\n        let proof = tree.merkle_proof(vec![key.to_h256()])?;\n        let leaves_bitmap = proof.leaves_bitmap();\n        let siblings = proof.merkle_path();\n        let leave_bitmap = leaves_bitmap[0];\n        let value = self.get_value(prefix, key.clone())?;\n\n        Ok(Proof {\n            key: key.clone(),\n            value: value.clone(),\n            path: key.to_h256(),\n            value_hash: value.to_h256(),\n            root: *tree.root(),\n            leave_bitmap,\n            siblings: siblings.clone(),\n        })\n    }\n\n    /// Get the Merkle proof, the return value is `Vec\u003cu8\u003e`, which is not developer-friendly and may be inefficient for on-chain gas or functionality.\n    pub fn get_merkle_proof_old(\u0026self, prefix: String, keys: Vec\u003cK\u003e) -\u003e SMTResult\u003cVec\u003cu8\u003e\u003e {\n        let tree = self.new_tree_with_store(prefix)?;\n        let keys = keys\n            .into_iter()\n            .map(|k| Ok(k.to_h256()))\n            .collect::\u003cResult\u003cVec\u003cH256\u003e\u003e\u003e()?;\n\n        let proof = tree.merkle_proof(keys.clone())?;\n        let proof = proof.compile(keys)?;\n        Ok(proof.0)\n    }\n\n    /// Before data is updated, the future value of the root hash can be calculated in advance.\n    pub fn get_next_root(\u0026self, old_proof: Vec\u003cu8\u003e, next_kvs: Vec\u003c(K, V)\u003e) -\u003e Result\u003cH256\u003e {\n        let p = CompiledMerkleProof(old_proof);\n        let kvs = next_kvs\n            .into_iter()\n            .map(|(k, v)| Ok((k.to_h256(), v.to_h256())))\n            .collect::\u003cResult\u003cVec\u003c(H256, H256)\u003e\u003e\u003e()?;\n\n        let next_root = p.compute_root::\u003cH\u003e(kvs)?;\n        Ok(next_root)\n    }\n\n    /// Delete a specific Merkle tree.\n    pub fn clear(\u0026self, prefix: String) {\n        let mut tx = self.store.transaction();\n        tx.delete_prefix(Default::default(), prefix.as_bytes());\n        self.store.write(tx).unwrap();\n    }\n\n    /// Verify the Merkle proof.\n    pub fn verify(\u0026self, proof: Proof\u003cK, V\u003e) -\u003e bool {\n        let mut res = false;\n        if proof.value != V::default() {\n            res = smt_verify::\u003cH\u003e(\n                proof.path,\n                proof.value_hash,\n                proof.leave_bitmap,\n                proof.siblings,\n                proof.root,\n            )\n        }\n        res\n    }\n}\n\n#[cfg(test)]\npub mod test {\n    use super::*;\n    use actix_web::web;\n    use smt_primitives::kv::{SMTKey, SMTValue};\n    use std::sync::Mutex;\n    #[test]\n    fn test_apis() {\n        // multi_tree\n        let base_path = \"./apis_test_db\";\n        let multi_tree =\n            MultiSMTStore::\u003cSMTKey, SMTValue, Keccak256Hasher\u003e::open(Path::new(base_path)).unwrap();\n\n        let tree1: \u0026str = \"tree1\";\n        let tree2: \u0026str = \"tree2\";\n        multi_tree.clear(tree1.to_string());\n        multi_tree.clear(tree2.to_string());\n        multi_tree.new_tree_with_store(tree1.to_string()).unwrap();\n        multi_tree.new_tree_with_store(tree2.to_string()).unwrap();\n\n        // treeroot\n        assert_eq!(\n            multi_tree.get_root(tree1.to_string()).unwrap(),\n            H256::zero()\n        );\n        assert_eq!(\n            multi_tree.get_root(tree2.to_string()).unwrap(),\n            H256::zero()\n        );\n\n        // tree\n        let tree1_key1 = SMTKey {\n            address: \"1\".to_string(),\n        };\n        let tree1_value1: SMTValue = SMTValue {\n            nonce: 1,\n            balance: 99,\n        };\n        let tree1_key2 = SMTKey {\n            address: \"2\".to_string(),\n        };\n        let tree1_value2: SMTValue = SMTValue {\n            nonce: 2,\n            balance: 97,\n        };\n\n        assert_eq!(\n            multi_tree\n                .get_value(tree1.to_string(), tree1_key1.clone())\n                .unwrap(),\n            SMTValue::default()\n        );\n        assert_eq!(\n            multi_tree.get_root(tree1.to_string()).unwrap(),\n            H256::zero()\n        );\n        multi_tree\n            .update(tree1.to_string(), tree1_key1.clone(), tree1_value1.clone())\n            .unwrap();\n        assert_eq!(\n            multi_tree\n                .get_value(tree1.to_string(), tree1_key1.clone())\n                .unwrap(),\n            tree1_value1.clone()\n        );\n        let proof = multi_tree\n            .get_merkle_proof(tree1.to_string(), tree1_key1.clone())\n            .unwrap();\n        assert_eq!(multi_tree.verify(proof), true);\n        // remove\n        multi_tree\n            .update(tree1.to_string(), tree1_key1.clone(), SMTValue::default())\n            .unwrap();\n        assert_eq!(\n            multi_tree\n                .get_value(tree1.to_string(), tree1_key1.clone())\n                .unwrap(),\n            SMTValue::default()\n        );\n        assert_eq!(\n            multi_tree.get_root(tree1.to_string()).unwrap(),\n            H256::zero()\n        );\n        multi_tree\n            .update(tree1.to_string(), tree1_key1.clone(), tree1_value1.clone())\n            .unwrap();\n        let tree1_root1 = multi_tree.get_root(tree1.to_string()).unwrap();\n        let old_proof = multi_tree\n            .get_merkle_proof_old(tree1.to_string(), vec![tree1_key2.clone()])\n            .unwrap();\n        let _next_root = multi_tree\n            .get_next_root(\n                old_proof.clone(),\n                vec![(tree1_key2.clone(), tree1_value2.clone())],\n            )\n            .unwrap();\n        multi_tree\n            .update(tree1.to_string(), tree1_key2.clone(), tree1_value2.clone())\n            .unwrap();\n        let tree1_root2 = multi_tree.get_root(tree2.to_string()).unwrap();\n        assert_ne!(tree1_root1, tree1_root2);\n        assert_eq!(\n            multi_tree.get_root(tree2.to_string()).unwrap(),\n            H256::zero()\n        );\n\n        let tree2_root1 = multi_tree\n            .update(tree2.to_string(), tree1_key1.clone(), tree1_value1.clone())\n            .unwrap();\n        multi_tree\n            .update(tree2.to_string(), tree1_key2.clone(), tree1_value2.clone())\n            .unwrap();\n        assert_eq!(tree1_root1, tree2_root1);\n        assert_eq!(\n            multi_tree.get_root(tree1.to_string()).unwrap(),\n            multi_tree.get_root(tree2.to_string()).unwrap()\n        );\n        let tree2_proof1 = multi_tree\n            .get_merkle_proof(tree2.to_string(), tree1_key2.clone())\n            .unwrap();\n        assert_eq!(multi_tree.verify(tree2_proof1), true);\n\n        // clear\n        multi_tree.clear(tree1.to_string());\n        assert_eq!(\n            multi_tree\n                .get_value(tree1.to_string(), tree1_key2.clone())\n                .unwrap(),\n            SMTValue::default()\n        );\n        assert_eq!(\n            multi_tree\n                .get_value(tree2.to_string(), tree1_key2.clone())\n                .unwrap(),\n            tree1_value2.clone()\n        );\n        multi_tree.clear(tree2.to_string());\n        assert_eq!(\n            multi_tree\n                .get_value(tree2.to_string(), tree1_key2.clone())\n                .unwrap(),\n            SMTValue::default()\n        );\n        assert_eq!(\n            multi_tree\n                .get_value(tree2.to_string(), tree1_key1.clone())\n                .unwrap(),\n            SMTValue::default()\n        );\n        assert_eq!(\n            multi_tree.get_root(tree2.to_string()).unwrap(),\n            H256::zero()\n        );\n        let mut kvs: Vec\u003c(SMTKey, SMTValue)\u003e = vec![];\n\n        for i in 1..2 {\n            kvs.push((\n                SMTKey {\n                    address: i.to_string(),\n                },\n                SMTValue {\n                    nonce: i as u64,\n                    balance: i as u128,\n                },\n            ));\n        }\n\n        for kv in kvs.clone() {\n            multi_tree\n                .update(tree2.to_string(), kv.0.clone(), kv.1.clone())\n                .unwrap();\n            let p = multi_tree\n                .get_merkle_proof(tree2.to_string(), kv.0.clone())\n                .unwrap();\n            assert_eq!(multi_tree.verify(p), true);\n        }\n\n        multi_tree.clear(tree1.to_string());\n        for kv in kvs.clone() {\n            multi_tree\n                .update_all(tree1.to_string(), vec![(kv.0.clone(), kv.1.clone())])\n                .unwrap();\n            let p = multi_tree\n                .get_merkle_proof(tree1.to_string(), kv.0.clone())\n                .unwrap();\n            assert_eq!(multi_tree.verify(p), true);\n        }\n        assert_eq!(\n            multi_tree.get_root(tree1.to_string()).unwrap(),\n            multi_tree.get_root(tree2.to_string()).unwrap()\n        );\n        multi_tree\n            .update_all(tree1.to_string(), kvs.clone())\n            .unwrap();\n    }\n}\n","traces":[{"line":81,"address":[],"length":0,"stats":{"Line":3}},{"line":82,"address":[],"length":0,"stats":{"Line":6}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":345}},{"line":91,"address":[],"length":0,"stats":{"Line":345}},{"line":92,"address":[],"length":0,"stats":{"Line":345}},{"line":96,"address":[],"length":0,"stats":{"Line":109}},{"line":97,"address":[],"length":0,"stats":{"Line":218}},{"line":98,"address":[],"length":0,"stats":{"Line":109}},{"line":99,"address":[],"length":0,"stats":{"Line":109}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":4}},{"line":106,"address":[],"length":0,"stats":{"Line":6}},{"line":109,"address":[],"length":0,"stats":{"Line":2}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":12}},{"line":116,"address":[],"length":0,"stats":{"Line":24}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":113}},{"line":122,"address":[],"length":0,"stats":{"Line":226}},{"line":123,"address":[],"length":0,"stats":{"Line":113}},{"line":124,"address":[],"length":0,"stats":{"Line":113}},{"line":128,"address":[],"length":0,"stats":{"Line":106}},{"line":129,"address":[],"length":0,"stats":{"Line":212}},{"line":130,"address":[],"length":0,"stats":{"Line":106}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":106}},{"line":136,"address":[],"length":0,"stats":{"Line":106}},{"line":137,"address":[],"length":0,"stats":{"Line":106}},{"line":138,"address":[],"length":0,"stats":{"Line":106}},{"line":139,"address":[],"length":0,"stats":{"Line":106}},{"line":140,"address":[],"length":0,"stats":{"Line":106}},{"line":141,"address":[],"length":0,"stats":{"Line":106}},{"line":142,"address":[],"length":0,"stats":{"Line":106}},{"line":143,"address":[],"length":0,"stats":{"Line":106}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":3}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":7}},{"line":174,"address":[],"length":0,"stats":{"Line":7}},{"line":175,"address":[],"length":0,"stats":{"Line":7}},{"line":176,"address":[],"length":0,"stats":{"Line":7}},{"line":180,"address":[],"length":0,"stats":{"Line":4}},{"line":181,"address":[],"length":0,"stats":{"Line":4}},{"line":182,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":4}},{"line":184,"address":[],"length":0,"stats":{"Line":4}},{"line":185,"address":[],"length":0,"stats":{"Line":4}},{"line":186,"address":[],"length":0,"stats":{"Line":4}},{"line":187,"address":[],"length":0,"stats":{"Line":4}},{"line":188,"address":[],"length":0,"stats":{"Line":4}},{"line":191,"address":[],"length":0,"stats":{"Line":4}}],"covered":60,"coverable":67},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","rocks","mod.rs"],"content":"pub mod apis;\npub mod req;\npub mod store;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","rocks","req.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#![allow(unused_imports)]\nuse serde::{self, Deserialize, Serialize};\nuse smt_primitives::kv::{SMTKey, SMTValue};\nuse std::{fmt::Debug, marker::PhantomData};\nuse utoipa::{IntoParams, ToSchema, __dev::ComposeSchema};\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct ReqUpdate\u003cK, V\u003e {\n    pub prefix: String,\n    #[serde(flatten)]\n    pub key: K,\n    #[serde(flatten)]\n    pub value: V,\n}\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct ReqByKey\u003cK\u003e {\n    pub prefix: String,\n    #[serde(flatten)]\n    pub key: K,\n}\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct ReqByKVs\u003cKVPair\u003e {\n    pub prefix: String,\n    #[serde(flatten)]\n    pub kv: KVPair,\n}\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct KVPair\u003cK, V\u003e {\n    #[serde(flatten)]\n    pub key: K,\n    #[serde(flatten)]\n    pub value: V,\n}\n\n#[derive(Debug, Serialize, Deserialize, ToSchema)]\npub struct ReqByPrefix {\n    pub prefix: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","rocks","store.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Store the Merkle tree data in a KVDB (Key-Value Database).\n\n#![allow(unused_imports)]\n#![allow(clippy::needless_lifetimes)]\nuse sparse_merkle_tree::{\n    error::Error,\n    traits::{StoreReadOps, StoreWriteOps, Value},\n    BranchKey, BranchNode, H256,\n};\nuse std::{marker::PhantomData, sync::Arc};\n\nuse codec::{Decode, Encode};\n// use rocksdb::{DBCommon, DB, DBWithThreadMode, OptimisticTransactionDB, ThreadMode};\nuse kvdb_rocksdb::Database;\n\npub struct SMTStore {\n    inner: Arc\u003cDatabase\u003e,\n    // col: u32, //  0\n    prefix: String,\n}\n\nimpl SMTStore {\n    pub fn new(db: Arc\u003cDatabase\u003e, prefix: impl Into\u003cString\u003e) -\u003e Self {\n        SMTStore {\n            inner: db,\n            // col,\n            prefix: prefix.into(),\n        }\n    }\n}\n\nimpl\u003cV\u003e StoreWriteOps\u003cV\u003e for SMTStore\nwhere\n    V: Value + Into\u003cVec\u003cu8\u003e\u003e,\n{\n    fn insert_branch(\u0026mut self, node_key: BranchKey, branch: BranchNode) -\u003e Result\u003c(), Error\u003e {\n        let mut tx = self.inner.transaction();\n        tx.put(\n            Default::default(),\n            \u0026[self.prefix.as_bytes(), \u0026node_key.encode()].concat(),\n            \u0026branch.encode(),\n        );\n        self.inner\n            .write(tx)\n            .map_err(|e| Error::Store(e.to_string()))\n    }\n\n    // \n    fn insert_leaf(\u0026mut self, leaf_key: H256, leaf: V) -\u003e Result\u003c(), Error\u003e {\n        let mut tx = self.inner.transaction();\n        tx.put(\n            Default::default(),\n            \u0026[self.prefix.as_bytes(), \u0026leaf_key.encode()].concat(),\n            \u0026leaf.into(),\n        );\n        self.inner\n            .write(tx)\n            .map_err(|e| Error::Store(e.to_string()))\n    }\n\n    fn remove_branch(\u0026mut self, node_key: \u0026BranchKey) -\u003e Result\u003c(), Error\u003e {\n        let mut tx = self.inner.transaction();\n        tx.delete(\n            Default::default(),\n            \u0026[self.prefix.as_bytes(), \u0026node_key.encode()].concat(),\n        );\n        self.inner\n            .write(tx)\n            .map_err(|e| Error::Store(e.to_string()))\n    }\n\n    fn remove_leaf(\u0026mut self, leaf_key: \u0026H256) -\u003e Result\u003c(), Error\u003e {\n        let mut tx = self.inner.transaction();\n        tx.delete(\n            Default::default(),\n            \u0026[self.prefix.as_bytes(), \u0026leaf_key.encode()].concat(),\n        );\n        self.inner\n            .write(tx)\n            .map_err(|e| Error::Store(e.to_string()))\n    }\n}\n\nimpl\u003cV\u003e StoreReadOps\u003cV\u003e for SMTStore\nwhere\n    V: Value + From\u003cVec\u003cu8\u003e\u003e,\n{\n    fn get_branch(\u0026self, branch_key: \u0026BranchKey) -\u003e Result\u003cOption\u003cBranchNode\u003e, Error\u003e {\n        self.inner\n            .get(\n                Default::default(),\n                \u0026[self.prefix.as_bytes(), \u0026branch_key.encode()].concat(),\n            )\n            .map(|s| s.map(|v| BranchNode::decode(\u0026mut v.as_slice()).unwrap()))\n            .map_err(|e| Error::Store(e.to_string()))\n    }\n\n    fn get_leaf(\u0026self, leaf_key: \u0026H256) -\u003e Result\u003cOption\u003cV\u003e, Error\u003e {\n        self.inner\n            .get(\n                Default::default(),\n                \u0026[self.prefix.as_bytes(), leaf_key.as_slice()].concat(),\n            )\n            .map(|s| s.map(|v| v.into()))\n            .map_err(|e| Error::Store(e.to_string()))\n    }\n}\n\n#[cfg(test)]\npub mod test {\n    use super::*;\n    use smt_primitives::kv::{SMTKey, SMTValue};\n    use sparse_merkle_tree::{merge::MergeValue, traits::Value};\n    use std::path::Path;\n\n    #[test]\n    fn test_store() {\n        // \n        let base_path = \"./test_store_db\";\n        let db = Database::open(\u0026Default::default(), Path::new(base_path)).unwrap();\n        let mut store = SMTStore::new(Arc::new(db), \"test\");\n\n        //\n        let leaf1_key: H256 = [1u8; 32].to_vec().into();\n        let leaf1 = SMTValue {\n            nonce: 1,\n            balance: 99,\n        };\n        assert_eq!(store.get_leaf(\u0026leaf1_key).unwrap(), None::\u003cSMTValue\u003e);\n        store.insert_leaf(leaf1_key, leaf1.clone()).unwrap();\n        assert_eq!(store.get_leaf(\u0026leaf1_key).unwrap(), Some(leaf1));\n        \u003cSMTStore as StoreWriteOps\u003cSMTValue\u003e\u003e::remove_leaf(\u0026mut store, \u0026leaf1_key).unwrap();\n        assert_eq!(store.get_leaf(\u0026leaf1_key).unwrap(), None::\u003cSMTValue\u003e);\n\n        // \n        let node1_key: BranchKey = BranchKey::new(100, [2u8; 32].into());\n        let node1: BranchNode = BranchNode {\n            left: MergeValue::from_h256([3u8; 32].into()),\n            right: MergeValue::from_h256([4u8; 32].into()),\n        };\n        assert_eq!(\n            \u003cSMTStore as StoreReadOps\u003cSMTValue\u003e\u003e::get_branch(\u0026store, \u0026node1_key).unwrap(),\n            None::\u003cBranchNode\u003e\n        );\n        \u003cSMTStore as StoreWriteOps\u003cSMTValue\u003e\u003e::insert_branch(\n            \u0026mut store,\n            node1_key.clone(),\n            node1.clone(),\n        )\n        .unwrap();\n        assert_eq!(\n            \u003cSMTStore as StoreReadOps\u003cSMTValue\u003e\u003e::get_branch(\u0026store, \u0026node1_key).unwrap(),\n            Some(node1.clone())\n        );\n        \u003cSMTStore as StoreWriteOps\u003cSMTValue\u003e\u003e::remove_branch(\u0026mut store, \u0026node1_key.clone())\n            .unwrap();\n        assert_eq!(\n            \u003cSMTStore as StoreReadOps\u003cSMTValue\u003e\u003e::get_branch(\u0026store, \u0026node1_key).unwrap(),\n            None::\u003cBranchNode\u003e\n        );\n    }\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":346}},{"line":44,"address":[],"length":0,"stats":{"Line":346}},{"line":53,"address":[],"length":0,"stats":{"Line":27649}},{"line":54,"address":[],"length":0,"stats":{"Line":27649}},{"line":55,"address":[],"length":0,"stats":{"Line":27649}},{"line":56,"address":[],"length":0,"stats":{"Line":27649}},{"line":57,"address":[],"length":0,"stats":{"Line":27649}},{"line":58,"address":[],"length":0,"stats":{"Line":27649}},{"line":60,"address":[],"length":0,"stats":{"Line":27649}},{"line":61,"address":[],"length":0,"stats":{"Line":27649}},{"line":62,"address":[],"length":0,"stats":{"Line":55298}},{"line":66,"address":[],"length":0,"stats":{"Line":109}},{"line":67,"address":[],"length":0,"stats":{"Line":109}},{"line":68,"address":[],"length":0,"stats":{"Line":109}},{"line":69,"address":[],"length":0,"stats":{"Line":109}},{"line":70,"address":[],"length":0,"stats":{"Line":109}},{"line":71,"address":[],"length":0,"stats":{"Line":109}},{"line":73,"address":[],"length":0,"stats":{"Line":109}},{"line":74,"address":[],"length":0,"stats":{"Line":109}},{"line":75,"address":[],"length":0,"stats":{"Line":218}},{"line":78,"address":[],"length":0,"stats":{"Line":769}},{"line":79,"address":[],"length":0,"stats":{"Line":769}},{"line":80,"address":[],"length":0,"stats":{"Line":769}},{"line":81,"address":[],"length":0,"stats":{"Line":769}},{"line":82,"address":[],"length":0,"stats":{"Line":769}},{"line":84,"address":[],"length":0,"stats":{"Line":769}},{"line":85,"address":[],"length":0,"stats":{"Line":769}},{"line":86,"address":[],"length":0,"stats":{"Line":1538}},{"line":89,"address":[],"length":0,"stats":{"Line":4}},{"line":90,"address":[],"length":0,"stats":{"Line":4}},{"line":91,"address":[],"length":0,"stats":{"Line":4}},{"line":92,"address":[],"length":0,"stats":{"Line":4}},{"line":93,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":4}},{"line":97,"address":[],"length":0,"stats":{"Line":8}},{"line":105,"address":[],"length":0,"stats":{"Line":56857}},{"line":106,"address":[],"length":0,"stats":{"Line":56857}},{"line":108,"address":[],"length":0,"stats":{"Line":56857}},{"line":109,"address":[],"length":0,"stats":{"Line":56857}},{"line":111,"address":[],"length":0,"stats":{"Line":256258}},{"line":112,"address":[],"length":0,"stats":{"Line":113714}},{"line":115,"address":[],"length":0,"stats":{"Line":111}},{"line":116,"address":[],"length":0,"stats":{"Line":111}},{"line":118,"address":[],"length":0,"stats":{"Line":111}},{"line":119,"address":[],"length":0,"stats":{"Line":111}},{"line":121,"address":[],"length":0,"stats":{"Line":551}},{"line":122,"address":[],"length":0,"stats":{"Line":222}}],"covered":48,"coverable":48},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","backend","src","traits.rs"],"content":"use scale_info::TypeInfo;\nuse serde::{Deserialize, Serialize};\nuse smt_primitives::verify::Proof;\nuse sparse_merkle_tree::{\n    error::{Error, Result as SMTResult},\n    traits::{Hasher, Value},\n    H256,\n};\nuse std::{fmt::Debug, path::Path};\nuse utoipa::{ToSchema, __dev::ComposeSchema};\n\n/// Multi Sparse Merkle Tree Store trait\n/// Defines common operations for managing multiple Sparse Merkle Trees in a single store\npub trait MSS\u003cT, K, V, H\u003e: Sized\nwhere\n    T: AsRef\u003c[u8]\u003e, // tree_id \n    K: Value + Clone + Serialize + ToSchema + Deserialize\u003c'static\u003e + ComposeSchema + Debug + TypeInfo,\n    V: Default\n        + Value\n        + Into\u003cVec\u003cu8\u003e\u003e\n        + From\u003cVec\u003cu8\u003e\u003e\n        + ToSchema\n        + Serialize\n        + Deserialize\u003c'static\u003e\n        + ComposeSchema\n        + PartialEq\n        + Clone\n        + Debug\n        + TypeInfo,\n    H: Hasher + Default,\n{\n    /// Associated type for the tree implementation\n    type Tree;\n\n    /// Open the database, create it if it does not exist\n    fn open\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e std::io::Result\u003cSelf\u003e;\n\n    /// Create or open a new tree\n    fn new_tree_with_store\u003c'a\u003e(\u0026'a self, tree_id: T) -\u003e Result\u003cSelf::Tree, Error\u003e;\n\n    /// Insert a value into a specific Merkle tree\n    fn update(\u0026self, tree_id: T, key: K, value: V) -\u003e SMTResult\u003cH256\u003e;\n\n    /// Insert multiple values into a Merkle tree at once\n    fn update_all(\u0026self, tree_id: T, kvs: Vec\u003c(K, V)\u003e) -\u003e SMTResult\u003cH256\u003e;\n\n    /// Get the root hash of a specific tree\n    fn get_root(\u0026self, tree_id: T) -\u003e Result\u003cH256, Error\u003e;\n\n    /// Get the value of a specific key in a particular tree\n    fn get_value(\u0026self, tree_id: T, key: K) -\u003e Result\u003cV, Error\u003e;\n\n    /// Get the Merkle proof for a specific key\n    fn get_merkle_proof(\u0026self, tree_id: T, key: K) -\u003e Result\u003cProof\u003cK, V\u003e, Error\u003e;\n\n    /// Get the Merkle proof in raw bytes format\n    fn get_merkle_proof_old(\u0026self, tree_id: T, keys: Vec\u003cK\u003e) -\u003e SMTResult\u003cVec\u003cu8\u003e\u003e;\n\n    /// Calculate the future root hash before updating data\n    fn get_next_root(\u0026self, old_proof: Vec\u003cu8\u003e, next_kvs: Vec\u003c(K, V)\u003e) -\u003e Result\u003cH256, Error\u003e;\n\n    /// Delete/clear a specific Merkle tree\n    fn clear(\u0026self, tree_id: T) -\u003e Result\u003c(), Error\u003e;\n\n    /// Verify a Merkle proof\n    fn verify(\u0026self, proof: Proof\u003cK, V\u003e) -\u003e bool;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","ink-contract","SMT","lib.rs"],"content":"#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n#![allow(unexpected_cfgs)]\n\n#[ink::contract]\nmod smt {\n    use smt_primitives::{\n        keccak_hasher::Keccak256Hasher,\n        kv::{SMTKey, SMTValue},\n        sparse_merkle_tree::H256,\n        verify::{verify as smt_verify, Proof},\n    };\n\n    /// Defines the storage of your contract.\n    /// Add new fields to the below struct in order\n    /// to add new static storage fields to your contract.\n    #[ink(storage)]\n    #[derive(Default)]\n    pub struct Smt;\n\n    #[ink(event)]\n    pub struct SMTVerify {\n        who: AccountId,\n        #[ink(topic)]\n        path: H256,\n        #[ink(topic)]\n        root: H256,\n    }\n\n    pub type Result\u003cT\u003e = core::result::Result\u003cT, Error\u003e;\n\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        SMTVerifyFaild,\n    }\n\n    impl Smt {\n        #[ink(constructor)]\n        pub fn new() -\u003e Self {\n            Self::default()\n        }\n\n        #[ink(message)]\n        pub fn smt_verify(\u0026self, proof: Proof\u003cSMTKey, SMTValue\u003e) -\u003e Result\u003c()\u003e {\n            self.do_verify(proof)\n        }\n\n        fn do_verify(\u0026self, proof: Proof\u003cSMTKey, SMTValue\u003e) -\u003e Result\u003c()\u003e {\n            let from = self.env().caller();\n            if !smt_verify::\u003cKeccak256Hasher\u003e(\n                proof.path,\n                proof.value_hash,\n                proof.leave_bitmap,\n                proof.siblings,\n                proof.root,\n            ) {\n                return Err(Error::SMTVerifyFaild);\n            }\n            Self::env().emit_event(SMTVerify {\n                who: from,\n                path: proof.path,\n                root: proof.root,\n            });\n            Ok(())\n        }\n    }\n\n    /// Unit tests in Rust are normally defined within such a `#[cfg(test)]`\n    /// module and test functions are marked with a `#[test]` attribute.\n    /// The below code is technically just normal Rust code.\n    #[cfg(test)]\n    mod tests {\n        #![allow(unused_imports)]\n        /// Imports all the definitions from the outer scope so we can use them here.\n        use super::*;\n        use smt_backend_lib::apis::MultiSMTStore;\n        use smt_primitives::{\n            keccak_hasher::Keccak256Hasher,\n            kv::{SMTKey, SMTValue},\n            verify::Proof,\n        };\n        use std::path::Path;\n\n        pub fn creat_db_and_get_proof(size: u8) -\u003e Vec\u003cProof\u003cSMTKey, SMTValue\u003e\u003e {\n            let base_path = \"./smt_ink_test_db\";\n            let multi_tree =\n                MultiSMTStore::\u003cSMTKey, SMTValue, Keccak256Hasher\u003e::open(Path::new(base_path))\n                    .unwrap();\n            // tree\n            let tree = \"tree1\";\n            multi_tree.clear(tree.to_string());\n            let mut kvs: Vec\u003c(SMTKey, SMTValue)\u003e = vec![];\n\n            for i in 0..size {\n                kvs.push((\n                    SMTKey {\n                        address: i.to_string(),\n                    },\n                    SMTValue {\n                        nonce: i as u64,\n                        balance: i as u128,\n                    },\n                ));\n            }\n\n            for kv in kvs.clone() {\n                multi_tree\n                    .update(tree.to_string(), kv.0.clone(), kv.1.clone())\n                    .unwrap();\n            }\n\n            let mut proofs: Vec\u003cProof\u003cSMTKey, SMTValue\u003e\u003e = vec![];\n            for kv in kvs.clone() {\n                let proof = multi_tree\n                    .get_merkle_proof(tree.to_string(), kv.0.clone())\n                    .unwrap();\n                proofs.push(proof);\n            }\n\n            proofs\n        }\n\n        #[ink::test]\n        fn smt_verify_works() {\n            let smt = Smt::new();\n            let proofs = creat_db_and_get_proof(2);\n            assert_ne!(smt.smt_verify(proofs[0].clone()), Ok(()));\n            proofs[1..].iter().for_each(|p| {\n                // ;\n                assert_eq!(smt.smt_verify(p.clone()), Ok(()));\n            });\n        }\n    }\n\n    /// This is how you'd write end-to-end (E2E) or integration tests for ink! contracts.\n    ///\n    /// When running these you need to make sure that you:\n    /// - Compile the tests with the `e2e-tests` feature flag enabled (`--features e2e-tests`)\n    /// - Are running a Substrate node which contains `pallet-contracts` in the background\n    #[cfg(all(test, feature = \"e2e-tests\"))]\n    mod e2e_tests {\n        /// Imports all the definitions from the outer scope so we can use them here.\n        use super::*;\n        use crate::smt::tests::creat_db_and_get_proof;\n\n        /// A helper function used for calling contract messages.\n        use ink_e2e::ContractsBackend;\n\n        /// The End-to-End test `Result` type.\n        type E2EResult\u003cT\u003e = std::result::Result\u003cT, Box\u003cdyn std::error::Error\u003e\u003e;\n\n        #[ink_e2e::test]\n        async fn it_works(mut client: ink_e2e::Client\u003cC, E\u003e) -\u003e E2EResult\u003c()\u003e {\n            let mut constructor = SmtRef::new();\n            let contract = client\n                .instantiate(\"smt\", \u0026ink_e2e::bob(), \u0026mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = contract.call_builder::\u003cSmt\u003e();\n\n            let proofs = creat_db_and_get_proof(2);\n\n            let verify = call_builder.smt_verify(proofs[1].clone());\n            let _flip_result = client\n                .call(\u0026ink_e2e::bob(), \u0026verify)\n                .submit()\n                .await\n                .expect(\"verify failed\");\n            // \n\n            Ok(())\n        }\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":64,"address":[],"length":0,"stats":{"Line":1}}],"covered":16,"coverable":16},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","pallet","SMT","src","benchmarking.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#![cfg(feature = \"runtime-benchmarks\")]\nuse super::*;\n\n#[allow(unused)]\nuse crate::Pallet as Template;\nuse frame_benchmarking::v2::*;\nuse frame_system::RawOrigin;\nuse mock::creat_db_and_get_proof;\nuse primitives::kv::{SMTKey, SMTValue};\n\n#[benchmarks]\nmod benchmarks {\n    use super::*;\n\n    #[benchmark]\n    fn smt_verify() {\n        let proof = creat_db_and_get_proof(3);\n        let caller: T::AccountId = whitelisted_caller();\n        #[extrinsic_call]\n        smt_verify(RawOrigin::Signed(caller), p);\n    }\n\n    impl_benchmark_test_suite!(Template, crate::mock::new_test_ext(), crate::mock::Test);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","pallet","SMT","src","lib.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! This template will be responsible for verifying Merkle tree proofs on-chain. We follow the principle of minimizing on-chain computation and storage resources as much as possible, providing only the verification method.  \n//! The advantage of Merkle trees lies precisely in this approach.  \n//! The Merkle tree proof is provided by the `merkle_proof` API from the SMT backend.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\npub use pallet::*;\n\n#[cfg(test)]\nmod mock;\n\n#[cfg(test)]\nmod tests;\n\npub mod weights;\n\n#[cfg(feature = \"runtime-benchmarks\")]\nmod benchmarking;\n\n#[frame_support::pallet]\npub mod pallet {\n    use crate::weights::WeightInfo;\n    use core::convert::TryInto;\n    use frame_support::{dispatch::DispatchResultWithPostInfo, pallet_prelude::*};\n    use frame_system::pallet_prelude::*;\n    use primitives::{\n        sparse_merkle_tree::{\n            traits::{Hasher, Value},\n            H256,\n        },\n        verify::{self, Proof},\n    };\n    use scale_info::prelude::fmt::Debug;\n\n    /// Configure the pallet by specifying the parameters and types on which it depends.\n    #[pallet::config]\n    pub trait Config: frame_system::Config {\n        /// Because this pallet emits events, it depends on the runtime's definition of an event.\n        type RuntimeEvent: From\u003cEvent\u003cSelf\u003e\u003e + IsType\u003c\u003cSelf as frame_system::Config\u003e::RuntimeEvent\u003e;\n        /// A type representing the weights required by the dispatchables of this pallet.\n        type WeightInfo: crate::weights::WeightInfo;\n        /// The data type of the Key in the KVDB.\n        type SMTKey: Value + Default + Debug + Clone + TypeInfo + Encode + Decode + PartialEq;\n        /// The data type of the value in the KVDB.\n        type SMTValue: Value + Default + Debug + Clone + TypeInfo + Encode + Decode + PartialEq;\n        /// The hash algorithm chosen for this Merkle tree off-chain.\n        type SMTHasher: Hasher + Default;\n    }\n\n    #[pallet::pallet]\n    pub struct Pallet\u003cT\u003e(_);\n\n    // Pallets use events to inform users when important changes are made.\n    // https://docs.substrate.io/v3/runtime/events-and-errors\n    #[pallet::event]\n    #[pallet::generate_deposit(pub(super) fn deposit_event)]\n    pub enum Event\u003cT: Config\u003e {\n        /// Merkle proof verification passed.\n        SMTVerify {\n            /// Who submitted the proof to the blockchain.\n            account: T::AccountId,\n            /// The path of the leaf being proven.\n            path: H256,\n            /// root hash\n            root: H256,\n        },\n    }\n\n    // Errors inform users that something went wrong.\n    #[pallet::error]\n    pub enum Error\u003cT\u003e {\n        /// Merkle proof verification failed.\n        SMTVerifyFaild,\n    }\n\n    #[pallet::hooks]\n    impl\u003cT: Config\u003e Hooks\u003cBlockNumberFor\u003cT\u003e\u003e for Pallet\u003cT\u003e {}\n\n    // Dispatchable functions allows users to interact with the pallet and invoke state changes.\n    // These functions materialize as \"extrinsics\", which are often compared to transactions.\n    // Dispatchable functions must be annotated with a weight and must return a DispatchResult.\n    #[pallet::call]\n    impl\u003cT: Config\u003e Pallet\u003cT\u003e {\n\n        /// Verify the Merkle proof provided off-chain.\n        /// \n        #[pallet::call_index(0)]\n        #[pallet::weight(T::WeightInfo::smt_verify().saturating_mul(1_u64 + proof.siblings.len() as u64))]\n        pub fn smt_verify(\n            origin: OriginFor\u003cT\u003e,\n            proof: verify::Proof\u003cT::SMTKey, T::SMTValue\u003e,\n        ) -\u003e DispatchResultWithPostInfo {\n            let who = ensure_signed(origin)?;\n            Self::do_verify(who, proof)\n        }\n    }\n\n    impl\u003cT: Config\u003e Pallet\u003cT\u003e {\n        pub fn do_verify(\n            who: T::AccountId,\n            proof: Proof\u003cT::SMTKey, T::SMTValue\u003e,\n        ) -\u003e DispatchResultWithPostInfo {\n            ensure!(\n                verify::verify::\u003cT::SMTHasher\u003e(\n                    proof.path,\n                    proof.value_hash,\n                    proof.leave_bitmap,\n                    proof.siblings,\n                    proof.root,\n                ),\n                Error::\u003cT\u003e::SMTVerifyFaild\n            );\n            Self::deposit_event(Event::\u003cT\u003e::SMTVerify {\n                account: who,\n                path: proof.path,\n                root: proof.root,\n            });\n\n            Ok(().into())\n        }\n    }\n}\n","traces":[{"line":110,"address":[],"length":0,"stats":{"Line":200}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":100}},{"line":120,"address":[],"length":0,"stats":{"Line":100}},{"line":121,"address":[],"length":0,"stats":{"Line":100}},{"line":122,"address":[],"length":0,"stats":{"Line":100}},{"line":123,"address":[],"length":0,"stats":{"Line":100}},{"line":124,"address":[],"length":0,"stats":{"Line":100}},{"line":125,"address":[],"length":0,"stats":{"Line":100}},{"line":126,"address":[],"length":0,"stats":{"Line":100}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[],"length":0,"stats":{"Line":99}},{"line":131,"address":[],"length":0,"stats":{"Line":99}},{"line":132,"address":[],"length":0,"stats":{"Line":99}},{"line":133,"address":[],"length":0,"stats":{"Line":99}},{"line":136,"address":[],"length":0,"stats":{"Line":99}}],"covered":15,"coverable":16},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","pallet","SMT","src","mock.rs"],"content":"use frame_support::{derive_impl, parameter_types, traits::Everything};\nuse frame_system as system;\nuse primitives::{\n    keccak_hasher::Keccak256Hasher,\n    kv::{SMTKey, SMTValue},\n    verify::Proof,\n};\nuse smt_backend_lib::apis::MultiSMTStore;\nuse sp_core::H256;\nuse sp_runtime::{\n    traits::{BlakeTwo256, IdentityLookup},\n    BuildStorage,\n};\nuse std::path::Path;\ntype Block = frame_system::mocking::MockBlock\u003cTest\u003e;\n\npub fn creat_db_and_get_proof(size: u8) -\u003e Vec\u003cProof\u003cSMTKey, SMTValue\u003e\u003e {\n    let base_path = \"./smt_mock_db\";\n    let multi_tree =\n        MultiSMTStore::\u003cSMTKey, SMTValue, Keccak256Hasher\u003e::open(Path::new(base_path)).unwrap();\n    // tree\n    let tree = \"tree1\";\n    multi_tree.clear(tree.to_string());\n    let mut kvs: Vec\u003c(SMTKey, SMTValue)\u003e = vec![];\n\n    for i in 0..size {\n        kvs.push((\n            SMTKey {\n                address: i.to_string(),\n            },\n            SMTValue {\n                nonce: i as u64,\n                balance: i as u128,\n            },\n        ));\n    }\n\n    for kv in kvs.clone() {\n        multi_tree\n            .update(tree.to_string(), kv.0.clone(), kv.1.clone())\n            .unwrap();\n    }\n\n    let mut proofs: Vec\u003cProof\u003cSMTKey, SMTValue\u003e\u003e = vec![];\n    for kv in kvs.clone() {\n        let proof = multi_tree\n            .get_merkle_proof(tree.to_string(), kv.0.clone())\n            .unwrap();\n        proofs.push(proof);\n    }\n\n    proofs\n}\n\n// Configure a mock runtime to test the pallet.\nframe_support::construct_runtime!(\n    pub enum Test\n    {\n        System: frame_system::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e},\n        TemplateModule: crate::{Pallet, Call, Storage, Event\u003cT\u003e},\n    }\n);\n\nparameter_types! {\n    pub const SS58Prefix: u8 = 42;\n}\n\n#[derive_impl(frame_system::config_preludes::TestDefaultConfig)]\nimpl system::Config for Test {\n    type BaseCallFilter = Everything;\n    type BlockWeights = ();\n    type BlockLength = ();\n    type DbWeight = ();\n    type RuntimeOrigin = RuntimeOrigin;\n    type RuntimeCall = RuntimeCall;\n    type Nonce = u64;\n    type Hash = H256;\n    type Hashing = BlakeTwo256;\n    type AccountId = u64;\n    type Lookup = IdentityLookup\u003cSelf::AccountId\u003e;\n    type Block = Block;\n    type RuntimeEvent = RuntimeEvent;\n    type Version = ();\n    type PalletInfo = PalletInfo;\n    type AccountData = ();\n    type OnNewAccount = ();\n    type OnKilledAccount = ();\n    type SystemWeightInfo = ();\n    type SS58Prefix = SS58Prefix;\n    type OnSetCode = ();\n    type MaxConsumers = frame_support::traits::ConstU32\u003c16\u003e;\n}\n\nimpl crate::Config for Test {\n    type RuntimeEvent = RuntimeEvent;\n    type WeightInfo = ();\n    type SMTHasher = Keccak256Hasher;\n    type SMTKey = SMTKey;\n    type SMTValue = SMTValue;\n}\n\n// Build genesis storage according to the mock runtime.\npub fn new_test_ext() -\u003e sp_io::TestExternalities {\n    system::GenesisConfig::\u003cTest\u003e::default()\n        .build_storage()\n        .unwrap()\n        .into()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","pallet","SMT","src","tests.rs"],"content":"#![allow(unused_imports)]\nuse crate::{mock::*, Error};\nuse frame_support::{assert_err, assert_noop, assert_ok};\nuse primitives::verify::Proof;\n\n#[test]\nfn it_works_for_smt_verify() {\n    new_test_ext().execute_with(|| {\n        // Dispatch a signed extrinsic.\n        let who = RuntimeOrigin::signed(1);\n        let proofs = creat_db_and_get_proof(100 as u8);\n        assert_err!(\n            TemplateModule::smt_verify(who.clone(), proofs[0].clone()),\n            Error::\u003cTest\u003e::SMTVerifyFaild\n        );\n        proofs[1..].iter().for_each(|p| {\n            assert_ok!(TemplateModule::smt_verify(who.clone(), p.clone()));\n        });\n    });\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","pallet","SMT","src","weights.rs"],"content":"\n//! Autogenerated weights for pallet_template\n//!\n//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev\n//! DATE: 2023-04-06, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`\n//! WORST CASE MAP SIZE: `1000000`\n//! HOSTNAME: `Alexs-MacBook-Pro-2.local`, CPU: `\u003cUNKNOWN\u003e`\n//! EXECUTION: Some(Wasm), WASM-EXECUTION: Compiled, CHAIN: Some(\"dev\"), DB CACHE: 1024\n\n// Executed Command:\n// ../../target/release/node-template\n// benchmark\n// pallet\n// --chain\n// dev\n// --pallet\n// pallet_template\n// --extrinsic\n// *\n// --steps=50\n// --repeat=20\n// --wasm-execution=compiled\n// --output\n// pallets/template/src/weights.rs\n// --template\n// ../../.maintain/frame-weight-template.hbs\n\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused_parens)]\n#![allow(unused_imports)]\n\nuse frame_support::{traits::Get, weights::{Weight, constants::RocksDbWeight}};\nuse core::marker::PhantomData;\n\n/// Weight functions needed for pallet_template.\npub trait WeightInfo {\n\tfn smt_verify() -\u003e Weight;\n}\n\n/// Weights for pallet_template using the Substrate node and recommended hardware.\npub struct SubstrateWeight\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: frame_system::Config\u003e WeightInfo for SubstrateWeight\u003cT\u003e {\n\n\t/// Storage: TemplateModule Something (r:1 w:1)\n\t/// Proof: TemplateModule Something (max_values: Some(1), max_size: Some(4), added: 499, mode: MaxEncodedLen)\n\tfn smt_verify() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `32`\n\t\t//  Estimated: `1489`\n\t\t// Minimum execution time: 6_000_000 picoseconds.\n\t\tWeight::from_parts(6_000_000, 1489)\n\t\t\t.saturating_add(T::DbWeight::get().reads(1_u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1_u64))\n\t}\n}\n\n// For backwards compatibility and tests\nimpl WeightInfo for () {\n\t\n\t/// Storage: TemplateModule Something (r:1 w:1)\n\t/// Proof: TemplateModule Something (max_values: Some(1), max_size: Some(4), added: 499, mode: MaxEncodedLen)\n\tfn smt_verify() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `32`\n\t\t//  Estimated: `1489`\n\t\t// Minimum execution time: 6_000_000 picoseconds.\n\t\tWeight::from_parts(6_000_000, 1489)\n\t\t\t.saturating_add(RocksDbWeight::get().reads(1_u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(1_u64))\n\t}\n}","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","primitives","src","keccak_hasher.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Typically, the computation of the Merkle tree root, as well as proof generation and verification, relies on a specific hash algorithm.\n//! This algorithm is responsible for transforming complex data structures encountered along the path into a hash value. In SMT, hash computations are needed for data types like `[u8; 32]` and `u8`.\n//! In this project, Keccak256 will be used by default, primarily considering Ethereum compatibility. However, you can choose other hash algorithms based on the specific requirements of your project.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse sha3::{Digest, Keccak256};\nuse sparse_merkle_tree::{traits::Hasher, H256};\n\n/// Choose the Keccak256 algorithm to compute the hash values for `[u8; 32]` and `u8` data.\npub struct Keccak256Hasher(Keccak256);\n\nimpl Default for Keccak256Hasher {\n    fn default() -\u003e Self {\n        Keccak256Hasher(Keccak256::new())\n    }\n}\n\nimpl Hasher for Keccak256Hasher {\n    fn write_h256(\u0026mut self, h: \u0026H256) {\n        self.0.update(h.as_ref());\n    }\n    fn write_byte(\u0026mut self, b: u8) {\n        self.0.update(\u0026[b][..])\n    }\n\n    fn finish(self) -\u003e H256 {\n        let a: [u8; 32] = self.0.finalize().into();\n        a.into()\n    }\n}\n\n#[cfg(test)]\npub mod test {\n    use super::*;\n    use ethers::utils::keccak256;\n    #[test]\n    fn test_hasher() {\n        let mut hasher = Keccak256Hasher::default();\n        hasher.write_h256(\u0026H256::default());\n        let h1 = hasher.finish();\n\n        let h11: H256 = keccak256(\u0026H256::default()).into();\n        assert_eq!(h1, h11);\n\n        let b: H256 = [1u8; 32].to_vec().into();\n        let mut hasher1 = Keccak256Hasher::default();\n        hasher1.write_h256(\u0026b);\n        let h2 = hasher1.finish();\n        let h22: H256 = keccak256(\u0026b).into();\n        assert_eq!(h2, h22);\n\n        let mut hasher2 = Keccak256Hasher::default();\n        hasher2.write_byte(25u8);\n        let h2: H256 = hasher2.finish();\n        assert_eq!(h2, keccak256(25u8.to_be_bytes()).into());\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":2656}},{"line":32,"address":[],"length":0,"stats":{"Line":2656}},{"line":37,"address":[],"length":0,"stats":{"Line":6847}},{"line":38,"address":[],"length":0,"stats":{"Line":6847}},{"line":40,"address":[],"length":0,"stats":{"Line":4967}},{"line":41,"address":[],"length":0,"stats":{"Line":4967}},{"line":44,"address":[],"length":0,"stats":{"Line":2656}},{"line":45,"address":[],"length":0,"stats":{"Line":2656}},{"line":46,"address":[],"length":0,"stats":{"Line":2656}}],"covered":9,"coverable":9},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","primitives","src","kv.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! You can think of this backend as a KVDB, but it also provides Merkle proofs for the existence or non-existence of data.  \n//! Here, define the data structures for your key and value, as they determine how data is stored in the database.  \n//! Your key will ultimately be hashed, and this hash will determine the path of your value in the Merkle tree.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\nuse codec::{Decode, Encode};\n// use ethers::utils::keccak256;\nuse scale_info::TypeInfo;\nuse serde::{Deserialize, Serialize};\nuse serde_with::{serde_as, DisplayFromStr};\n// use sp_core::Hasher::keccak256;\nuse scale_info::prelude::{string::String, vec::Vec};\nuse sha3::Digest;\n// use sp_crypto_hashing::keccak_256;\nuse scale_info::prelude::fmt::Debug;\nuse sha3::Keccak256;\nuse sparse_merkle_tree::{traits::Value, H256};\n\ncfg_if::cfg_if! {\n    if #[cfg(feature=\"std\")] {\n        /// The data structure of the value in the KVDB, which determines the type of data you store in the Merkle tree.\n        use utoipa::{IntoParams, ToSchema};\n        #[serde_as]\n        #[derive(\n            Encode,\n            Decode,\n            Debug,\n            Serialize,\n            Deserialize,\n            Default,\n            PartialEq,\n            Eq,\n            Clone,\n            ToSchema,\n            IntoParams,\n            TypeInfo,\n        )]\n        pub struct SMTValue {\n            /// The nonce value of the user account.\n            // #[serde_as(as = \"DisplayFromStr\")]\n            pub nonce: u64,\n            /// The balance of the user account.\n            #[serde_as(as = \"DisplayFromStr\")]\n            pub balance: u128,\n        }\n\n        #[serde_as]\n        #[derive(\n            Encode,\n            Decode,\n            Debug,\n            Serialize,\n            Deserialize,\n            Default,\n            PartialEq,\n            Eq,\n            Clone,\n            ToSchema,\n            IntoParams,\n            TypeInfo,\n        )]\n        /// The key in the KVDB, which determines for whom you are storing data.\n        pub struct SMTKey {\n            /// The on-chain user address.\n            pub address: String,\n        }\n    } else {\n        /// The data structure of the value in the KVDB, which determines the type of data you store in the Merkle tree.\n        #[serde_as]\n        #[derive(\n            Encode,\n            Decode,\n            Debug,\n            Serialize,\n            Deserialize,\n            Default,\n            PartialEq,\n            Eq,\n            Clone,\n            // ToSchema,\n            // IntoParams,\n            TypeInfo,\n        )]\n        pub struct SMTValue {\n            /// The nonce value of the user account.\n            // #[serde_as(as = \"DisplayFromStr\")]\n            pub nonce: u64,\n             /// The balance of the user account.\n            #[serde_as(as = \"DisplayFromStr\")]\n            pub balance: u128,\n        }\n\n        /// The key in the KVDB, which determines for whom you are storing data.\n        #[serde_as]\n        #[derive(\n            Encode,\n            Decode,\n            Debug,\n            Serialize,\n            Deserialize,\n            Default,\n            PartialEq,\n            Eq,\n            Clone,\n            TypeInfo,\n        )]\n        pub struct SMTKey {\n            /// The on-chain user address.\n            pub address: String,\n        }\n\n    }\n\n}\n\n/// How the key in the KVDB is computed into a hash value.\nimpl Value for SMTKey {\n    fn zero() -\u003e Self {\n        SMTKey::default()\n    }\n\n    fn to_h256(\u0026self) -\u003e sparse_merkle_tree::H256 {\n        let mut k = Keccak256::new();\n        k.update(self.encode().as_slice());\n        let r: [u8; 32] = k.finalize().into();\n        r.into()\n    }\n}\n\n/// How the value in the KVDB is computed into a hash value.\nimpl Value for SMTValue {\n    fn zero() -\u003e Self {\n        Default::default()\n    }\n\n    fn to_h256(\u0026self) -\u003e sparse_merkle_tree::H256 {\n        if self == \u0026Default::default() {\n            return H256::zero();\n        }\n        let mut k = Keccak256::new();\n        k.update(self.encode().as_slice());\n        let r: [u8; 32] = k.finalize().into();\n        r.into()\n    }\n}\n\nimpl From\u003cSMTValue\u003e for Vec\u003cu8\u003e {\n    fn from(value: SMTValue) -\u003e Self {\n        value.encode()\n    }\n}\n\nimpl From\u003cVec\u003cu8\u003e\u003e for SMTValue {\n    fn from(value: Vec\u003cu8\u003e) -\u003e Self {\n        let a: SMTValue = Decode::decode::\u003c\u0026[u8]\u003e(\u0026mut value.as_slice()).unwrap_or_default();\n        a\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::SMTValue;\n    use sparse_merkle_tree::{traits::Value, H256};\n\n    #[test]\n    fn test_value() {\n        let v = SMTValue {\n            nonce: 1,\n            balance: 100000,\n        };\n        let v_vec: Vec\u003cu8\u003e = v.clone().into();\n        assert_eq!(v, v_vec.into());\n\n        let v1: SMTValue = Default::default();\n        assert_eq!(v1.to_h256(), H256::default());\n    }\n}\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":452}},{"line":140,"address":[],"length":0,"stats":{"Line":452}},{"line":141,"address":[],"length":0,"stats":{"Line":452}},{"line":142,"address":[],"length":0,"stats":{"Line":452}},{"line":143,"address":[],"length":0,"stats":{"Line":452}},{"line":149,"address":[],"length":0,"stats":{"Line":10}},{"line":150,"address":[],"length":0,"stats":{"Line":10}},{"line":153,"address":[],"length":0,"stats":{"Line":226}},{"line":154,"address":[],"length":0,"stats":{"Line":226}},{"line":155,"address":[],"length":0,"stats":{"Line":7}},{"line":157,"address":[],"length":0,"stats":{"Line":219}},{"line":158,"address":[],"length":0,"stats":{"Line":219}},{"line":159,"address":[],"length":0,"stats":{"Line":219}},{"line":160,"address":[],"length":0,"stats":{"Line":219}},{"line":165,"address":[],"length":0,"stats":{"Line":115}},{"line":166,"address":[],"length":0,"stats":{"Line":115}},{"line":171,"address":[],"length":0,"stats":{"Line":111}},{"line":172,"address":[],"length":0,"stats":{"Line":111}},{"line":173,"address":[],"length":0,"stats":{"Line":111}}],"covered":19,"coverable":28},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","primitives","src","lib.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\npub mod keccak_hasher;\npub mod kv;\npub mod verify;\npub use sparse_merkle_tree;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","primitives","src","verify.rs"],"content":"// This file is part of farcloud-labs/subsmt.\n\n// Copyright (C) Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Verify the Merkle proof.  \n//! This provides a more user-friendly method of verifying the Merkle proof, rather than just a sequence of `Vec\u003cu8\u003e` that cannot be directly parsed back into the original data.  \n//! It enables you to perform more actions on-chain.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n#![allow(dead_code)]\n#![allow(unused_imports)]\n#![allow(clippy::collapsible_else_if)]\n#![allow(clippy::legacy_numeric_constants)]\n#![allow(clippy::arithmetic_side_effects)]\n\nextern crate alloc;\nuse alloc::vec::Vec;\nuse codec::{Decode, Encode};\nuse scale_info::{prelude::fmt::Debug, TypeInfo};\nuse serde::{self, Deserialize, Serialize};\nuse sparse_merkle_tree::{\n    merge::{hash_base_node, merge, MergeValue},\n    traits::Hasher,\n    H256,\n};\n\ncfg_if::cfg_if! {\n    if #[cfg(feature=\"std\")] {\n        use utoipa::{ToSchema, IntoParams, __dev::ComposeSchema};\n\n        /// Merkle proof.\n        #[derive(Debug, Serialize, Deserialize, Clone, Encode, Decode, TypeInfo, PartialEq, ToSchema)]\n        pub struct Proof\u003cK: Debug + Clone + TypeInfo, V: Default + Debug + Clone + TypeInfo\u003e {\n            /// The key in the KVDB.\n            #[serde(flatten)]\n            pub key: K,\n            /// The value in the KVDB.\n            #[serde(flatten)]\n            pub value: V,\n            /// The Merkle leaf's path (i.e., the hash value of the key).\n            pub path: H256,\n            /// The hash value of the Merkle leaf (i.e., the hash value of the value).\n            pub value_hash: H256,\n            /// Merkle root hash.\n            pub root: H256,\n            /// Path marker, indicating where hashing should be performed.\n            pub leave_bitmap: H256,\n            /// Branches encountered on the leave_bitmap that need to be hashed. They correspond one-to-one with the leave_bitmap.\n            pub siblings: Vec\u003cMergeValue\u003e,\n        }\n\n    } else {\n         /// Merkle proof.\n        #[derive(Debug, Serialize, Deserialize, Clone, Encode, Decode, TypeInfo, PartialEq)]\n        pub struct Proof\u003cK: Debug + Clone + TypeInfo, V: Default + Debug + Clone + TypeInfo\u003e {\n            /// The key in the KVDB.\n            #[serde(flatten)]\n            pub key: K,\n            /// The value in the KVDB.\n            #[serde(flatten)]\n            pub value: V,\n            /// The Merkle leaf's path (i.e., the hash value of the key).\n            pub path: H256,\n            /// The hash value of the Merkle leaf (i.e., the hash value of the value).\n            pub value_hash: H256,\n            /// Merkle root hash.\n            pub root: H256,\n            /// Path marker, indicating where hashing should be performed.\n            pub leave_bitmap: H256,\n            /// Branches encountered on the leave_bitmap that need to be hashed. They correspond one-to-one with the leave_bitmap.\n            pub siblings: Vec\u003cMergeValue\u003e,\n        }\n    }\n\n}\n\n/// When there is only one value in the database (i.e., only one leaf, and the other leaves are empty), how to compute the root.\nfn single_leaf_verify\u003cH: Hasher + Default\u003e(key: H256, value: H256) -\u003e MergeValue {\n    if value.is_zero() {\n        MergeValue::from_h256(value)\n    } else {\n        let base_key = key.parent_path(0);\n        let base_node = hash_base_node::\u003cH\u003e(0, \u0026base_key, \u0026value);\n        let zero_bits = key;\n        MergeValue::MergeWithZero {\n            base_node,\n            zero_bits,\n            zero_count: 0,\n        }\n    }\n}\n\nfn into_merge_value\u003cH: Hasher + Default\u003e(key: H256, value: H256, height: u8) -\u003e MergeValue {\n    // try keep hash same with MergeWithZero\n    if value.is_zero() || height == 0 {\n        MergeValue::from_h256(value)\n    } else {\n        let base_key = key.parent_path(0);\n        let base_node = hash_base_node::\u003cH\u003e(0, \u0026base_key, \u0026value);\n        let mut zero_bits = key;\n        for i in height..=core::u8::MAX {\n            if key.get_bit(i) {\n                zero_bits.clear_bit(i);\n            }\n        }\n        MergeValue::MergeWithZero {\n            base_node,\n            zero_bits,\n            zero_count: height,\n        }\n    }\n}\n\n/// Verify the Merkle proof,  \n/// including the verification when there is only one leaf (which differs slightly from multi-leaf cases).\npub fn verify\u003cH: Hasher + Default\u003e(\n    path: H256,\n    value_hash: H256,\n    leave_bitmap: H256,\n    siblings: Vec\u003cMergeValue\u003e,\n    root: H256,\n) -\u003e bool {\n    if value_hash.is_zero() {\n        return false;\n    }\n    if siblings.is_empty() {\n        return single_leaf_verify::\u003cH\u003e(path, value_hash).hash::\u003cH\u003e() == root;\n    }\n\n    let mut current_path = path;\n    let mut n = 0;\n\n    let mut current_v = MergeValue::zero();\n\n    let mut left: MergeValue = MergeValue::zero();\n    let mut right: MergeValue = MergeValue::zero();\n\n    for i in 0..=u8::MAX {\n        let parent_path = current_path.parent_path(i);\n        if leave_bitmap.get_bit(i) {\n            if n == 0 {\n                current_v = into_merge_value::\u003cH\u003e(path, value_hash, i);\n            }\n            if current_path.is_right(i) {\n                left = siblings[n].clone();\n                right = current_v.clone();\n            } else {\n                left = current_v.clone();\n                right = siblings[n].clone();\n            }\n\n            n += 1;\n        } else {\n            if n \u003e 0 {\n                if current_path.is_right(i) {\n                    left = MergeValue::zero();\n                    right = current_v.clone();\n                } else {\n                    left = current_v.clone();\n                    right = MergeValue::zero();\n                }\n            }\n        }\n\n        current_v = merge::\u003cH\u003e(i, \u0026parent_path, \u0026left, \u0026right);\n\n        current_path = parent_path;\n    }\n    current_v.hash::\u003cH\u003e() == root\n}\n","traces":[{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":5}},{"line":92,"address":[],"length":0,"stats":{"Line":5}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":5}},{"line":96,"address":[],"length":0,"stats":{"Line":5}},{"line":97,"address":[],"length":0,"stats":{"Line":5}},{"line":106,"address":[],"length":0,"stats":{"Line":100}},{"line":108,"address":[],"length":0,"stats":{"Line":200}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":100}},{"line":112,"address":[],"length":0,"stats":{"Line":100}},{"line":113,"address":[],"length":0,"stats":{"Line":100}},{"line":114,"address":[],"length":0,"stats":{"Line":805}},{"line":115,"address":[],"length":0,"stats":{"Line":1205}},{"line":116,"address":[],"length":0,"stats":{"Line":400}},{"line":129,"address":[],"length":0,"stats":{"Line":107}},{"line":136,"address":[],"length":0,"stats":{"Line":107}},{"line":137,"address":[],"length":0,"stats":{"Line":2}},{"line":139,"address":[],"length":0,"stats":{"Line":105}},{"line":140,"address":[],"length":0,"stats":{"Line":5}},{"line":143,"address":[],"length":0,"stats":{"Line":100}},{"line":144,"address":[],"length":0,"stats":{"Line":100}},{"line":146,"address":[],"length":0,"stats":{"Line":100}},{"line":148,"address":[],"length":0,"stats":{"Line":100}},{"line":149,"address":[],"length":0,"stats":{"Line":100}},{"line":151,"address":[],"length":0,"stats":{"Line":51300}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":792}},{"line":155,"address":[],"length":0,"stats":{"Line":100}},{"line":157,"address":[],"length":0,"stats":{"Line":1028}},{"line":158,"address":[],"length":0,"stats":{"Line":336}},{"line":159,"address":[],"length":0,"stats":{"Line":336}},{"line":161,"address":[],"length":0,"stats":{"Line":356}},{"line":162,"address":[],"length":0,"stats":{"Line":356}},{"line":165,"address":[],"length":0,"stats":{"Line":692}},{"line":167,"address":[],"length":0,"stats":{"Line":24908}},{"line":168,"address":[],"length":0,"stats":{"Line":177}},{"line":169,"address":[],"length":0,"stats":{"Line":64}},{"line":170,"address":[],"length":0,"stats":{"Line":64}},{"line":172,"address":[],"length":0,"stats":{"Line":49}},{"line":173,"address":[],"length":0,"stats":{"Line":49}},{"line":178,"address":[],"length":0,"stats":{"Line":25600}},{"line":180,"address":[],"length":0,"stats":{"Line":25600}},{"line":182,"address":[],"length":0,"stats":{"Line":100}}],"covered":41,"coverable":46},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","benches","smt_benchmark.rs"],"content":"#[macro_use]\nextern crate criterion;\n\nuse criterion::Criterion;\nuse rand::{thread_rng, Rng};\nuse sparse_merkle_tree::{\n    blake2b::Blake2bHasher, default_store::DefaultStore, SparseMerkleTree, H256,\n};\n\nconst TARGET_LEAVES_COUNT: usize = 20;\n\n#[allow(clippy::upper_case_acronyms)]\ntype SMT = SparseMerkleTree\u003cBlake2bHasher, H256, DefaultStore\u003cH256\u003e\u003e;\n\nfn random_h256(rng: \u0026mut impl Rng) -\u003e H256 {\n    let mut buf = [0u8; 32];\n    rng.fill(\u0026mut buf);\n    buf.into()\n}\n\nfn random_smt(update_count: usize, rng: \u0026mut impl Rng) -\u003e (SMT, Vec\u003cH256\u003e) {\n    let mut smt = SparseMerkleTree::default();\n    let mut keys = Vec::with_capacity(update_count);\n    for _ in 0..update_count {\n        let key = random_h256(rng);\n        let value = random_h256(rng);\n        smt.update(key, value).unwrap();\n        keys.push(key);\n    }\n    (smt, keys)\n}\n\nfn random_smt_update_all(update_count: usize, rng: \u0026mut impl Rng) {\n    let mut smt = SMT::default();\n    let mut kvs = Vec::with_capacity(update_count);\n    for _ in 0..update_count {\n        let key = random_h256(rng);\n        let value = random_h256(rng);\n        kvs.push((key, value));\n    }\n    smt.update_all(kvs).unwrap();\n}\n\nfn bench(c: \u0026mut Criterion) {\n    c.bench_function_over_inputs(\n        \"SMT update\",\n        |b, \u0026\u0026size| {\n            b.iter(|| {\n                let mut rng = thread_rng();\n                random_smt(size, \u0026mut rng)\n            });\n        },\n        \u0026[100, 10_000],\n    );\n\n    c.bench_function_over_inputs(\n        \"SMT update_all\",\n        |b, \u0026\u0026size| {\n            b.iter(|| {\n                let mut rng = thread_rng();\n                random_smt_update_all(size, \u0026mut rng)\n            });\n        },\n        \u0026[100, 10_000],\n    );\n\n    c.bench_function_over_inputs(\n        \"SMT get\",\n        |b, \u0026\u0026size| {\n            let mut rng = thread_rng();\n            let (smt, _keys) = random_smt(size, \u0026mut rng);\n            b.iter(|| {\n                let key = random_h256(\u0026mut rng);\n                smt.get(\u0026key).unwrap();\n            });\n        },\n        \u0026[5_000, 10_000],\n    );\n\n    c.bench_function(\"SMT generate merkle proof\", |b| {\n        let mut rng = thread_rng();\n        let (smt, mut keys) = random_smt(10_000, \u0026mut rng);\n        keys.dedup();\n        let keys: Vec\u003c_\u003e = keys.into_iter().take(TARGET_LEAVES_COUNT).collect();\n        b.iter(|| {\n            smt.merkle_proof(keys.clone()).unwrap();\n        });\n    });\n\n    c.bench_function(\"SMT verify merkle proof\", |b| {\n        let mut rng = thread_rng();\n        let (smt, mut keys) = random_smt(10_000, \u0026mut rng);\n        keys.dedup();\n        let leaves: Vec\u003c_\u003e = keys\n            .iter()\n            .take(TARGET_LEAVES_COUNT)\n            .map(|k| (*k, smt.get(k).unwrap()))\n            .collect();\n        let proof = smt\n            .merkle_proof(keys.into_iter().take(TARGET_LEAVES_COUNT).collect())\n            .unwrap();\n        let root = smt.root();\n        b.iter(|| {\n            let valid = proof.clone().verify::\u003cBlake2bHasher\u003e(root, leaves.clone());\n            assert!(valid.expect(\"verify result\"));\n        });\n    });\n}\n\ncriterion_group!(\n    name = benches;\n    config = Criterion::default().sample_size(10);\n    targets = bench\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","benches","store_counter_benchmark.rs"],"content":"#[macro_use]\nextern crate criterion;\n\nuse std::sync::atomic::{AtomicUsize, Ordering};\n\nuse rand::{thread_rng, Rng};\nuse sparse_merkle_tree::{\n    blake2b::Blake2bHasher,\n    default_store::DefaultStore,\n    error::Error,\n    traits::{StoreReadOps, StoreWriteOps},\n    BranchKey, BranchNode, SparseMerkleTree, H256,\n};\n\n#[derive(Debug, Default)]\nstruct DefaultStoreWithCounters\u003cV\u003e {\n    store: DefaultStore\u003cV\u003e,\n    counters: Counters,\n}\n\n#[derive(Debug, Default)]\nstruct Counters {\n    get_branch_counter: AtomicUsize,\n    get_leaf_counter: AtomicUsize,\n    insert_branch_counter: AtomicUsize,\n    insert_leaf_counter: AtomicUsize,\n    remove_branch_counter: AtomicUsize,\n    remove_leaf_counter: AtomicUsize,\n}\n\nimpl\u003cV: Clone\u003e StoreReadOps\u003cV\u003e for DefaultStoreWithCounters\u003cV\u003e {\n    fn get_branch(\u0026self, branch_key: \u0026BranchKey) -\u003e Result\u003cOption\u003cBranchNode\u003e, Error\u003e {\n        self.counters\n            .get_branch_counter\n            .fetch_add(1, Ordering::SeqCst);\n        self.store.get_branch(branch_key)\n    }\n    fn get_leaf(\u0026self, leaf_key: \u0026H256) -\u003e Result\u003cOption\u003cV\u003e, Error\u003e {\n        self.counters\n            .get_leaf_counter\n            .fetch_add(1, Ordering::SeqCst);\n        self.store.get_leaf(leaf_key)\n    }\n}\n\nimpl\u003cV\u003e StoreWriteOps\u003cV\u003e for DefaultStoreWithCounters\u003cV\u003e {\n    fn insert_branch(\u0026mut self, branch_key: BranchKey, branch: BranchNode) -\u003e Result\u003c(), Error\u003e {\n        self.counters\n            .insert_branch_counter\n            .fetch_add(1, Ordering::SeqCst);\n        self.store.insert_branch(branch_key, branch)\n    }\n    fn insert_leaf(\u0026mut self, leaf_key: H256, leaf: V) -\u003e Result\u003c(), Error\u003e {\n        self.counters\n            .insert_leaf_counter\n            .fetch_add(1, Ordering::SeqCst);\n        self.store.insert_leaf(leaf_key, leaf)\n    }\n    fn remove_branch(\u0026mut self, branch_key: \u0026BranchKey) -\u003e Result\u003c(), Error\u003e {\n        self.counters\n            .remove_branch_counter\n            .fetch_add(1, Ordering::SeqCst);\n        self.store.remove_branch(branch_key)\n    }\n    fn remove_leaf(\u0026mut self, leaf_key: \u0026H256) -\u003e Result\u003c(), Error\u003e {\n        self.counters\n            .remove_leaf_counter\n            .fetch_add(1, Ordering::SeqCst);\n        self.store.remove_leaf(leaf_key)\n    }\n}\n\n#[allow(clippy::upper_case_acronyms)]\ntype SMT = SparseMerkleTree\u003cBlake2bHasher, H256, DefaultStoreWithCounters\u003cH256\u003e\u003e;\n\nfn random_h256(rng: \u0026mut impl Rng) -\u003e H256 {\n    let mut buf = [0u8; 32];\n    rng.fill(\u0026mut buf);\n    buf.into()\n}\n\nfn random_smt(update_count: usize, rng: \u0026mut impl Rng) {\n    let mut smt = SMT::default();\n    let mut keys = Vec::with_capacity(update_count);\n    for _ in 0..update_count {\n        let key = random_h256(rng);\n        let value = random_h256(rng);\n        smt.update(key, value).unwrap();\n        keys.push(key);\n    }\n    println!(\n        \"random update {} keys, store counters: {:?}\",\n        update_count,\n        smt.store().counters\n    );\n}\n\nfn random_smt_update_all(update_count: usize, rng: \u0026mut impl Rng) {\n    let mut smt = SMT::default();\n    let mut kvs = Vec::with_capacity(update_count);\n    for _ in 0..update_count {\n        let key = random_h256(rng);\n        let value = random_h256(rng);\n        kvs.push((key, value));\n    }\n    smt.update_all(kvs).unwrap();\n    println!(\n        \"random update_all {} keys, store counters: {:?}\",\n        update_count,\n        smt.store().counters\n    );\n}\n\nfn main() {\n    let mut rng = thread_rng();\n    random_smt(100, \u0026mut rng);\n    random_smt(10000, \u0026mut rng);\n    random_smt_update_all(100, \u0026mut rng);\n    random_smt_update_all(10000, \u0026mut rng);\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":30},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","build.rs"],"content":"fn main() {\n    #[cfg(feature = \"smtc\")]\n    {\n        println!(\"cargo:rerun-if-changed=c/ckb_smt.h\");\n\n        cc::Build::new()\n            .file(\"src/ckb_smt.c\")\n            .static_flag(true)\n            .flag(\"-O3\")\n            .flag(\"-fvisibility=hidden\")\n            .flag(\"-fdata-sections\")\n            .flag(\"-ffunction-sections\")\n            .include(\"src/\")\n            .include(\"c/\")\n            .include(\"c/deps/ckb-c-stdlib\")\n            .flag(\"-Wall\")\n            .flag(\"-Werror\")\n            .flag(\"-Wno-unused-parameter\")\n            .flag(\"-Wno-nonnull\")\n            .define(\"__SHARED_LIBRARY__\", None)\n            .define(\"CKB_STDLIB_NO_SYSCALL_IMPL\", None)\n            .compile(\"smt-c-impl\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","c","rust-tests","build.rs"],"content":"fn main() {\n    println!(\"cargo:rerun-if-changed=../ckb_smt.h\");\n\n    cc::Build::new()\n        .file(\"../../src/ckb_smt.c\")\n        .static_flag(true)\n        .flag(\"-O3\")\n        .flag(\"-fvisibility=hidden\")\n        .flag(\"-fdata-sections\")\n        .flag(\"-ffunction-sections\")\n        .include(\"../../src\")\n        .include(\"..\")\n        .include(\"../deps/ckb-c-stdlib\")\n        .flag(\"-Wall\")\n        .flag(\"-Werror\")\n        .flag(\"-Wno-unused-parameter\")\n        .flag(\"-Wno-nonnull\")\n        .define(\"__SHARED_LIBRARY__\", None)\n        .define(\"CKB_STDLIB_NO_SYSCALL_IMPL\", None)\n        .compile(\"dl-c-impl\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","c","rust-tests","src","lib.rs"],"content":"#[cfg(test)]\nmod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","c","rust-tests","src","tests","mod.rs"],"content":"mod smt;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","c","rust-tests","src","tests","smt.rs"],"content":"use anyhow::Result;\nuse anyhow::Result as AnyResult;\nuse blake2b_rs::{Blake2b, Blake2bBuilder};\nuse core::ffi::c_void;\nuse proptest::prelude::*;\nuse rand::prelude::Rng;\nuse serde::{Deserialize, Serialize};\nuse sparse_merkle_tree::traits::Hasher;\nuse sparse_merkle_tree::{default_store::DefaultStore, SparseMerkleTree, H256};\nuse std::collections::HashMap;\nuse std::fs;\n\n#[link(name = \"dl-c-impl\", kind = \"static\")]\nextern \"C\" {\n    fn smt_state_new(capacity: u32) -\u003e *mut c_void;\n    fn smt_state_len(state: *mut c_void) -\u003e u32;\n\n    fn smt_state_insert(state: *mut c_void, key: *const u8, value: *const u8) -\u003e isize;\n    fn smt_state_fetch(state: *mut c_void, key: *const u8, value: *mut u8) -\u003e isize;\n    fn smt_state_normalize(state: *mut c_void);\n    #[allow(dead_code)]\n    fn smt_calculate_root(\n        buffer: *mut u8,\n        state: *const c_void,\n        proof: *const u8,\n        proof_length: u32,\n    ) -\u003e isize;\n    fn smt_verify(\n        hash: *const u8,\n        state: *const c_void,\n        proof: *const u8,\n        proof_length: u32,\n    ) -\u003e isize;\n}\n\npub struct SmtCImpl {\n    state_ptr: *mut c_void,\n}\n\nfn ffi_smt_result\u003cT\u003e(value: T, code: isize) -\u003e Result\u003cT, isize\u003e {\n    if code == 0 {\n        Ok(value)\n    } else {\n        Err(code)\n    }\n}\n\nfn ffi_assert_slice_len(slice: \u0026[u8], expected_len: usize) -\u003e Result\u003c(), isize\u003e {\n    if slice.len() == expected_len {\n        Ok(())\n    } else {\n        Err(-999)\n    }\n}\n\nimpl SmtCImpl {\n    pub fn new(capacity: u32) -\u003e SmtCImpl {\n        let state_ptr = unsafe { smt_state_new(capacity) };\n        SmtCImpl { state_ptr }\n    }\n\n    pub fn len(\u0026self) -\u003e u32 {\n        unsafe { smt_state_len(self.state_ptr) }\n    }\n\n    pub fn insert(\u0026mut self, key: \u0026[u8], value: \u0026[u8]) -\u003e Result\u003c(), isize\u003e {\n        ffi_assert_slice_len(key, 32)?;\n        ffi_assert_slice_len(value, 32)?;\n        let code = unsafe { smt_state_insert(self.state_ptr, key.as_ptr(), value.as_ptr()) };\n        ffi_smt_result((), code)\n    }\n\n    pub fn fetch(\u0026self, key: \u0026[u8]) -\u003e Result\u003c[u8; 32], isize\u003e {\n        ffi_assert_slice_len(key, 32)?;\n        let mut value = [0u8; 32];\n        let code = unsafe { smt_state_fetch(self.state_ptr, key.as_ptr(), value.as_mut_ptr()) };\n        ffi_smt_result(value, code)\n    }\n\n    pub fn normalize(\u0026mut self) {\n        unsafe {\n            smt_state_normalize(self.state_ptr);\n        }\n    }\n\n    #[allow(dead_code)]\n    pub fn calculate_root(\u0026self, proof: \u0026[u8]) -\u003e Result\u003c[u8; 32], isize\u003e {\n        let mut hash = [0u8; 32];\n        let code = unsafe {\n            smt_calculate_root(\n                hash.as_mut_ptr(),\n                self.state_ptr,\n                proof.as_ptr(),\n                proof.len() as u32,\n            )\n        };\n        ffi_smt_result(hash, code)\n    }\n\n    pub fn verify(\u0026self, root: \u0026[u8], proof: \u0026[u8]) -\u003e Result\u003c(), isize\u003e {\n        ffi_assert_slice_len(root, 32)?;\n        let code = unsafe {\n            smt_verify(\n                root.as_ptr(),\n                self.state_ptr,\n                proof.as_ptr(),\n                proof.len() as u32,\n            )\n        };\n        ffi_smt_result((), code)\n    }\n}\n\npub type Leave = ([u8; 32], [u8; 32]);\n\n#[derive(Default, Serialize, Deserialize)]\npub struct Proof {\n    pub leaves: Vec\u003cLeave\u003e,\n    pub compiled_proof: Vec\u003cu8\u003e,\n    pub error: Option\u003cString\u003e,\n}\n\n#[derive(Default, Serialize, Deserialize)]\npub struct Case {\n    pub name: String,\n    pub leaves: Vec\u003cLeave\u003e,\n    pub root: [u8; 32],\n    pub proofs: Vec\u003cProof\u003e,\n}\n\npub struct CkbBlake2bHasher(Blake2b);\n\nimpl Default for CkbBlake2bHasher {\n    fn default() -\u003e Self {\n        // NOTE: here we not set the `personal` since ckb_smt.c linked blake2b implementation from blake2b-rs\n        let blake2b = Blake2bBuilder::new(32)\n            .personal(b\"ckb-default-hash\")\n            .build();\n        CkbBlake2bHasher(blake2b)\n    }\n}\n\nimpl Hasher for CkbBlake2bHasher {\n    fn write_byte(\u0026mut self, b: u8) {\n        self.0.update(\u0026[b][..]);\n    }\n    fn write_h256(\u0026mut self, h: \u0026H256) {\n        self.0.update(h.as_slice());\n    }\n    fn finish(self) -\u003e H256 {\n        let mut hash = [0u8; 32];\n        self.0.finalize(\u0026mut hash);\n        hash.into()\n    }\n}\n\npub type CkbSMT = SparseMerkleTree\u003cCkbBlake2bHasher, H256, DefaultStore\u003cH256\u003e\u003e;\n\npub fn new_ckb_smt(pairs: Vec\u003c(H256, H256)\u003e) -\u003e CkbSMT {\n    let mut smt = CkbSMT::default();\n    for (key, value) in pairs {\n        smt.update(key, value).unwrap();\n    }\n    smt\n}\n\nfn h256_by_u8(n: u8) -\u003e [u8; 32] {\n    let mut data = [0u8; 32];\n    data[31] = n;\n    data\n}\n\n#[test]\nfn test_normalize() {\n    // pushed key = 7, value = 1\n    // pushed key = 1, value = 1\n    // pushed key = 1, value = 2\n    // pushed key = 2, value = 1\n    // pushed key = 2, value = 2\n    // pushed key = 0, value = 1\n    // pushed key = 0, value = 2\n    // pushed key = 6, value = 1\n    let mut smt_state = SmtCImpl::new(256);\n    let data_set = [\n        (7, 1),\n        (1, 1),\n        (1, 2),\n        (2, 1),\n        (2, 2),\n        (0, 1),\n        (0, 2),\n        (6, 1),\n    ];\n    for (k, v) in \u0026data_set {\n        smt_state.insert(\u0026h256_by_u8(*k), \u0026h256_by_u8(*v)).unwrap();\n    }\n    assert_eq!(smt_state.len() as usize, data_set.len());\n    smt_state.normalize();\n    assert_eq!(smt_state.len(), 5);\n    for (k, v) in \u0026[(0, 2), (1, 2), (2, 2), (6, 1), (7, 1)] {\n        assert_eq!(smt_state.fetch(\u0026h256_by_u8(*k)).unwrap(), h256_by_u8(*v));\n    }\n}\n\n#[test]\nfn test_normalize_random() {\n    let mut rng = rand::thread_rng();\n    for pair_size in vec![1, 2, 100, 256, 512, 1024, 2048] {\n        for _ in 0..4 {\n            let mut final_map: HashMap\u003cu8, u8\u003e = HashMap::default();\n            let mut smt_state = SmtCImpl::new(pair_size);\n            let rand_pairs: Vec\u003c(u8, u8)\u003e =\n                (0..pair_size).map(|_| (rng.gen(), rng.gen())).collect();\n            for (key, value) in \u0026rand_pairs {\n                final_map.insert(*key, *value);\n                smt_state\n                    .insert(\u0026h256_by_u8(*key), \u0026h256_by_u8(*value))\n                    .unwrap();\n            }\n            assert_eq!(smt_state.len(), pair_size);\n            smt_state.normalize();\n            assert_eq!(smt_state.len() as usize, final_map.len());\n            for (key, value) in \u0026final_map {\n                let byte32_value = smt_state.fetch(\u0026h256_by_u8(*key)).unwrap();\n                assert_eq!(h256_by_u8(*value), byte32_value);\n            }\n        }\n    }\n}\n\nfn run_test_case(case: Case) -\u003e AnyResult\u003c()\u003e {\n    let Case { leaves, proofs, .. } = case;\n\n    let ckb_smt = new_ckb_smt(\n        leaves\n            .iter()\n            .map(|(k, v)| ((*k).into(), (*v).into()))\n            .collect(),\n    );\n\n    for proof in proofs {\n        let Proof { leaves, error, .. } = proof;\n        let keys: Vec\u003c_\u003e = leaves.iter().map(|(k, _v)| (*k).into()).collect();\n        let ckb_actual_proof = match ckb_smt.merkle_proof(keys) {\n            Ok(proof) =\u003e proof,\n            Err(err) =\u003e {\n                let expected_error = error.expect(\"expected error\");\n                assert_eq!(expected_error, format!(\"{}\", err));\n                return Ok(());\n            }\n        };\n        let ckb_actual_compiled_proof = ckb_actual_proof.clone().compile(\n            leaves\n                .iter()\n                .map(|(k, _v)| (*k).into())\n                .collect(),\n        )?;\n        let ckb_actual_compiled_proof_bin: Vec\u003cu8\u003e = ckb_actual_compiled_proof.clone().into();\n\n        let mut smt_state = SmtCImpl::new(leaves.len() as u32);\n        for (key, value) in \u0026leaves {\n            smt_state.insert(key, value).unwrap();\n        }\n        for (key, value) in \u0026leaves {\n            let fetched_value = smt_state.fetch(key).unwrap();\n            assert_eq!(value, \u0026fetched_value);\n        }\n        smt_state.normalize();\n        for (key, value) in \u0026leaves {\n            let fetched_value = smt_state.fetch(key).unwrap();\n            assert_eq!(value, \u0026fetched_value);\n        }\n\n        assert_eq!(smt_state.len(), leaves.len() as u32);\n        smt_state\n            .verify(ckb_smt.root().as_slice(), \u0026ckb_actual_compiled_proof_bin)\n            .unwrap();\n    }\n    Ok(())\n}\n\nfn hex2bin(src: String) -\u003e Vec\u003cu8\u003e {\n    hex::decode(src).unwrap_or(Vec::new())\n}\n\n#[test]\nfn test_smt_c_verify1() {\n    let key = hex2bin(\"381dc5391dab099da5e28acd1ad859a051cf18ace804d037f12819c6fbc0e18b\".to_owned());\n    let value = hex2bin(\"9158ce9b0e11dd150ba2ae5d55c1db04b1c5986ec626f2e38a93fe8ad0b2923b\".to_owned());\n    let root_hash = hex2bin(\"ebe0fab376cd802d364eeb44af20c67a74d6183a33928fead163120ef12e6e06\".to_owned());\n    let proof = hex2bin(\n        \"4c4fff51ff322de8a89fe589987f97220cfcb6820bd798b31a0b56ffea221093d35f909e580b00000000000000000000000000000000000000000000000000000000000000\".to_owned());\n\n    unsafe {\n        let changes = smt_state_new(32);\n        smt_state_insert(changes, key.as_ptr(), value.as_ptr());\n        smt_state_normalize(changes);\n\n        let verify_ref = smt_verify(root_hash.as_ptr(), changes, proof.as_ptr(), proof.len() as u32);\n        assert_eq!(0, verify_ref);\n    }\n}\n\n#[test]\nfn test_smt_c_verify2() {\n    let key = hex2bin(\"a9bb945be71f0bd2757d33d2465b6387383da42f321072e47472f0c9c7428a8a\".to_owned());\n    let value = hex2bin(\"a939a47335f777eac4c40fbc0970e25f832a24e1d55adc45a7b76d63fe364e82\".to_owned());\n    let root_hash = hex2bin(\"6e5c722644cd55cef8c4ed886cd8b44027ae9ed129e70a4b67d87be1c6857842\".to_owned());\n    let proof = hex2bin(\n        \"4c4fff51fa8aaa2aece17b92ec3f202a40a09f7286522bae1e5581a2a49195ab6781b1b8090000000000000000000000000000000000000000000000000000000000000000\".to_owned());\n\n    unsafe {\n        let changes = smt_state_new(32);\n        smt_state_insert(changes, key.as_ptr(), value.as_ptr());\n        smt_state_normalize(changes);\n\n        let verify_ref = smt_verify(root_hash.as_ptr(), changes, proof.as_ptr(), proof.len() as u32);\n        assert_eq!(0, verify_ref);\n    }\n}\n\n// FIXME: uncomment this later\n// pub const FIXTURES_DIR: \u0026str = \"../deps/sparse-merkle-tree/fixtures\";\n// #[test]\n// fn test_fixtures() {\n//     for i in 0..100 {\n//         let path = format!(\"{}/basic/case-{}.json\", FIXTURES_DIR, i);\n//         let content = fs::read(\u0026path).expect(\"read\");\n//         let case: Case = serde_json::from_slice(\u0026content).expect(\"parse json\");\n//         run_test_case(case).expect(\"test case c impl\");\n//         println!(\"pass {}\", i);\n//     }\n// }\n\nproptest! {\n    #[test]\n    fn test_random_merkle_proof(key: [u8; 32], value: [u8;32]) {\n        let key = H256::from(key);\n        let value = H256::from(value);\n        const EXPECTED_PROOF_SIZE: usize = 16;\n\n        let mut tree = CkbSMT::default();\n        tree.update(key, value).expect(\"update\");\n        if !tree.is_empty() {\n            let proof = tree.merkle_proof(vec![key]).expect(\"proof\");\n            let compiled_proof = proof\n                .clone()\n                .compile(vec![key])\n                .expect(\"compile proof\");\n            assert!(proof.merkle_path().len() \u003c EXPECTED_PROOF_SIZE);\n            assert!(proof\n                    .verify::\u003cCkbBlake2bHasher\u003e(tree.root(), vec![(key, value)])\n                    .expect(\"verify\"));\n            assert!(compiled_proof\n                    .verify::\u003cCkbBlake2bHasher\u003e(tree.root(), vec![(key, value)])\n                    .expect(\"compiled verify\"));\n\n            let compiled_proof_bin: Vec\u003cu8\u003e = compiled_proof.into();\n            let mut smt_state = SmtCImpl::new(8);\n            smt_state.insert(key.as_slice(), value.as_slice()).unwrap();\n            smt_state.normalize();\n            smt_state\n                .verify(tree.root().as_slice(), \u0026compiled_proof_bin)\n                .expect(\"verify with c\");\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","blake2b.rs"],"content":"// use crate::{traits::Hasher, H256};\n// use blake2b_rs::{Blake2b, Blake2bBuilder};\n//\n// const BLAKE2B_KEY: \u0026[u8] = \u0026[];\n// const BLAKE2B_LEN: usize = 32;\n// const PERSONALIZATION: \u0026[u8] = b\"sparsemerkletree\";\n//\n// pub struct Blake2bHasher(Blake2b);\n//\n// impl Default for Blake2bHasher {\n//     fn default() -\u003e Self {\n//         let blake2b = Blake2bBuilder::new(BLAKE2B_LEN)\n//             .personal(PERSONALIZATION)\n//             .key(BLAKE2B_KEY)\n//             .build();\n//         Blake2bHasher(blake2b)\n//     }\n// }\n//\n// impl Hasher for Blake2bHasher {\n//     fn write_h256(\u0026mut self, h: \u0026H256) {\n//         self.0.update(h.as_slice());\n//     }\n//     fn write_byte(\u0026mut self, b: u8) {\n//         self.0.update(\u0026[b][..]);\n//     }\n//     fn finish(self) -\u003e H256 {\n//         let mut hash = [0u8; 32];\n//         self.0.finalize(\u0026mut hash);\n//         hash.into()\n//     }\n// }\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","ckb_smt.rs"],"content":"use crate::H256;\nuse core::{ptr, result::Result};\n\nextern crate alloc;\nuse alloc::{boxed::Box, vec::Vec};\n\n#[repr(C)]\nstruct smt_pair_t {\n    key: [u8; 32],\n    value: [u8; 32],\n    order: u32,\n}\n\n#[repr(C)]\nstruct smt_state_t {\n    pairs: *mut smt_pair_t,\n    len: u32,\n    capacity: u32,\n}\n\n#[link(name = \"smt-c-impl\", kind = \"static\")]\nextern \"C\" {\n    fn smt_state_init(state: *mut smt_state_t, buffer: *const smt_pair_t, capacity: u32);\n\n    fn smt_state_insert(state: *mut smt_state_t, key: *const u8, value: *const u8) -\u003e i32;\n    fn smt_state_normalize(state: *mut smt_state_t);\n    fn smt_verify(\n        hash: *const u8,\n        state: *const smt_state_t,\n        proof: *const u8,\n        proof_length: u32,\n    ) -\u003e i32;\n}\n\n#[derive(Default)]\npub struct SMTBuilder {\n    data: Vec\u003c(H256, H256)\u003e,\n}\n\npub struct SMT {\n    state: Box\u003csmt_state_t\u003e,\n    _buffer: Vec\u003csmt_pair_t\u003e,\n}\n\nimpl SMTBuilder {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    pub fn insert(self, key: \u0026H256, value: \u0026H256) -\u003e Result\u003cSelf, i32\u003e {\n        let mut ret = self;\n        ret.data.push((*key, *value));\n        Ok(ret)\n    }\n\n    pub fn build(self) -\u003e Result\u003cSMT, i32\u003e {\n        let capacity = self.data.len();\n        let mut smt = SMT {\n            state: Box::new(smt_state_t {\n                pairs: ptr::null_mut(),\n                len: 0,\n                capacity: 0,\n            }),\n            _buffer: Vec::with_capacity(capacity as usize),\n        };\n        unsafe {\n            smt_state_init(smt.state.as_mut(), smt._buffer.as_ptr(), capacity as u32);\n\n            for (key, value) in self.data {\n                let ret = smt_state_insert(\n                    smt.state.as_mut(),\n                    key.as_slice().as_ptr(),\n                    value.as_slice().as_ptr(),\n                );\n                if ret != 0 {\n                    return Err(ret);\n                }\n            }\n\n            smt_state_normalize(smt.state.as_mut());\n        }\n        Ok(smt)\n    }\n}\n\nimpl SMT {\n    pub fn verify(\u0026self, root: \u0026H256, proof: \u0026[u8]) -\u003e Result\u003c(), i32\u003e {\n        unsafe {\n            let verify_ret = smt_verify(\n                root.as_slice().as_ptr(),\n                self.state.as_ref(),\n                proof.as_ptr(),\n                proof.len() as u32,\n            );\n            if 0 != verify_ret {\n                return Err(verify_ret);\n            }\n        }\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","default_store.rs"],"content":"use crate::{\n    collections,\n    error::Error,\n    traits::{StoreReadOps, StoreWriteOps},\n    tree::{BranchKey, BranchNode},\n    H256,\n};\n\n#[derive(Debug, Clone, Default)]\npub struct DefaultStore\u003cV\u003e {\n    branches_map: Map\u003cBranchKey, BranchNode\u003e,\n    leaves_map: Map\u003cH256, V\u003e,\n}\n\nimpl\u003cV\u003e DefaultStore\u003cV\u003e {\n    pub fn branches_map(\u0026self) -\u003e \u0026Map\u003cBranchKey, BranchNode\u003e {\n        \u0026self.branches_map\n    }\n    pub fn leaves_map(\u0026self) -\u003e \u0026Map\u003cH256, V\u003e {\n        \u0026self.leaves_map\n    }\n    pub fn clear(\u0026mut self) {\n        self.branches_map.clear();\n        self.leaves_map.clear();\n    }\n}\n\nimpl\u003cV: Clone\u003e StoreReadOps\u003cV\u003e for DefaultStore\u003cV\u003e {\n    fn get_branch(\u0026self, branch_key: \u0026BranchKey) -\u003e Result\u003cOption\u003cBranchNode\u003e, Error\u003e {\n        Ok(self.branches_map.get(branch_key).map(Clone::clone))\n    }\n    fn get_leaf(\u0026self, leaf_key: \u0026H256) -\u003e Result\u003cOption\u003cV\u003e, Error\u003e {\n        Ok(self.leaves_map.get(leaf_key).map(Clone::clone))\n    }\n}\n\nimpl\u003cV\u003e StoreWriteOps\u003cV\u003e for DefaultStore\u003cV\u003e {\n    fn insert_branch(\u0026mut self, branch_key: BranchKey, branch: BranchNode) -\u003e Result\u003c(), Error\u003e {\n        self.branches_map.insert(branch_key, branch);\n        Ok(())\n    }\n    fn insert_leaf(\u0026mut self, leaf_key: H256, leaf: V) -\u003e Result\u003c(), Error\u003e {\n        self.leaves_map.insert(leaf_key, leaf);\n        Ok(())\n    }\n    fn remove_branch(\u0026mut self, branch_key: \u0026BranchKey) -\u003e Result\u003c(), Error\u003e {\n        self.branches_map.remove(branch_key);\n        Ok(())\n    }\n    fn remove_leaf(\u0026mut self, leaf_key: \u0026H256) -\u003e Result\u003c(), Error\u003e {\n        self.leaves_map.remove(leaf_key);\n        Ok(())\n    }\n}\n\ncfg_if::cfg_if! {\n    if #[cfg(feature = \"std\")] {\n        pub type Map\u003cK, V\u003e = collections::HashMap\u003cK, V\u003e;\n        pub type Entry\u003c'a, K, V\u003e = collections::hash_map::Entry\u003c'a, K, V\u003e;\n    } else {\n        pub type Map\u003cK, V\u003e = collections::BTreeMap\u003cK, V\u003e;\n        pub type Entry\u003c'a, K, V\u003e = collections::btree_map::Entry\u003c'a, K, V\u003e;\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":23},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","error.rs"],"content":"use crate::{string, H256};\n\npub type Result\u003cT\u003e = ::core::result::Result\u003cT, Error\u003e;\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum Error {\n    MissingBranch(u8, H256),\n    MissingLeaf(H256),\n    CorruptedProof,\n    EmptyProof,\n    EmptyKeys,\n    IncorrectNumberOfLeaves { expected: usize, actual: usize },\n    Store(string::String),\n    CorruptedStack,\n    NonSiblings,\n    InvalidCode(u8),\n    NonMergableRange,\n}\n\nimpl core::fmt::Display for Error {\n    fn fmt(\u0026self, f: \u0026mut core::fmt::Formatter\u003c'_\u003e) -\u003e core::fmt::Result {\n        match self {\n            Error::MissingBranch(height, key) =\u003e {\n                write!(\n                    f,\n                    \"Corrupted store, missing branch height:{}, key:{:?}\",\n                    height, key\n                )?;\n            }\n            Error::MissingLeaf(key) =\u003e {\n                write!(f, \"Corrupted store, missing leaf {:?}\", key)?;\n            }\n            Error::CorruptedProof =\u003e {\n                write!(f, \"Corrupted proof\")?;\n            }\n            Error::EmptyProof =\u003e {\n                write!(f, \"Empty proof\")?;\n            }\n            Error::EmptyKeys =\u003e {\n                write!(f, \"Empty keys\")?;\n            }\n            Error::IncorrectNumberOfLeaves { expected, actual } =\u003e {\n                write!(\n                    f,\n                    \"Incorrect number of leaves, expected {} actual {}\",\n                    expected, actual\n                )?;\n            }\n            Error::Store(err_msg) =\u003e {\n                write!(f, \"Backend store error: {}\", err_msg)?;\n            }\n            Error::CorruptedStack =\u003e {\n                write!(f, \"Corrupted serialized proof stack\")?;\n            }\n            Error::NonSiblings =\u003e {\n                write!(f, \"Merging non-siblings in serialized stack\")?;\n            }\n            Error::InvalidCode(code) =\u003e {\n                write!(f, \"Invalid serialized proof code: {}\", code)?;\n            }\n            Error::NonMergableRange =\u003e {\n                write!(f, \"Ranges can not be merged\")?;\n            }\n        }\n        Ok(())\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl std::error::Error for Error {}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":23},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","h256.rs"],"content":"use crate::vec::Vec;\nuse codec::{Decode, Encode};\nuse core::cmp::Ordering;\nuse scale_info::TypeInfo;\nuse serde::{Deserialize, Serialize};\nuse serde_with::serde_as;\n\ncfg_if::cfg_if! {\n    if #[cfg(feature=\"std\")] {\n        use utoipa::ToSchema;\n        #[serde_as]\n        #[derive(\n            Eq, PartialEq, Debug, Default, Hash, Clone, Copy, Decode, Encode, Deserialize, Serialize,\n            ToSchema, TypeInfo\n        )]\n        pub struct H256(#[serde_as(as = \"serde_with::hex::Hex\")] [u8; 32]);\n    }  else {\n        #[serde_as]\n        #[derive(\n            Eq, PartialEq, Debug, Default, Hash, Clone, Copy, Decode, Encode, Deserialize, Serialize, TypeInfo,\n        )]\n        pub struct H256(#[serde_as(as = \"serde_with::hex::Hex\")] [u8; 32]);\n\n    }\n}\n\nimpl From\u003cVec\u003cu8\u003e\u003e for H256 {\n    fn from(value: Vec\u003cu8\u003e) -\u003e Self {\n        let mut array = [0u8; 32];\n        let len = value.len().min(32);\n        array[..len].copy_from_slice(\u0026value[..len]);\n        H256(array)\n    }\n}\n\nimpl AsRef\u003c[u8]\u003e for H256 {\n    fn as_ref(\u0026self) -\u003e \u0026[u8] {\n        \u0026self.0\n    }\n}\n\nconst ZERO: H256 = H256([0u8; 32]);\nconst BYTE_SIZE: u8 = 8;\n\nimpl H256 {\n    pub const fn zero() -\u003e Self {\n        ZERO\n    }\n\n    pub fn is_zero(\u0026self) -\u003e bool {\n        self == \u0026ZERO\n    }\n\n    #[inline]\n    pub fn get_bit(\u0026self, i: u8) -\u003e bool {\n        let byte_pos = i / BYTE_SIZE;\n        let bit_pos = i % BYTE_SIZE;\n        let bit = self.0[byte_pos as usize] \u003e\u003e (7 - bit_pos) \u0026 1;\n        bit != 0\n    }\n\n    #[inline]\n    pub fn set_bit(\u0026mut self, i: u8) {\n        let byte_pos = i / BYTE_SIZE;\n        let bit_pos = i % BYTE_SIZE;\n        self.0[byte_pos as usize] |= 1 \u003c\u003c (7 - bit_pos) as u8;\n    }\n\n    #[inline]\n\n    pub fn clear_bit(\u0026mut self, i: u8) {\n        let byte_pos = i / BYTE_SIZE;\n        let bit_pos = i % BYTE_SIZE;\n        self.0[byte_pos as usize] \u0026= !((1 \u003c\u003c (7 - bit_pos)) as u8);\n    }\n\n    #[inline]\n    pub fn is_right(\u0026self, height: u8) -\u003e bool {\n        self.get_bit(height)\n    }\n\n    pub fn as_slice(\u0026self) -\u003e \u0026[u8] {\n        \u0026self.0[..]\n    }\n\n    /// Treat H256 as a path in a tree\n    /// fork height is the number of common bits(from heigher to lower: 255..=0) of two H256\n    pub fn fork_height(\u0026self, key: \u0026H256) -\u003e u8 {\n        for h in (0..=core::u8::MAX).rev() {\n            if self.get_bit(h) != key.get_bit(h) {\n                return h;\n            }\n        }\n        0\n    }\n\n    /// Treat H256 as a path in a tree\n    /// return parent_path of self\n    pub fn parent_path(\u0026self, height: u8) -\u003e Self {\n        if height == core::u8::MAX {\n            H256::zero()\n        } else {\n            self.copy_bits(height + 1)\n        }\n    }\n\n    /// Copy bits and return a new H256\n    pub fn copy_bits(\u0026self, start: u8) -\u003e Self {\n        let mut target = H256::zero();\n\n        let start_byte = (start / BYTE_SIZE) as usize;\n        // copy bytes\n        target.0[start_byte..].copy_from_slice(\u0026self.0[start_byte..]);\n\n        // reset remain bytes\n        let remain = start % BYTE_SIZE;\n        if remain \u003e 0 {\n            target.0[start_byte] \u0026= 0b11111111 \u003e\u003e remain\n        }\n\n        target\n    }\n}\n\nimpl PartialOrd for H256 {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for H256 {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n        // Compare bits from heigher to lower (255..0)\n        self.0.iter().rev().cmp(other.0.iter().rev())\n    }\n}\n\nimpl From\u003c[u8; 32]\u003e for H256 {\n    fn from(v: [u8; 32]) -\u003e H256 {\n        H256(v)\n    }\n}\n\nimpl From\u003cH256\u003e for [u8; 32] {\n    fn from(h256: H256) -\u003e [u8; 32] {\n        h256.0\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":3}},{"line":29,"address":[],"length":0,"stats":{"Line":3}},{"line":30,"address":[],"length":0,"stats":{"Line":3}},{"line":31,"address":[],"length":0,"stats":{"Line":3}},{"line":32,"address":[],"length":0,"stats":{"Line":3}},{"line":37,"address":[],"length":0,"stats":{"Line":6849}},{"line":38,"address":[],"length":0,"stats":{"Line":6849}},{"line":46,"address":[],"length":0,"stats":{"Line":167781}},{"line":47,"address":[],"length":0,"stats":{"Line":167781}},{"line":50,"address":[],"length":0,"stats":{"Line":143126}},{"line":51,"address":[],"length":0,"stats":{"Line":143126}},{"line":55,"address":[],"length":0,"stats":{"Line":141398}},{"line":56,"address":[],"length":0,"stats":{"Line":141398}},{"line":57,"address":[],"length":0,"stats":{"Line":141398}},{"line":58,"address":[],"length":0,"stats":{"Line":141398}},{"line":59,"address":[],"length":0,"stats":{"Line":141398}},{"line":63,"address":[],"length":0,"stats":{"Line":15163}},{"line":64,"address":[],"length":0,"stats":{"Line":15163}},{"line":65,"address":[],"length":0,"stats":{"Line":15163}},{"line":66,"address":[],"length":0,"stats":{"Line":15163}},{"line":71,"address":[],"length":0,"stats":{"Line":400}},{"line":72,"address":[],"length":0,"stats":{"Line":400}},{"line":73,"address":[],"length":0,"stats":{"Line":400}},{"line":74,"address":[],"length":0,"stats":{"Line":400}},{"line":78,"address":[],"length":0,"stats":{"Line":86065}},{"line":79,"address":[],"length":0,"stats":{"Line":86065}},{"line":82,"address":[],"length":0,"stats":{"Line":115}},{"line":83,"address":[],"length":0,"stats":{"Line":115}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":111721}},{"line":100,"address":[],"length":0,"stats":{"Line":111721}},{"line":101,"address":[],"length":0,"stats":{"Line":436}},{"line":103,"address":[],"length":0,"stats":{"Line":111285}},{"line":108,"address":[],"length":0,"stats":{"Line":111285}},{"line":109,"address":[],"length":0,"stats":{"Line":111285}},{"line":111,"address":[],"length":0,"stats":{"Line":111285}},{"line":113,"address":[],"length":0,"stats":{"Line":111285}},{"line":116,"address":[],"length":0,"stats":{"Line":111285}},{"line":117,"address":[],"length":0,"stats":{"Line":111285}},{"line":118,"address":[],"length":0,"stats":{"Line":97769}},{"line":121,"address":[],"length":0,"stats":{"Line":111285}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":3340}},{"line":140,"address":[],"length":0,"stats":{"Line":3340}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}}],"covered":42,"coverable":55},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","lib.rs"],"content":"//! Constructs a new `SparseMerkleTree\u003cH, V, S\u003e`.\n//!\n//! # Examples\n//!\n//! ```\n//! use sparse_merkle_tree::{\n//!     blake2b::Blake2bHasher, default_store::DefaultStore,\n//!     error::Error, MerkleProof,\n//!     SparseMerkleTree, traits::Value, H256\n//! };\n//! use blake2b_rs::{Blake2b, Blake2bBuilder};\n//!\n//! // define SMT\n//! type SMT = SparseMerkleTree\u003cBlake2bHasher, Word, DefaultStore\u003cWord\u003e\u003e;\n//!\n//! // define SMT value\n//! #[derive(Default, Clone)]\n//! pub struct Word(String);\n//! impl Value for Word {\n//!    fn to_h256(\u0026self) -\u003e H256 {\n//!        if self.0.is_empty() {\n//!            return H256::zero();\n//!        }\n//!        let mut buf = [0u8; 32];\n//!        let mut hasher = new_blake2b();\n//!        hasher.update(self.0.as_bytes());\n//!        hasher.finalize(\u0026mut buf);\n//!        buf.into()\n//!    }\n//!    fn zero() -\u003e Self {\n//!        Default::default()\n//!    }\n//! }\n//!\n//! // helper function\n//! fn new_blake2b() -\u003e Blake2b {\n//!     Blake2bBuilder::new(32).personal(b\"SMT\").build()\n//! }\n//!\n//! fn construct_smt() {\n//!     let mut tree = SMT::default();\n//!     for (i, word) in \"The quick brown fox jumps over the lazy dog\"\n//!         .split_whitespace()\n//!         .enumerate()\n//!     {\n//!         let key: H256 = {\n//!             let mut buf = [0u8; 32];\n//!             let mut hasher = new_blake2b();\n//!             hasher.update(\u0026(i as u32).to_le_bytes());\n//!             hasher.finalize(\u0026mut buf);\n//!             buf.into()\n//!         };\n//!         let value = Word(word.to_string());\n//!         // insert key value into tree\n//!         tree.update(key, value).expect(\"update\");\n//!     }\n//!\n//!     println!(\"SMT root is {:?} \", tree.root());\n//! }\n//! ```\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\npub mod blake2b;\n#[cfg(feature = \"smtc\")]\npub mod ckb_smt;\npub mod default_store;\npub mod error;\npub mod h256;\npub mod merge;\npub mod merkle_proof;\n#[cfg(test)]\nmod tests;\npub mod traits;\nmod tree;\n#[cfg(feature = \"trie\")]\nmod trie_tree;\n\n#[cfg(feature = \"smtc\")]\npub use ckb_smt::{SMTBuilder, SMT};\npub use h256::H256;\npub use merkle_proof::{CompiledMerkleProof, MerkleProof};\n#[cfg(not(feature = \"trie\"))]\npub use tree::SparseMerkleTree;\npub use tree::{BranchKey, BranchNode};\n#[cfg(feature = \"trie\")]\npub use trie_tree::SparseMerkleTree;\n\n/// Expected path size: log2(256) * 2, used for hint vector capacity\npub const EXPECTED_PATH_SIZE: usize = 16;\n// Max stack size can be used when verify compiled proof\npub(crate) const MAX_STACK_SIZE: usize = 257;\n\ncfg_if::cfg_if! {\n    if #[cfg(feature = \"std\")] {\n        use std::collections;\n        use std::vec;\n        use std::string;\n    } else {\n        extern crate alloc;\n        use alloc::collections;\n        use alloc::vec;\n        use alloc::string;\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","merge.rs"],"content":"#![cfg_attr(not(feature = \"std\"), no_std)]\n#![allow(unused_imports)]\nuse crate::{h256::H256, traits::Hasher};\nuse codec::{Decode, Encode};\nuse serde::{Deserialize, Serialize};\nuse serde_with::{hex::Hex, serde_as, DisplayFromStr};\n// use tiny_keccak::{Hasher as OtherHasher, Keccak};\nconst MERGE_NORMAL: u8 = 1;\nconst MERGE_ZEROS: u8 = 2;\nuse scale_info::TypeInfo;\n\ncfg_if::cfg_if! {\n    if #[cfg(feature=\"std\")] {\n        use utoipa::{ToSchema};\n        #[serde_as]\n        #[derive(Debug, Eq, PartialEq, Clone, Decode, Encode, Deserialize, Serialize, ToSchema, TypeInfo)]\n        pub enum MergeValue {\n            Value(#[serde_as(as = \"Hex\")] H256),\n            MergeWithZero {\n                #[serde_as(as = \"Hex\")]\n                base_node: H256,\n                #[serde_as(as = \"Hex\")]\n                zero_bits: H256,\n                // #[serde_as(as = \"DisplayFromStr\")]\n                zero_count: u8,\n            },\n            #[cfg(feature = \"trie\")]\n            ShortCut {\n                #[serde_as(as = \"Hex\")]\n                key: H256,\n                #[serde_as(as = \"Hex\")]\n                value: H256,\n                // #[serde_as(as = \"DisplayFromStr\")]\n                height: u8,\n            },\n}\n    }\n    else {\n        #[serde_as]\n        #[derive(Debug, Eq, PartialEq, Clone, Decode, Encode, Deserialize, Serialize, TypeInfo)]\n        pub enum MergeValue {\n            Value(#[serde_as(as = \"Hex\")] H256),\n            MergeWithZero {\n                #[serde_as(as = \"Hex\")]\n                base_node: H256,\n                #[serde_as(as = \"Hex\")]\n                zero_bits: H256,\n                // #[serde_as(as = \"DisplayFromStr\")]\n                zero_count: u8,\n            },\n            #[cfg(feature = \"trie\")]\n            ShortCut {\n                #[serde_as(as = \"Hex\")]\n                key: H256,\n                #[serde_as(as = \"Hex\")]\n                value: H256,\n                // #[serde_as(as = \"DisplayFromStr\")]\n                height: u8,\n    },\n}\n\n    }\n}\n\nimpl MergeValue {\n    pub fn from_h256(v: H256) -\u003e Self {\n        MergeValue::Value(v)\n    }\n\n    pub fn zero() -\u003e Self {\n        MergeValue::Value(H256::zero())\n    }\n\n    pub fn is_zero(\u0026self) -\u003e bool {\n        match self {\n            MergeValue::Value(v) =\u003e v.is_zero(),\n            MergeValue::MergeWithZero { .. } =\u003e false,\n            #[cfg(feature = \"trie\")]\n            MergeValue::ShortCut { .. } =\u003e false,\n        }\n    }\n\n    #[cfg(feature = \"trie\")]\n    pub fn shortcut_or_value(key: H256, value: H256, height: u8) -\u003e Self {\n        if height == 0 || value.is_zero() {\n            MergeValue::Value(value)\n        } else {\n            MergeValue::ShortCut { key, value, height }\n        }\n    }\n\n    #[cfg(feature = \"trie\")]\n    pub fn is_shortcut(\u0026self) -\u003e bool {\n        matches!(self, MergeValue::ShortCut { .. })\n    }\n\n    pub fn hash\u003cH: Hasher + Default\u003e(\u0026self) -\u003e H256 {\n        match self {\n            MergeValue::Value(v) =\u003e *v,\n            MergeValue::MergeWithZero {\n                base_node,\n                zero_bits,\n                zero_count,\n            } =\u003e {\n                let mut hasher = H::default();\n                hasher.write_byte(MERGE_ZEROS);\n                hasher.write_h256(base_node);\n                hasher.write_h256(zero_bits);\n                hasher.write_byte(*zero_count);\n                hasher.finish()\n            }\n            #[cfg(feature = \"trie\")]\n            MergeValue::ShortCut { key, value, height } =\u003e {\n                into_merge_value::\u003cH\u003e(*key, *value, *height).hash::\u003cH\u003e()\n            }\n        }\n    }\n}\n\npub fn into_merge_value1\u003cH: Hasher + Default\u003e(key: H256, value: H256, height: u8) -\u003e MergeValue {\n    // try keep hash same with MergeWithZero\n    if value.is_zero() || height == 0 {\n        MergeValue::from_h256(value)\n    } else {\n        let base_key = key.parent_path(0);\n        let base_node = hash_base_node::\u003cH\u003e(0, \u0026base_key, \u0026value);\n        let mut zero_bits = key;\n        for i in height..=core::u8::MAX {\n            if key.get_bit(i) {\n                zero_bits.clear_bit(i);\n            }\n        }\n        MergeValue::MergeWithZero {\n            base_node,\n            zero_bits,\n            zero_count: height,\n        }\n    }\n}\n\n/// Helper function for Shortcut node\n/// Transform it into a MergeValue or MergeWithZero node\n#[cfg(feature = \"trie\")]\npub fn into_merge_value\u003cH: Hasher + Default\u003e(key: H256, value: H256, height: u8) -\u003e MergeValue {\n    // try keep hash same with MergeWithZero\n    if value.is_zero() || height == 0 {\n        MergeValue::from_h256(value)\n    } else {\n        let base_key = key.parent_path(0);\n        let base_node = hash_base_node::\u003cH\u003e(0, \u0026base_key, \u0026value);\n        let mut zero_bits = key;\n        for i in height..=core::u8::MAX {\n            if key.get_bit(i) {\n                zero_bits.clear_bit(i);\n            }\n        }\n        MergeValue::MergeWithZero {\n            base_node,\n            zero_bits,\n            zero_count: height,\n        }\n    }\n}\n\n/// Hash base node into a H256\npub fn hash_base_node\u003cH: Hasher + Default\u003e(\n    base_height: u8,\n    base_key: \u0026H256,\n    base_value: \u0026H256,\n) -\u003e H256 {\n    let mut hasher = H::default();\n    // use tiny_keccak::Hasher;\n\n    hasher.write_byte(base_height);\n    hasher.write_h256(base_key);\n    hasher.write_h256(base_value);\n    hasher.finish()\n}\n\n/// Merge two hash with node information\n/// this function optimized for ZERO_HASH\n/// if lhs and rhs both are ZERO_HASH return ZERO_HASH, otherwise hash all info.\npub fn merge\u003cH: Hasher + Default\u003e(\n    height: u8,\n    node_key: \u0026H256,\n    lhs: \u0026MergeValue,\n    rhs: \u0026MergeValue,\n) -\u003e MergeValue {\n    if lhs.is_zero() \u0026\u0026 rhs.is_zero() {\n        return MergeValue::zero();\n    }\n    if lhs.is_zero() {\n        let res = merge_with_zero::\u003cH\u003e(height, node_key, rhs, true);\n        return res;\n    }\n    if rhs.is_zero() {\n        let res = merge_with_zero::\u003cH\u003e(height, node_key, lhs, false);\n        return res;\n    }\n\n    let mut hasher = H::default();\n    hasher.write_byte(MERGE_NORMAL);\n    hasher.write_byte(height);\n    hasher.write_h256(node_key);\n    hasher.write_h256(\u0026lhs.hash::\u003cH\u003e());\n    hasher.write_h256(\u0026rhs.hash::\u003cH\u003e());\n    MergeValue::Value(hasher.finish())\n}\n\npub fn merge_with_zero\u003cH: Hasher + Default\u003e(\n    height: u8,\n    node_key: \u0026H256,\n    value: \u0026MergeValue,\n    set_bit: bool,\n) -\u003e MergeValue {\n    match value {\n        MergeValue::Value(v) =\u003e {\n            let mut zero_bits = H256::zero();\n            if set_bit {\n                zero_bits.set_bit(height);\n            }\n            let base_node = hash_base_node::\u003cH\u003e(height, node_key, v);\n            MergeValue::MergeWithZero {\n                base_node,\n                zero_bits,\n                zero_count: 1,\n            }\n        }\n        MergeValue::MergeWithZero {\n            base_node,\n            zero_bits,\n            zero_count,\n        } =\u003e {\n            let mut zero_bits = *zero_bits;\n            if set_bit {\n                zero_bits.set_bit(height);\n            }\n            MergeValue::MergeWithZero {\n                base_node: *base_node,\n                zero_bits,\n                zero_count: zero_count.wrapping_add(1),\n            }\n        }\n        #[cfg(feature = \"trie\")]\n        MergeValue::ShortCut { key, value, .. } =\u003e {\n            if height == core::u8::MAX {\n                let base_key = key.parent_path(0);\n                let base_node = hash_base_node::\u003cH\u003e(0, \u0026base_key, value);\n                MergeValue::MergeWithZero {\n                    base_node,\n                    zero_bits: *key,\n                    zero_count: 0,\n                }\n            } else {\n                MergeValue::ShortCut {\n                    key: *key,\n                    value: *value,\n                    height: height + 1,\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":61504}},{"line":19,"address":[],"length":0,"stats":{"Line":55916}},{"line":66,"address":[],"length":0,"stats":{"Line":122}},{"line":67,"address":[],"length":0,"stats":{"Line":122}},{"line":70,"address":[],"length":0,"stats":{"Line":55008}},{"line":71,"address":[],"length":0,"stats":{"Line":55008}},{"line":74,"address":[],"length":0,"stats":{"Line":215130}},{"line":75,"address":[],"length":0,"stats":{"Line":215130}},{"line":76,"address":[],"length":0,"stats":{"Line":142796}},{"line":77,"address":[],"length":0,"stats":{"Line":72334}},{"line":97,"address":[],"length":0,"stats":{"Line":3630}},{"line":98,"address":[],"length":0,"stats":{"Line":3630}},{"line":99,"address":[],"length":0,"stats":{"Line":2856}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":774}},{"line":102,"address":[],"length":0,"stats":{"Line":774}},{"line":103,"address":[],"length":0,"stats":{"Line":774}},{"line":104,"address":[],"length":0,"stats":{"Line":774}},{"line":105,"address":[],"length":0,"stats":{"Line":774}},{"line":106,"address":[],"length":0,"stats":{"Line":774}},{"line":107,"address":[],"length":0,"stats":{"Line":774}},{"line":108,"address":[],"length":0,"stats":{"Line":774}},{"line":109,"address":[],"length":0,"stats":{"Line":774}},{"line":110,"address":[],"length":0,"stats":{"Line":774}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":340}},{"line":171,"address":[],"length":0,"stats":{"Line":340}},{"line":174,"address":[],"length":0,"stats":{"Line":340}},{"line":175,"address":[],"length":0,"stats":{"Line":340}},{"line":176,"address":[],"length":0,"stats":{"Line":340}},{"line":177,"address":[],"length":0,"stats":{"Line":340}},{"line":183,"address":[],"length":0,"stats":{"Line":56137}},{"line":189,"address":[],"length":0,"stats":{"Line":96417}},{"line":190,"address":[],"length":0,"stats":{"Line":25819}},{"line":192,"address":[],"length":0,"stats":{"Line":30318}},{"line":193,"address":[],"length":0,"stats":{"Line":14461}},{"line":194,"address":[],"length":0,"stats":{"Line":14461}},{"line":196,"address":[],"length":0,"stats":{"Line":15857}},{"line":197,"address":[],"length":0,"stats":{"Line":14318}},{"line":198,"address":[],"length":0,"stats":{"Line":14318}},{"line":201,"address":[],"length":0,"stats":{"Line":1539}},{"line":202,"address":[],"length":0,"stats":{"Line":1539}},{"line":203,"address":[],"length":0,"stats":{"Line":1539}},{"line":204,"address":[],"length":0,"stats":{"Line":1539}},{"line":205,"address":[],"length":0,"stats":{"Line":1539}},{"line":206,"address":[],"length":0,"stats":{"Line":1539}},{"line":207,"address":[],"length":0,"stats":{"Line":1539}},{"line":210,"address":[],"length":0,"stats":{"Line":28779}},{"line":216,"address":[],"length":0,"stats":{"Line":28779}},{"line":217,"address":[],"length":0,"stats":{"Line":235}},{"line":218,"address":[],"length":0,"stats":{"Line":235}},{"line":219,"address":[],"length":0,"stats":{"Line":348}},{"line":220,"address":[],"length":0,"stats":{"Line":113}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":28544}},{"line":231,"address":[],"length":0,"stats":{"Line":28544}},{"line":232,"address":[],"length":0,"stats":{"Line":28544}},{"line":233,"address":[],"length":0,"stats":{"Line":28544}},{"line":234,"address":[],"length":0,"stats":{"Line":28544}},{"line":235,"address":[],"length":0,"stats":{"Line":42892}},{"line":236,"address":[],"length":0,"stats":{"Line":14348}},{"line":239,"address":[],"length":0,"stats":{"Line":28544}},{"line":241,"address":[],"length":0,"stats":{"Line":28544}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}}],"covered":60,"coverable":92},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","merkle_proof.rs"],"content":"use crate::{\n    error::{Error, Result},\n    merge::{merge, MergeValue},\n    traits::Hasher,\n    vec::Vec,\n    H256, MAX_STACK_SIZE,\n};\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct MerkleProof {\n    // leaf bitmap, bitmap.get_bit(height) is true means there need a non zero sibling in this height\n    leaves_bitmap: Vec\u003cH256\u003e,\n    // needed sibling node hash\n    merkle_path: Vec\u003cMergeValue\u003e,\n}\n\nimpl MerkleProof {\n    /// Create MerkleProof\n    /// leaves_bitmap: leaf bitmap, bitmap.get_bit(height) is true means there need a non zero sibling in this height\n    /// proof: needed sibling node hash\n    pub fn new(leaves_bitmap: Vec\u003cH256\u003e, merkle_path: Vec\u003cMergeValue\u003e) -\u003e Self {\n        MerkleProof {\n            leaves_bitmap,\n            merkle_path,\n        }\n    }\n\n    /// Destruct the structure, useful for serialization\n    pub fn take(self) -\u003e (Vec\u003cH256\u003e, Vec\u003cMergeValue\u003e) {\n        let MerkleProof {\n            leaves_bitmap,\n            merkle_path,\n        } = self;\n        (leaves_bitmap, merkle_path)\n    }\n\n    /// number of leaves required by this merkle proof\n    pub fn leaves_count(\u0026self) -\u003e usize {\n        self.leaves_bitmap.len()\n    }\n\n    /// return the inner leaves_bitmap vector\n    pub fn leaves_bitmap(\u0026self) -\u003e \u0026Vec\u003cH256\u003e {\n        \u0026self.leaves_bitmap\n    }\n\n    /// return sibling node hashes\n    pub fn merkle_path(\u0026self) -\u003e \u0026Vec\u003cMergeValue\u003e {\n        \u0026self.merkle_path\n    }\n\n    pub fn compile(self, mut leaves_keys: Vec\u003cH256\u003e) -\u003e Result\u003cCompiledMerkleProof\u003e {\n        if leaves_keys.is_empty() {\n            return Err(Error::EmptyKeys);\n        } else if leaves_keys.len() != self.leaves_count() {\n            return Err(Error::IncorrectNumberOfLeaves {\n                expected: self.leaves_count(),\n                actual: leaves_keys.len(),\n            });\n        }\n        // sort leaves keys\n        leaves_keys.sort_unstable();\n\n        let (leaves_bitmap, merkle_path) = self.take();\n\n        let mut proof: Vec\u003cu8\u003e = Vec::with_capacity(merkle_path.len() * 33 + leaves_keys.len());\n        let mut stack_fork_height = [0u8; MAX_STACK_SIZE]; // store fork height\n        let mut stack_top = 0;\n        let mut leaf_index = 0;\n        let mut merkle_path_index = 0;\n        while leaf_index \u003c leaves_keys.len() {\n            let leaf_key = leaves_keys[leaf_index];\n            let fork_height = if leaf_index + 1 \u003c leaves_keys.len() {\n                leaf_key.fork_height(\u0026leaves_keys[leaf_index + 1])\n            } else {\n                core::u8::MAX\n            };\n            proof.push(0x4C);\n            let mut zero_count = 0u16;\n            for height in 0..=fork_height {\n                if height == fork_height \u0026\u0026 leaf_index + 1 \u003c leaves_keys.len() {\n                    // If it's not final round, we don't need to merge to root (height=255)\n                    break;\n                }\n                let (op_code_opt, sibling_data_opt): (_, Option\u003cVec\u003cu8\u003e\u003e) =\n                    if stack_top \u003e 0 \u0026\u0026 stack_fork_height[stack_top - 1] == height {\n                        stack_top -= 1;\n                        (Some(0x48), None)\n                    } else if leaves_bitmap[leaf_index].get_bit(height) {\n                        if merkle_path_index \u003e= merkle_path.len() {\n                            return Err(Error::CorruptedProof);\n                        }\n                        let node = \u0026merkle_path[merkle_path_index];\n                        merkle_path_index += 1;\n                        match node {\n                            MergeValue::Value(v) =\u003e (Some(0x50), Some(v.as_slice().to_vec())),\n                            MergeValue::MergeWithZero {\n                                base_node,\n                                zero_bits,\n                                zero_count,\n                            } =\u003e {\n                                let mut buffer = crate::vec![*zero_count];\n                                buffer.extend_from_slice(base_node.as_slice());\n                                buffer.extend_from_slice(zero_bits.as_slice());\n                                (Some(0x51), Some(buffer))\n                            }\n                            #[cfg(feature = \"trie\")]\n                            _ =\u003e unreachable!(),\n                        }\n                    } else {\n                        zero_count += 1;\n                        if zero_count \u003e 256 {\n                            return Err(Error::CorruptedProof);\n                        }\n                        (None, None)\n                    };\n                if let Some(op_code) = op_code_opt {\n                    if zero_count \u003e 0 {\n                        let n = if zero_count == 256 {\n                            0\n                        } else {\n                            zero_count as u8\n                        };\n                        proof.push(0x4F);\n                        proof.push(n);\n                        zero_count = 0;\n                    }\n                    proof.push(op_code);\n                }\n                if let Some(data) = sibling_data_opt {\n                    proof.extend(\u0026data);\n                }\n            }\n            if zero_count \u003e 0 {\n                let n = if zero_count == 256 {\n                    0\n                } else {\n                    zero_count as u8\n                };\n                proof.push(0x4F);\n                proof.push(n);\n            }\n            debug_assert!(stack_top \u003c MAX_STACK_SIZE);\n            stack_fork_height[stack_top] = fork_height;\n            stack_top += 1;\n            leaf_index += 1;\n        }\n\n        if stack_top != 1 {\n            return Err(Error::CorruptedProof);\n        }\n        if leaf_index != leaves_keys.len() {\n            return Err(Error::CorruptedProof);\n        }\n        if merkle_path_index != merkle_path.len() {\n            return Err(Error::CorruptedProof);\n        }\n        Ok(CompiledMerkleProof(proof))\n    }\n\n    /// Compute root from proof\n    /// leaves: a vector of (key, value)\n    ///\n    /// return EmptyProof error when proof is empty\n    /// return CorruptedProof error when proof is invalid\n    pub fn compute_root\u003cH: Hasher + Default\u003e(self, leaves: Vec\u003c(H256, H256)\u003e) -\u003e Result\u003cH256\u003e {\n        self.compile(leaves.iter().map(|(key, _value)| *key).collect())?\n            .compute_root::\u003cH\u003e(leaves)\n    }\n\n    /// Verify merkle proof\n    /// see compute_root_from_proof\n    pub fn verify\u003cH: Hasher + Default\u003e(\n        self,\n        root: \u0026H256,\n        leaves: Vec\u003c(H256, H256)\u003e,\n    ) -\u003e Result\u003cbool\u003e {\n        let calculated_root = self.compute_root::\u003cH\u003e(leaves)?;\n        Ok(\u0026calculated_root == root)\n    }\n}\n\n/// An structure optimized for verify merkle proof\n#[derive(Debug, Clone)]\npub struct CompiledMerkleProof(pub Vec\u003cu8\u003e);\n\n// A op code context passing to the callback function\nenum OpCodeContext\u003c'a\u003e {\n    L {\n        key: \u0026'a H256,\n    },\n    P {\n        key: \u0026'a H256,\n        height: u8,\n        program_index: usize,\n    },\n    Q {\n        key: \u0026'a H256,\n        height: u8,\n        program_index: usize,\n    },\n    H {\n        key_a: \u0026'a H256,\n        key_b: \u0026'a H256,\n        height: u8,\n        value_a: \u0026'a MergeValue,\n        value_b: \u0026'a MergeValue,\n    },\n    O {\n        key: \u0026'a H256,\n        height: u8,\n        n: u8,\n    },\n}\n\nimpl CompiledMerkleProof {\n    fn compute_root_inner\u003cH: Hasher + Default, F: FnMut(OpCodeContext) -\u003e Result\u003c()\u003e\u003e(\n        \u0026self,\n        mut leaves: Vec\u003c(H256, H256)\u003e,\n        mut callback: F,\n    ) -\u003e Result\u003cH256\u003e {\n        leaves.sort_unstable_by_key(|(k, _v)| *k);\n        let mut program_index = 0;\n        let mut leaf_index = 0;\n        let mut stack: Vec\u003c(u16, H256, MergeValue)\u003e = Vec::new();\n        while program_index \u003c self.0.len() {\n            let code = self.0[program_index];\n            program_index += 1;\n            match code {\n                // L : push leaf value\n                0x4C =\u003e {\n                    if leaf_index \u003e= leaves.len() {\n                        return Err(Error::CorruptedStack);\n                    }\n                    let (k, v) = leaves[leaf_index];\n                    callback(OpCodeContext::L { key: \u0026k })?;\n                    stack.push((0, k, MergeValue::from_h256(v)));\n                    leaf_index += 1;\n                }\n                // P : hash stack top item with sibling node in proof\n                0x50 =\u003e {\n                    if stack.is_empty() {\n                        return Err(Error::CorruptedStack);\n                    }\n                    if program_index + 32 \u003e self.0.len() {\n                        return Err(Error::CorruptedProof);\n                    }\n                    let mut data = [0u8; 32];\n                    data.copy_from_slice(\u0026self.0[program_index..program_index + 32]);\n                    program_index += 32;\n                    let sibling_node = MergeValue::from_h256(H256::from(data));\n                    let (height_u16, key, value) = stack.pop().unwrap();\n                    if height_u16 \u003e 255 {\n                        return Err(Error::CorruptedProof);\n                    }\n                    let height = height_u16 as u8;\n                    let parent_key = key.parent_path(height);\n                    callback(OpCodeContext::P {\n                        key: \u0026key,\n                        height,\n                        program_index,\n                    })?;\n                    let parent = if key.get_bit(height) {\n                        merge::\u003cH\u003e(height, \u0026parent_key, \u0026sibling_node, \u0026value)\n                    } else {\n                        merge::\u003cH\u003e(height, \u0026parent_key, \u0026value, \u0026sibling_node)\n                    };\n                    stack.push((height_u16 + 1, parent_key, parent));\n                }\n                // Q : hash stack top item with sibling node in proof,\n                // this is similar to P except that proof comes in using\n                // MergeWithZero format.\n                0x51 =\u003e {\n                    if stack.is_empty() {\n                        return Err(Error::CorruptedStack);\n                    }\n                    if program_index + 65 \u003e self.0.len() {\n                        return Err(Error::CorruptedProof);\n                    }\n                    let zero_count = self.0[program_index];\n                    let base_node = {\n                        let mut data = [0u8; 32];\n                        data.copy_from_slice(\u0026self.0[program_index + 1..program_index + 33]);\n                        H256::from(data)\n                    };\n                    let zero_bits = {\n                        let mut data = [0u8; 32];\n                        data.copy_from_slice(\u0026self.0[program_index + 33..program_index + 65]);\n                        H256::from(data)\n                    };\n                    program_index += 65;\n                    let sibling_node = MergeValue::MergeWithZero {\n                        base_node,\n                        zero_bits,\n                        zero_count,\n                    };\n                    let (height_u16, key, value) = stack.pop().unwrap();\n                    if height_u16 \u003e 255 {\n                        return Err(Error::CorruptedProof);\n                    }\n                    let height = height_u16 as u8;\n                    let parent_key = key.parent_path(height);\n                    callback(OpCodeContext::Q {\n                        key: \u0026key,\n                        height,\n                        program_index,\n                    })?;\n                    let parent = if key.get_bit(height) {\n                        merge::\u003cH\u003e(height, \u0026parent_key, \u0026sibling_node, \u0026value)\n                    } else {\n                        merge::\u003cH\u003e(height, \u0026parent_key, \u0026value, \u0026sibling_node)\n                    };\n                    stack.push((height_u16 + 1, parent_key, parent));\n                }\n                // H : pop 2 items in stack hash them then push the result\n                0x48 =\u003e {\n                    if stack.len() \u003c 2 {\n                        return Err(Error::CorruptedStack);\n                    }\n                    let (height_b, key_b, value_b) = stack.pop().unwrap();\n                    let (height_a, key_a, value_a) = stack.pop().unwrap();\n                    if height_a != height_b {\n                        return Err(Error::CorruptedProof);\n                    }\n                    if height_a \u003e 255 {\n                        return Err(Error::CorruptedProof);\n                    }\n                    let height_u16 = height_a;\n                    let height = height_u16 as u8;\n                    let parent_key_a = key_a.parent_path(height);\n                    let parent_key_b = key_b.parent_path(height);\n                    if parent_key_a != parent_key_b {\n                        return Err(Error::CorruptedProof);\n                    }\n                    callback(OpCodeContext::H {\n                        key_a: \u0026key_a,\n                        key_b: \u0026key_b,\n                        height,\n                        value_a: \u0026value_a,\n                        value_b: \u0026value_b,\n                    })?;\n                    let parent = if key_a.get_bit(height) {\n                        merge::\u003cH\u003e(height, \u0026parent_key_a, \u0026value_b, \u0026value_a)\n                    } else {\n                        merge::\u003cH\u003e(height, \u0026parent_key_a, \u0026value_a, \u0026value_b)\n                    };\n                    stack.push((height_u16 + 1, parent_key_a, parent));\n                }\n                // O : hash stack top item with n zero values\n                0x4F =\u003e {\n                    if stack.is_empty() {\n                        return Err(Error::CorruptedStack);\n                    }\n                    if program_index \u003e= self.0.len() {\n                        return Err(Error::CorruptedProof);\n                    }\n                    let n = self.0[program_index];\n                    program_index += 1;\n                    let zero_count: u16 = if n == 0 { 256 } else { n as u16 };\n                    let (base_height, key, mut value) = stack.pop().unwrap();\n                    if base_height \u003e 255 {\n                        return Err(Error::CorruptedProof);\n                    }\n                    callback(OpCodeContext::O {\n                        key: \u0026key,\n                        height: base_height as u8,\n                        n,\n                    })?;\n                    let mut parent_key = key;\n                    let mut height_u16 = base_height;\n                    for idx in 0..zero_count {\n                        if base_height + idx \u003e 255 {\n                            return Err(Error::CorruptedProof);\n                        }\n                        height_u16 = base_height + idx;\n                        let height = height_u16 as u8;\n                        parent_key = key.parent_path(height);\n                        value = if key.get_bit(height) {\n                            merge::\u003cH\u003e(height, \u0026parent_key, \u0026MergeValue::zero(), \u0026value)\n                        } else {\n                            merge::\u003cH\u003e(height, \u0026parent_key, \u0026value, \u0026MergeValue::zero())\n                        };\n                    }\n                    stack.push((height_u16 + 1, parent_key, value));\n                }\n                _ =\u003e return Err(Error::InvalidCode(code)),\n            }\n            debug_assert!(stack.len() \u003c= MAX_STACK_SIZE);\n        }\n        if stack.len() != 1 {\n            return Err(Error::CorruptedStack);\n        }\n        if stack[0].0 != 256 {\n            return Err(Error::CorruptedProof);\n        }\n        if leaf_index != leaves.len() {\n            return Err(Error::CorruptedProof);\n        }\n        Ok(stack[0].2.hash::\u003cH\u003e())\n    }\n\n    /// Extract sub compiled proof for certain sub leaves from current compiled proof.\n    ///\n    /// The argument must include all leaves. The 3rd item of every tuple\n    /// indicate if the sub key is selected.\n    pub fn extract_proof\u003cH: Hasher + Default\u003e(\n        \u0026self,\n        all_leaves: Vec\u003c(H256, H256, bool)\u003e,\n    ) -\u003e Result\u003cCompiledMerkleProof\u003e {\n        let mut leaves = Vec::with_capacity(all_leaves.len());\n        let mut sub_keys = Vec::new();\n        for (key, value, included) in all_leaves {\n            leaves.push((key, value));\n            if included {\n                sub_keys.push(key);\n            }\n        }\n\n        fn match_any_sub_key(key: \u0026H256, height: u8, sub_keys: \u0026[H256]) -\u003e bool {\n            sub_keys.iter().any(|sub_key| {\n                if height == 0 {\n                    key == sub_key\n                } else {\n                    key == \u0026sub_key.parent_path(height - 1)\n                }\n            })\n        }\n\n        let mut sub_proof = Vec::default();\n        let mut is_last_merge_zero = false;\n        let mut callback = |ctx: OpCodeContext| {\n            match ctx {\n                OpCodeContext::L { key } =\u003e {\n                    if sub_keys.contains(key) {\n                        sub_proof.push(0x4C);\n                        is_last_merge_zero = false;\n                    }\n                }\n                OpCodeContext::P {\n                    key,\n                    height,\n                    program_index,\n                } =\u003e {\n                    if match_any_sub_key(key, height, \u0026sub_keys) {\n                        sub_proof.push(0x50);\n                        sub_proof.extend(\u0026self.0[program_index - 32..program_index]);\n                        is_last_merge_zero = false;\n                    }\n                }\n                OpCodeContext::Q {\n                    key,\n                    height,\n                    program_index,\n                } =\u003e {\n                    if match_any_sub_key(key, height, \u0026sub_keys) {\n                        sub_proof.push(0x51);\n                        sub_proof.extend(\u0026self.0[program_index - 65..program_index]);\n                        is_last_merge_zero = false;\n                    }\n                }\n                OpCodeContext::H {\n                    key_a,\n                    key_b,\n                    height,\n                    value_a,\n                    value_b,\n                } =\u003e {\n                    let key_a_included = match_any_sub_key(key_a, height, \u0026sub_keys);\n                    let key_b_included = match_any_sub_key(key_b, height, \u0026sub_keys);\n                    if key_a_included \u0026\u0026 key_b_included {\n                        sub_proof.push(0x48);\n                        is_last_merge_zero = false;\n                    } else if key_a_included || key_b_included {\n                        let sibling_value = if key_a_included { \u0026value_b } else { \u0026value_a };\n                        match sibling_value {\n                            MergeValue::Value(hash) =\u003e {\n                                if hash.is_zero() {\n                                    if is_last_merge_zero {\n                                        let last_n = *sub_proof.last().unwrap();\n                                        if last_n == 0 {\n                                            return Err(Error::CorruptedProof);\n                                        }\n                                        *sub_proof.last_mut().unwrap() = last_n.wrapping_add(1);\n                                    } else {\n                                        sub_proof.push(0x4F);\n                                        sub_proof.push(1);\n                                        is_last_merge_zero = true;\n                                    }\n                                } else {\n                                    sub_proof.push(0x50);\n                                    sub_proof.extend(hash.as_slice());\n                                    is_last_merge_zero = false;\n                                }\n                            }\n                            MergeValue::MergeWithZero {\n                                base_node,\n                                zero_bits,\n                                zero_count,\n                            } =\u003e {\n                                sub_proof.push(0x51);\n                                sub_proof.push(*zero_count);\n                                sub_proof.extend(base_node.as_slice());\n                                sub_proof.extend(zero_bits.as_slice());\n                                is_last_merge_zero = false;\n                            }\n                            #[cfg(feature = \"trie\")]\n                            _ =\u003e {}\n                        };\n                    }\n                }\n                OpCodeContext::O { key, height, n } =\u003e {\n                    if match_any_sub_key(key, height, \u0026sub_keys) {\n                        if is_last_merge_zero {\n                            let last_n = *sub_proof.last().unwrap();\n                            if last_n == 0 || (last_n as u16 + n as u16) \u003e 256 {\n                                return Err(Error::CorruptedProof);\n                            }\n                            *sub_proof.last_mut().unwrap() = last_n.wrapping_add(n);\n                        } else {\n                            sub_proof.push(0x4F);\n                            sub_proof.push(n);\n                            is_last_merge_zero = true;\n                        }\n                    }\n                }\n            }\n            Ok(())\n        };\n        self.compute_root_inner::\u003cH, _\u003e(leaves, \u0026mut callback)?;\n        Ok(CompiledMerkleProof(sub_proof))\n    }\n\n    pub fn compute_root\u003cH: Hasher + Default\u003e(\u0026self, leaves: Vec\u003c(H256, H256)\u003e) -\u003e Result\u003cH256\u003e {\n        self.compute_root_inner::\u003cH, _\u003e(leaves, |_| Ok(()))\n    }\n\n    pub fn verify\u003cH: Hasher + Default\u003e(\n        \u0026self,\n        root: \u0026H256,\n        leaves: Vec\u003c(H256, H256)\u003e,\n    ) -\u003e Result\u003cbool\u003e {\n        let calculated_root = self.compute_root::\u003cH\u003e(leaves)?;\n        Ok(\u0026calculated_root == root)\n    }\n}\n\nimpl From\u003cCompiledMerkleProof\u003e for Vec\u003cu8\u003e {\n    fn from(proof: CompiledMerkleProof) -\u003e Vec\u003cu8\u003e {\n        proof.0\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":109}},{"line":29,"address":[],"length":0,"stats":{"Line":2}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":2}},{"line":32,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":34,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":107}},{"line":44,"address":[],"length":0,"stats":{"Line":107}},{"line":48,"address":[],"length":0,"stats":{"Line":107}},{"line":49,"address":[],"length":0,"stats":{"Line":107}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":4}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":80,"address":[],"length":0,"stats":{"Line":512}},{"line":81,"address":[],"length":0,"stats":{"Line":514}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":512}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":512}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":2}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":510}},{"line":112,"address":[],"length":0,"stats":{"Line":510}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":510}},{"line":117,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":4}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":2}},{"line":128,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":514}},{"line":134,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":2}},{"line":140,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":149,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":2}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":2}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":2}},{"line":222,"address":[],"length":0,"stats":{"Line":4}},{"line":223,"address":[],"length":0,"stats":{"Line":2}},{"line":224,"address":[],"length":0,"stats":{"Line":2}},{"line":225,"address":[],"length":0,"stats":{"Line":2}},{"line":226,"address":[],"length":0,"stats":{"Line":10}},{"line":227,"address":[],"length":0,"stats":{"Line":8}},{"line":228,"address":[],"length":0,"stats":{"Line":8}},{"line":229,"address":[],"length":0,"stats":{"Line":8}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":2}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":2}},{"line":236,"address":[],"length":0,"stats":{"Line":2}},{"line":237,"address":[],"length":0,"stats":{"Line":2}},{"line":238,"address":[],"length":0,"stats":{"Line":2}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":2}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":2}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":2}},{"line":281,"address":[],"length":0,"stats":{"Line":2}},{"line":282,"address":[],"length":0,"stats":{"Line":2}},{"line":283,"address":[],"length":0,"stats":{"Line":2}},{"line":284,"address":[],"length":0,"stats":{"Line":2}},{"line":286,"address":[],"length":0,"stats":{"Line":2}},{"line":287,"address":[],"length":0,"stats":{"Line":2}},{"line":288,"address":[],"length":0,"stats":{"Line":2}},{"line":289,"address":[],"length":0,"stats":{"Line":2}},{"line":291,"address":[],"length":0,"stats":{"Line":2}},{"line":297,"address":[],"length":0,"stats":{"Line":2}},{"line":298,"address":[],"length":0,"stats":{"Line":2}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":2}},{"line":302,"address":[],"length":0,"stats":{"Line":2}},{"line":303,"address":[],"length":0,"stats":{"Line":2}},{"line":304,"address":[],"length":0,"stats":{"Line":2}},{"line":305,"address":[],"length":0,"stats":{"Line":2}},{"line":306,"address":[],"length":0,"stats":{"Line":2}},{"line":308,"address":[],"length":0,"stats":{"Line":4}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":2}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":4}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":4}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":4}},{"line":358,"address":[],"length":0,"stats":{"Line":4}},{"line":359,"address":[],"length":0,"stats":{"Line":4}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":4}},{"line":365,"address":[],"length":0,"stats":{"Line":4}},{"line":366,"address":[],"length":0,"stats":{"Line":4}},{"line":367,"address":[],"length":0,"stats":{"Line":4}},{"line":369,"address":[],"length":0,"stats":{"Line":4}},{"line":370,"address":[],"length":0,"stats":{"Line":4}},{"line":371,"address":[],"length":0,"stats":{"Line":510}},{"line":372,"address":[],"length":0,"stats":{"Line":510}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":510}},{"line":376,"address":[],"length":0,"stats":{"Line":510}},{"line":377,"address":[],"length":0,"stats":{"Line":510}},{"line":378,"address":[],"length":0,"stats":{"Line":510}},{"line":379,"address":[],"length":0,"stats":{"Line":256}},{"line":381,"address":[],"length":0,"stats":{"Line":254}},{"line":384,"address":[],"length":0,"stats":{"Line":4}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":16}},{"line":390,"address":[],"length":0,"stats":{"Line":2}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":2}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":2}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":2}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":2}},{"line":534,"address":[],"length":0,"stats":{"Line":12}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}}],"covered":126,"coverable":308},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","tests","fixtures.rs"],"content":"use std::fs;\n\nuse crate::{\n    blake2b::Blake2bHasher, default_store::DefaultStore, CompiledMerkleProof, SparseMerkleTree,\n    H256,\n};\nuse anyhow::Result;\nuse rand::{prelude::SliceRandom, thread_rng, Rng};\nuse serde::{Deserialize, Serialize};\n\ntype Leave = ([u8; 32], [u8; 32]);\n\n#[derive(Default, Serialize, Deserialize)]\nstruct Proof {\n    leaves: Vec\u003cLeave\u003e,\n    compiled_proof: Vec\u003cu8\u003e,\n    error: Option\u003cString\u003e,\n}\n\n#[derive(Default, Serialize, Deserialize)]\nstruct Case {\n    name: String,\n    leaves: Vec\u003cLeave\u003e,\n    root: [u8; 32],\n    proofs: Vec\u003cProof\u003e,\n}\n\ntype SMT = SparseMerkleTree\u003cBlake2bHasher, H256, DefaultStore\u003cH256\u003e\u003e;\n\nfn new_smt(pairs: Vec\u003c(H256, H256)\u003e) -\u003e SMT {\n    let mut smt = SMT::default();\n    for (key, value) in pairs {\n        smt.update(key, value).unwrap();\n    }\n    smt\n}\n\nfn leaves(min_leaves: usize, max_leaves: usize) -\u003e Vec\u003c(H256, H256)\u003e {\n    let mut rng = thread_rng();\n    let size = rng.gen_range(min_leaves..=max_leaves);\n    let mut pairs: Vec\u003c_\u003e = (0..size)\n        .map(|_| {\n            let mut k = [0u8; 32];\n            let mut v = [0u8; 32];\n            rng.fill(\u0026mut k);\n            rng.fill(\u0026mut v);\n            (k.into(), v.into())\n        })\n        .collect();\n    pairs.dedup_by_key(|(k, _v)| *k);\n    pairs\n}\n\nfn gen_test_case(name: String) -\u003e Case {\n    let leaves = leaves(1, 50);\n    let smt = new_smt(leaves.clone());\n    let mut rng = thread_rng();\n\n    let mut proofs = Vec::new();\n    for _i in 0..5 {\n        let amount = rng.gen_range(0..=leaves.len());\n        let leaves_to_proof: Vec\u003c_\u003e = leaves.choose_multiple(\u0026mut rng, amount).cloned().collect();\n        let keys: Vec\u003c_\u003e = leaves_to_proof.iter().map(|(k, _v)| *k).collect();\n        let proof = match smt.merkle_proof(keys.clone()) {\n            Ok(proof) =\u003e {\n                let compiled_proof = proof.clone().compile(keys).expect(\"compile proof\");\n                Proof {\n                    leaves: leaves_to_proof\n                        .into_iter()\n                        .map(|(k, v)| (k.into(), v.into()))\n                        .collect(),\n                    compiled_proof: compiled_proof.into(),\n                    error: None,\n                }\n            }\n            Err(err) =\u003e Proof {\n                leaves: Default::default(),\n                compiled_proof: Default::default(),\n                error: Some(format!(\"{}\", err)),\n            },\n        };\n        proofs.push(proof);\n    }\n\n    Case {\n        name,\n        root: (*smt.root()).into(),\n        leaves: leaves\n            .into_iter()\n            .map(|(k, v)| (k.into(), v.into()))\n            .collect(),\n        proofs,\n    }\n}\n\n// use `cargo test test_gen_fixtures -- --ignored` to regenerate fixtures\n#[test]\n#[ignore]\nfn test_gen_fixtures() {\n    for i in 0..100 {\n        let name = format!(\"case-{}\", i);\n        let case = gen_test_case(name.clone());\n        let content = serde_json::to_vec_pretty(\u0026case).expect(\"to json\");\n        let path = format!(\"{}/basic/{}.json\", FIXTURES_DIR, name);\n        fs::write(\u0026path, content).expect(\"write\");\n        println!(\"write {}\", \u0026path);\n    }\n}\n\nfn run_test_case(case: Case) -\u003e Result\u003c()\u003e {\n    let Case {\n        name: _name,\n        leaves,\n        root,\n        proofs,\n    } = case;\n    let smt = new_smt(\n        leaves\n            .iter()\n            .map(|(k, v)| ((*k).into(), (*v).into()))\n            .collect(),\n    );\n    assert_eq!(smt.root(), \u0026root.into(), \"root\");\n\n    for proof in proofs {\n        let Proof {\n            leaves,\n            compiled_proof,\n            error,\n        } = proof;\n        let keys = leaves.iter().map(|(k, _v)| (*k).into()).collect();\n        let actual_compiled_proof: Vec\u003cu8\u003e = match smt.merkle_proof(keys) {\n            Ok(proof) =\u003e proof\n                .compile(leaves.iter().map(|(k, _v)| (*k).into()).collect())?\n                .into(),\n            Err(err) =\u003e {\n                let expected_error = error.expect(\"expected error\");\n                assert_eq!(expected_error, format!(\"{}\", err));\n                return Ok(());\n            }\n        };\n\n        assert_eq!(compiled_proof, actual_compiled_proof, \"proof\");\n\n        let proof = CompiledMerkleProof(compiled_proof);\n        let proof_root = proof\n            .compute_root::\u003cBlake2bHasher\u003e(\n                leaves\n                    .into_iter()\n                    .map(|(k, v)| (k.into(), v.into()))\n                    .collect(),\n            )\n            .expect(\"compute_root\");\n        assert_eq!(smt.root(), \u0026proof_root, \"proof root\");\n    }\n\n    Ok(())\n}\n\nconst FIXTURES_DIR: \u0026str = \"fixtures\";\n\n#[test]\nfn test_fixtures() {\n    for i in 0..100 {\n        let path = format!(\"{}/basic/case-{}.json\", FIXTURES_DIR, i);\n        let content = fs::read(\u0026path).expect(\"read\");\n        let case: Case = serde_json::from_slice(\u0026content).expect(\"parse json\");\n        run_test_case(case).expect(\"test case\");\n        println!(\"pass {}\", i);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","tests","mod.rs"],"content":"// FIXME: fix fixtures tests later\nmod fixtures;\nmod smt;\nmod tree;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","tests","smt.rs"],"content":"#[cfg(feature = \"smtc\")]\nuse std::convert::TryInto;\n\nuse crate::*;\nuse blake2b_rs::{Blake2b, Blake2bBuilder};\nuse default_store::DefaultStore;\n#[cfg(feature = \"smtc\")]\nuse hex::decode;\nuse proptest::prelude::*;\nuse traits::Hasher;\n\n#[cfg(feature = \"smtc\")]\nfn str_to_h256(src: \u0026str) -\u003e H256 {\n    let src = decode(src).unwrap();\n    assert!(src.len() == 32);\n    let data: [u8; 32] = src.try_into().unwrap();\n    H256::from(data)\n}\n\n#[cfg(feature = \"smtc\")]\nfn str_to_vec(src: \u0026str) -\u003e Vec\u003cu8\u003e {\n    decode(src).unwrap()\n}\n\n#[cfg(feature = \"smtc\")]\n#[test]\nfn test_ckb_smt_verify1() {\n    let key = str_to_h256(\"381dc5391dab099da5e28acd1ad859a051cf18ace804d037f12819c6fbc0e18b\");\n    let val = str_to_h256(\"9158ce9b0e11dd150ba2ae5d55c1db04b1c5986ec626f2e38a93fe8ad0b2923b\");\n    let root_hash = str_to_h256(\"ebe0fab376cd802d364eeb44af20c67a74d6183a33928fead163120ef12e6e06\");\n    let proof = str_to_vec(\n        \"4c4fff51ff322de8a89fe589987f97220cfcb6820bd798b31a0b56ffea221093d35f909e580b00000000000000000000000000000000000000000000000000000000000000\");\n\n    let builder = SMTBuilder::new();\n    let builder = builder.insert(\u0026key, \u0026val).unwrap();\n\n    let smt = builder.build().unwrap();\n    assert!(smt.verify(\u0026root_hash, \u0026proof).is_ok());\n}\n\n#[cfg(feature = \"smtc\")]\n#[test]\nfn test_ckb_smt_verify2() {\n    let key = str_to_h256(\"a9bb945be71f0bd2757d33d2465b6387383da42f321072e47472f0c9c7428a8a\");\n    let val = str_to_h256(\"a939a47335f777eac4c40fbc0970e25f832a24e1d55adc45a7b76d63fe364e82\");\n    let root_hash = str_to_h256(\"6e5c722644cd55cef8c4ed886cd8b44027ae9ed129e70a4b67d87be1c6857842\");\n    let proof = str_to_vec(\n        \"4c4fff51fa8aaa2aece17b92ec3f202a40a09f7286522bae1e5581a2a49195ab6781b1b8090000000000000000000000000000000000000000000000000000000000000000\");\n\n    let builder = SMTBuilder::new();\n    let builder = builder.insert(\u0026key, \u0026val).unwrap();\n\n    let smt = builder.build().unwrap();\n    assert!(smt.verify(\u0026root_hash, \u0026proof).is_ok());\n}\n\n#[cfg(feature = \"smtc\")]\n#[test]\nfn test_ckb_smt_verify3() {\n    let key = str_to_h256(\"e8c0265680a02b680b6cbc880348f062b825b28e237da7169aded4bcac0a04e5\");\n    let val = str_to_h256(\"2ca41595841e46ce8e74ad749e5c3f1d17202150f99c3d8631233ebdd19b19eb\");\n    let root_hash = str_to_h256(\"c8f513901e34383bcec57c368628ce66da7496df0a180ee1e021df3d97cb8f7b\");\n    let proof = str_to_vec(\n        \"4c4fff51fa8aaa2aece17b92ec3f202a40a09f7286522bae1e5581a2a49195ab6781b1b8090000000000000000000000000000000000000000000000000000000000000000\");\n\n    let builder = SMTBuilder::new();\n    let builder = builder.insert(\u0026key, \u0026val).unwrap();\n\n    let smt = builder.build().unwrap();\n    assert!(smt.verify(\u0026root_hash, \u0026proof).is_ok());\n}\n\n#[cfg(feature = \"smtc\")]\n#[test]\nfn test_ckb_smt_verify_invalid() {\n    let key = str_to_h256(\"e8c0265680a02b680b6cbc880348f062b825b28e237da7169aded4bcac0a04e5\");\n    let val = str_to_h256(\"2ca41595841e46ce8e74ad749e5c3f1d17202150f99c3d8631233ebdd19b19eb\");\n    let root_hash = str_to_h256(\"a4cbf1b69a848396ac759f362679e2b185ac87a17cba747d2db1ef6fd929042f\");\n    let proof =\n        str_to_vec(\"4c50fe32845309d34f132cd6f7ac6a7881962401adc35c19a18d4fffeb511b97eabf86\");\n\n    let builder = SMTBuilder::new();\n    let builder = builder.insert(\u0026key, \u0026val).unwrap();\n\n    let smt = builder.build().unwrap();\n    assert!(smt.verify(\u0026root_hash, \u0026proof).is_err());\n}\n\npub struct CkbBlake2bHasher(Blake2b);\n\nimpl Default for CkbBlake2bHasher {\n    fn default() -\u003e Self {\n        // NOTE: here we not set the `personal` since ckb_smt.c linked blake2b implementation from blake2b-rs\n        let blake2b = Blake2bBuilder::new(32)\n            .personal(b\"ckb-default-hash\")\n            .build();\n        CkbBlake2bHasher(blake2b)\n    }\n}\n\nimpl Hasher for CkbBlake2bHasher {\n    fn write_byte(\u0026mut self, b: u8) {\n        self.0.update(\u0026[b][..]);\n    }\n    fn write_h256(\u0026mut self, h: \u0026H256) {\n        self.0.update(h.as_slice());\n    }\n    fn finish(self) -\u003e H256 {\n        let mut hash = [0u8; 32];\n        self.0.finalize(\u0026mut hash);\n        hash.into()\n    }\n}\n\npub type CkbSMT = SparseMerkleTree\u003cCkbBlake2bHasher, H256, DefaultStore\u003cH256\u003e\u003e;\nproptest! {\n    #[test]\n    fn test_random_merkle_proof(key: [u8; 32], value: [u8;32]) {\n        let key = H256::from(key);\n        let value = H256::from(value);\n        const EXPECTED_PROOF_SIZE: usize = 16;\n\n        let mut tree = CkbSMT::default();\n        tree.update(key, value).expect(\"update\");\n        if !tree.is_empty() {\n            let proof = tree.merkle_proof(vec![key]).expect(\"proof\");\n            let compiled_proof = proof\n                .clone()\n                .compile(vec![key])\n                .expect(\"compile proof\");\n            assert!(proof.merkle_path().len() \u003c EXPECTED_PROOF_SIZE);\n            assert!(proof\n                    .verify::\u003cCkbBlake2bHasher\u003e(tree.root(), vec![(key, value)])\n                    .expect(\"verify\"));\n            assert!(compiled_proof\n                    .verify::\u003cCkbBlake2bHasher\u003e(tree.root(), vec![(key, value)])\n                    .expect(\"compiled verify\"));\n\n            let single_compiled_proof = compiled_proof\n                .extract_proof::\u003cCkbBlake2bHasher\u003e(vec![(key, value, true)])\n                .expect(\"compiled one proof\");\n            assert_eq!(compiled_proof.0, single_compiled_proof.0);\n            assert!(single_compiled_proof\n                    .verify::\u003cCkbBlake2bHasher\u003e(tree.root(), vec![(key, value)])\n                    .expect(\"verify compiled one proof\"));\n\n            #[cfg(feature = \"smtc\")]\n            {\n                let compiled_proof_bin: Vec\u003cu8\u003e = compiled_proof.into();\n                let smt_state = SMTBuilder::new();\n                let smt_state = smt_state.insert(\u0026key, \u0026value).unwrap();\n                let smt = smt_state.build().unwrap();\n                smt.verify(tree.root(), \u0026compiled_proof_bin).expect(\"verify with c\");\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","tests","tree.rs"],"content":"use crate::{\n    blake2b::Blake2bHasher, default_store::DefaultStore, error::Error, merge::MergeValue,\n    MerkleProof, *,\n};\nuse proptest::prelude::*;\nuse rand::prelude::{Rng, SliceRandom};\nuse std::collections::HashMap;\n\n#[allow(clippy::upper_case_acronyms)]\ntype SMT = SparseMerkleTree\u003cBlake2bHasher, H256, DefaultStore\u003cH256\u003e\u003e;\n\n#[test]\nfn test_default_root() {\n    let mut tree = SMT::default();\n    assert_eq!(tree.store().branches_map().len(), 0);\n    assert_eq!(tree.store().leaves_map().len(), 0);\n    assert_eq!(tree.root(), \u0026H256::zero());\n\n    // insert a key-value\n    tree.update(H256::zero(), [42u8; 32].into())\n        .expect(\"update\");\n    assert_ne!(tree.root(), \u0026H256::zero());\n    assert_ne!(tree.store().branches_map().len(), 0);\n    assert_ne!(tree.store().leaves_map().len(), 0);\n    assert_eq!(tree.get(\u0026H256::zero()).expect(\"get\"), [42u8; 32].into());\n    // update zero is to delete the key\n    tree.update(H256::zero(), H256::zero()).expect(\"update\");\n    assert_eq!(tree.root(), \u0026H256::zero());\n    assert_eq!(tree.get(\u0026H256::zero()).expect(\"get\"), H256::zero());\n}\n\n#[test]\nfn test_default_tree() {\n    let tree = SMT::default();\n    assert_eq!(tree.get(\u0026H256::zero()).expect(\"get\"), H256::zero());\n    let proof = tree.merkle_proof(vec![H256::zero()]).expect(\"merkle proof\");\n    let root = proof\n        .compute_root::\u003cBlake2bHasher\u003e(vec![(H256::zero(), H256::zero())])\n        .expect(\"root\");\n    assert_eq!(\u0026root, tree.root());\n    let proof = tree.merkle_proof(vec![H256::zero()]).expect(\"merkle proof\");\n    let root2 = proof\n        .compute_root::\u003cBlake2bHasher\u003e(vec![(H256::zero(), [42u8; 32].into())])\n        .expect(\"root\");\n    assert_ne!(\u0026root2, tree.root());\n}\n\n#[test]\nfn test_default_merkle_proof() {\n    let proof = MerkleProof::new(Default::default(), Default::default());\n    let result = proof.compute_root::\u003cBlake2bHasher\u003e(vec![([42u8; 32].into(), [42u8; 32].into())]);\n    assert_eq!(\n        result.unwrap_err(),\n        Error::IncorrectNumberOfLeaves {\n            expected: 0,\n            actual: 1\n        }\n    );\n\n    // FIXME: makes room for leaves\n    // let proof = MerkleProof::new(vec![Vec::new()], Default::default());\n    // let root = proof\n    //     .compute_root::\u003cBlake2bHasher\u003e(vec![([42u8; 32].into(), [42u8; 32].into())])\n    //     .expect(\"compute root\");\n    // assert_ne!(root, H256::zero());\n}\n\n#[test]\nfn test_merkle_root() {\n    fn new_blake2b() -\u003e blake2b_rs::Blake2b {\n        blake2b_rs::Blake2bBuilder::new(32).personal(b\"SMT\").build()\n    }\n\n    let mut tree = SMT::default();\n    for (i, word) in \"The quick brown fox jumps over the lazy dog\"\n        .split_whitespace()\n        .enumerate()\n    {\n        let key: H256 = {\n            let mut buf = [0u8; 32];\n            let mut hasher = new_blake2b();\n            hasher.update(\u0026(i as u32).to_le_bytes());\n            hasher.finalize(\u0026mut buf);\n            buf.into()\n        };\n        let value: H256 = {\n            let mut buf = [0u8; 32];\n            let mut hasher = new_blake2b();\n            hasher.update(word.as_bytes());\n            hasher.finalize(\u0026mut buf);\n            buf.into()\n        };\n        tree.update(key, value).expect(\"update\");\n    }\n\n    let expected_root: H256 = [\n        209, 214, 1, 128, 166, 207, 49, 89, 206, 78, 169, 88, 18, 243, 130, 61, 150, 45, 43, 54,\n        208, 20, 237, 20, 98, 69, 130, 120, 241, 169, 248, 211,\n    ]\n    .into();\n    assert_eq!(tree.store().leaves_map().len(), 9);\n    assert_eq!(tree.root(), \u0026expected_root);\n}\n\n#[test]\nfn test_zero_value_donot_change_root() {\n    let mut tree = SMT::default();\n    let key = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 1,\n    ]\n    .into();\n    let value = H256::zero();\n    tree.update(key, value).unwrap();\n    assert_eq!(tree.root(), \u0026H256::zero());\n    assert_eq!(tree.store().leaves_map().len(), 0);\n    assert_eq!(tree.store().branches_map().len(), 0);\n}\n\n#[test]\nfn test_zero_value_donot_change_store() {\n    let mut tree = SMT::default();\n    let key = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n    let value = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 1,\n    ]\n    .into();\n    tree.update(key, value).unwrap();\n    assert_ne!(tree.root(), \u0026H256::zero());\n    let root = *tree.root();\n    let store = tree.store().clone();\n\n    // insert a zero value leaf\n    let key = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 1,\n    ]\n    .into();\n    let value = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n    tree.update(key, value).unwrap();\n    assert_eq!(tree.root(), \u0026root);\n    assert_eq!(tree.store().leaves_map(), store.leaves_map());\n    assert_eq!(tree.store().branches_map(), store.branches_map());\n}\n\n#[test]\nfn test_delete_a_leaf() {\n    let mut tree = SMT::default();\n    let key = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n    let value = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 1,\n    ]\n    .into();\n    tree.update(key, value).unwrap();\n    assert_ne!(tree.root(), \u0026H256::zero());\n\n    let key = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 2,\n    ]\n    .into();\n\n    tree.update(key, value).unwrap();\n\n    let root = *tree.root();\n    let store = tree.store().clone();\n\n    // insert a leaf\n    let key = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 1,\n    ]\n    .into();\n    let value = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 1,\n    ]\n    .into();\n    tree.update(key, value).unwrap();\n    assert_ne!(tree.root(), \u0026root);\n\n    // delete a leaf\n    tree.update(key, H256::zero()).unwrap();\n    assert_eq!(tree.root(), \u0026root);\n    assert_eq!(tree.store().leaves_map(), store.leaves_map());\n    assert_eq!(tree.store().branches_map(), store.branches_map());\n}\n\n#[test]\nfn test_sibling_key_get() {\n    {\n        let mut tree = SMT::default();\n        let key = H256::from([\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]);\n        let value = H256::from([1u8; 32]);\n        tree.update(key, value).expect(\"update\");\n\n        let sibling_key = H256::from([\n            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]);\n        // get non exists sibling key should return zero value;\n        assert_eq!(H256::zero(), tree.get(\u0026sibling_key).unwrap());\n    }\n\n    {\n        let mut tree = SMT::default();\n        let key = H256::from([\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]);\n        let value = H256::from([1u8; 32]);\n        tree.update(key, value).expect(\"update\");\n\n        let sibling_key = H256::from([\n            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]);\n        let sibling_value = H256::from([2u8; 32]);\n        tree.update(sibling_key, sibling_value).expect(\"update\");\n        // get sibling key should return corresponding value\n        assert_eq!(value, tree.get(\u0026key).unwrap());\n        assert_eq!(sibling_value, tree.get(\u0026sibling_key).unwrap());\n    }\n}\n\nfn test_construct(key: H256, value: H256) {\n    // insert same value to sibling key will construct a different root\n\n    let mut tree = SMT::default();\n    tree.update(key, value).expect(\"update\");\n\n    let mut sibling_key = key;\n    if sibling_key.get_bit(0) {\n        sibling_key.clear_bit(0);\n    } else {\n        sibling_key.set_bit(0);\n    }\n    let mut tree2 = SMT::default();\n    tree2.update(sibling_key, value).expect(\"update\");\n    assert_ne!(tree.root(), tree2.root());\n}\n\nfn test_update(key: H256, value: H256) {\n    let mut tree = SMT::default();\n    tree.update(key, value).expect(\"update\");\n    assert_eq!(tree.get(\u0026key), Ok(value));\n}\n\n#[cfg(not(feature = \"trie\"))]\nfn test_update_tree_store(key: H256, value: H256, value2: H256) {\n    const EXPECTED_LEAVES_LEN: usize = 1;\n\n    let mut tree = SMT::default();\n    tree.update(key, value).expect(\"update\");\n    assert_eq!(tree.store().branches_map().len(), 256);\n    assert_eq!(tree.store().leaves_map().len(), EXPECTED_LEAVES_LEN);\n    tree.update(key, value2).expect(\"update\");\n    assert_eq!(tree.store().branches_map().len(), 256);\n    assert_eq!(tree.store().leaves_map().len(), EXPECTED_LEAVES_LEN);\n    assert_eq!(tree.get(\u0026key), Ok(value2));\n}\n\nfn test_merkle_proof(key: H256, value: H256) {\n    const EXPECTED_MERKLE_PATH_SIZE: usize = 1;\n\n    let mut tree = SMT::default();\n    tree.update(key, value).expect(\"update\");\n    if !tree.is_empty() {\n        let proof = tree.merkle_proof(vec![key]).expect(\"proof\");\n        let compiled_proof = proof.clone().compile(vec![key]).expect(\"compile proof\");\n        assert!(proof.merkle_path().len() \u003c EXPECTED_MERKLE_PATH_SIZE);\n        assert!(proof\n            .verify::\u003cBlake2bHasher\u003e(tree.root(), vec![(key, value)])\n            .expect(\"verify\"));\n        assert!(compiled_proof\n            .verify::\u003cBlake2bHasher\u003e(tree.root(), vec![(key, value)])\n            .expect(\"compiled verify\"));\n\n        let single_compiled_proof = compiled_proof\n            .extract_proof::\u003cBlake2bHasher\u003e(vec![(key, value, true)])\n            .expect(\"compute one proof\");\n        assert!(single_compiled_proof\n            .verify::\u003cBlake2bHasher\u003e(tree.root(), vec![(key, value)])\n            .expect(\"verify compiled proof\"));\n    }\n}\n\nfn new_smt(pairs: Vec\u003c(H256, H256)\u003e) -\u003e SMT {\n    let mut smt = SMT::default();\n    for (key, value) in pairs {\n        smt.update(key, value).unwrap();\n    }\n    smt\n}\n\nfn leaves(\n    min_leaves: usize,\n    max_leaves: usize,\n) -\u003e impl Strategy\u003cValue = (Vec\u003c(H256, H256)\u003e, usize)\u003e {\n    prop::collection::vec(\n        prop::array::uniform2(prop::array::uniform32(0u8..)),\n        min_leaves..=max_leaves,\n    )\n    .prop_flat_map(|mut pairs| {\n        pairs.dedup_by_key(|[k, _v]| *k);\n        let len = pairs.len();\n        (\n            Just(\n                pairs\n                    .into_iter()\n                    .map(|[k, v]| (k.into(), v.into()))\n                    .collect(),\n            ),\n            core::cmp::min(1, len)..=len,\n        )\n    })\n}\n\nfn leaves_bitmap(max_leaves_bitmap: usize) -\u003e impl Strategy\u003cValue = Vec\u003cH256\u003e\u003e {\n    prop::collection::vec(prop::array::uniform32(0u8..), max_leaves_bitmap).prop_flat_map(\n        |leaves_bitmap| Just(leaves_bitmap.into_iter().map(|item| item.into()).collect()),\n    )\n}\n\nfn merkle_proof(max_proof: usize) -\u003e impl Strategy\u003cValue = Vec\u003cMergeValue\u003e\u003e {\n    prop::collection::vec(prop::array::uniform32(0u8..), max_proof).prop_flat_map(|proof| {\n        Just(\n            proof\n                .into_iter()\n                .map(|item| MergeValue::from_h256(item.into()))\n                .collect(),\n        )\n    })\n}\n\nproptest! {\n    #[test]\n    fn test_h256(key: [u8; 32], key2: [u8; 32]) {\n        let mut list1: Vec\u003cH256\u003e = vec![key.into() , key2.into()];\n        let mut list2 = list1.clone();\n        // sort H256\n        list1.sort_unstable_by_key(|k| *k);\n        // sort by high bits to lower bits\n        list2.sort_unstable_by(|k1, k2| {\n            for i in (0u8..=255).rev() {\n                let b1 = if k1.get_bit(i) { 1 } else { 0 };\n                let b2 = if k2.get_bit(i) { 1 } else { 0 };\n                let o = b1.cmp(\u0026b2);\n                if o != std::cmp::Ordering::Equal {\n                    return o;\n                }\n            }\n            std::cmp::Ordering::Equal\n        });\n        assert_eq!(list1, list2);\n    }\n\n    #[test]\n    fn test_h256_copy_bits(start: u8) {\n        let one: H256 = [255u8; 32].into();\n        let target = one.copy_bits(start);\n        for i in start..=core::u8::MAX {\n            assert_eq!(one.get_bit(i), target.get_bit(i));\n        }\n        for i in 0..start {\n            assert!(!target.get_bit(i));\n        }\n    }\n\n    #[test]\n    fn test_random_update(key: [u8; 32], value: [u8;32]) {\n        test_update(key.into(), value.into());\n    }\n\n    #[cfg(not(feature = \"trie\"))]\n    #[test]\n    fn test_random_update_tree_store(key: [u8;32], value: [u8;32], value2: [u8;32]) {\n        test_update_tree_store(key.into(), value.into(), value2.into());\n    }\n\n    #[test]\n    fn test_random_construct(key: [u8;32], value: [u8;32]) {\n        test_construct(key.into(), value.into());\n    }\n\n    #[test]\n    fn test_random_merkle_proof(key: [u8; 32], value: [u8;32]) {\n        test_merkle_proof(key.into(), value.into());\n    }\n\n    #[test]\n    fn test_smt_single_leaf_small((pairs, _n) in leaves(1, 50)){\n        let smt = new_smt(pairs.clone());\n        for (k, v) in pairs {\n            let proof = smt.merkle_proof(vec![k]).expect(\"gen proof\");\n            let compiled_proof = proof.clone().compile(vec![k]).expect(\"compile proof\");\n            assert!(proof.verify::\u003cBlake2bHasher\u003e(smt.root(), vec![(k, v)]).expect(\"verify proof\"));\n            assert!(compiled_proof.verify::\u003cBlake2bHasher\u003e(smt.root(), vec![(k, v)]).expect(\"verify compiled proof\"));\n\n            let single_compiled_proof = compiled_proof\n                .extract_proof::\u003cBlake2bHasher\u003e(vec![(k, v, true)])\n                .expect(\"compute one proof\");\n            assert!(single_compiled_proof.verify::\u003cBlake2bHasher\u003e(smt.root(), vec![(k, v)]).expect(\"verify compiled one proof\"));\n        }\n    }\n\n    #[test]\n    fn test_smt_single_leaf_large((pairs, _n) in leaves(50, 100)){\n        let smt = new_smt(pairs.clone());\n        for (k, v) in pairs {\n            let proof = smt.merkle_proof(vec![k]).expect(\"gen proof\");\n            let compiled_proof = proof.clone().compile(vec![k]).expect(\"compile proof\");\n            assert!(proof.verify::\u003cBlake2bHasher\u003e(smt.root(), vec![(k, v)]).expect(\"verify proof\"));\n            assert!(compiled_proof.verify::\u003cBlake2bHasher\u003e(smt.root(), vec![(k, v)]).expect(\"verify compiled proof\"));\n\n            let single_compiled_proof = compiled_proof\n                .extract_proof::\u003cBlake2bHasher\u003e(vec![(k, v, true)])\n                .expect(\"compute one proof\");\n            assert!(single_compiled_proof.verify::\u003cBlake2bHasher\u003e(smt.root(), vec![(k, v)]).expect(\"verify compiled one proof\"));\n        }\n    }\n\n    #[test]\n    fn test_smt_multi_leaves_small((pairs, n) in leaves(1, 50)){\n        let smt = new_smt(pairs.clone());\n        let keys: Vec\u003c_\u003e = pairs.iter().take(n).map(|(k, _v)| *k).collect();\n        let proof = smt.merkle_proof(keys.clone()).expect(\"gen proof\");\n        let data: Vec\u003c(H256, H256)\u003e = pairs.into_iter().take(n).collect();\n        let compiled_proof = proof.clone().compile(keys).expect(\"compile proof\");\n        assert!(proof.verify::\u003cBlake2bHasher\u003e(smt.root(), data.clone()).expect(\"verify proof\"));\n        assert!(compiled_proof.verify::\u003cBlake2bHasher\u003e(smt.root(), data.clone()).expect(\"verify compiled proof\"));\n\n        test_sub_proof(\u0026compiled_proof, \u0026smt, \u0026data, 20);\n    }\n\n    #[test]\n    fn test_smt_multi_leaves_large((pairs, _n) in leaves(50, 100)){\n        let n = 20;\n        let smt = new_smt(pairs.clone());\n        let keys: Vec\u003c_\u003e = pairs.iter().take(n).map(|(k, _v)| *k).collect();\n        let proof = smt.merkle_proof(keys.clone()).expect(\"gen proof\");\n        let data: Vec\u003c(H256, H256)\u003e = pairs.into_iter().take(n).collect();\n        let compiled_proof = proof.clone().compile(keys).expect(\"compile proof\");\n        assert!(proof.verify::\u003cBlake2bHasher\u003e(smt.root(), data.clone()).expect(\"verify proof\"));\n        assert!(compiled_proof.verify::\u003cBlake2bHasher\u003e(smt.root(), data.clone()).expect(\"verify compiled proof\"));\n\n        test_sub_proof(\u0026compiled_proof, \u0026smt, \u0026data, 20);\n    }\n\n    #[test]\n    fn test_smt_non_exists_leaves((pairs, _n) in leaves(1, 20), (pairs2, _n2) in leaves(1, 5)){\n        if pairs.iter().all(|(k, _v)| pairs2.iter().all(|(k2, _v2)| k2 != k)) {\n            let smt = new_smt(pairs);\n            let non_exists_keys: Vec\u003c_\u003e = pairs2.into_iter().map(|(k, _v)|k).collect();\n            let proof = smt.merkle_proof(non_exists_keys.clone()).expect(\"gen proof\");\n            let data: Vec\u003c(H256, H256)\u003e = non_exists_keys.iter().map(|k|(*k, H256::zero())).collect();\n            let compiled_proof = proof.clone().compile(non_exists_keys).expect(\"compile proof\");\n            assert!(proof.verify::\u003cBlake2bHasher\u003e(smt.root(), data.clone()).expect(\"verify proof\"));\n            assert!(compiled_proof.verify::\u003cBlake2bHasher\u003e(smt.root(), data.clone()).expect(\"verify compiled proof\"));\n\n            test_sub_proof(\u0026compiled_proof, \u0026smt, \u0026data, 20);\n        }\n    }\n\n    #[test]\n    fn test_smt_non_existssss_leaves_mix((pairs, _n) in leaves(1, 20), (pairs2, _n2) in leaves(1, 5)){\n        if pairs.iter().all(|(k, _v)| pairs2.iter().all(|(k2, _v2)| k2 != k)) {\n            let smt = new_smt(pairs.clone());\n            let exists_keys: Vec\u003c_\u003e = pairs.into_iter().map(|(k, _v)|k).collect();\n            let non_exists_keys: Vec\u003c_\u003e = pairs2.into_iter().map(|(k, _v)|k).collect();\n            let exists_keys_len = std::cmp::max(exists_keys.len() / 2, 1);\n            let non_exists_keys_len = std::cmp::max(non_exists_keys.len() / 2, 1);\n            let mut keys: Vec\u003c_\u003e = exists_keys.into_iter().take(exists_keys_len).chain(non_exists_keys.into_iter().take(non_exists_keys_len)).collect();\n            keys.dedup();\n            let proof = smt.merkle_proof(keys.clone()).expect(\"gen proof\");\n            let data: Vec\u003c(H256, H256)\u003e = keys.iter().map(|k|(*k, smt.get(k).expect(\"get\"))).collect();\n            let compiled_proof = proof.clone().compile(keys.clone()).expect(\"compile proof\");\n            assert!(proof.verify::\u003cBlake2bHasher\u003e(smt.root(), data.clone()).expect(\"verify proof\"));\n            assert!(compiled_proof.verify::\u003cBlake2bHasher\u003e(smt.root(), data.clone()).expect(\"verify compiled proof\"));\n\n            test_sub_proof(\u0026compiled_proof, \u0026smt, \u0026data, 20);\n        }\n    }\n\n    #[test]\n    fn test_update_smt_tree_store((pairs, n) in leaves(1, 20)) {\n        let smt = new_smt(pairs.clone());\n        for (k, v) in pairs.into_iter().take(n) {\n            assert_eq!(smt.get(\u0026k), Ok(v));\n        }\n    }\n\n    #[test]\n    fn test_from_store((pairs, _n) in leaves(1, 20)) {\n        let smt = new_smt(pairs.clone());\n        let smt2 = SMT::new_with_store(smt.store().clone()).expect(\"from store\");\n        assert_eq!(smt.root(), smt2.root());\n    }\n\n    #[test]\n    fn test_smt_update_all((pairs, _n) in leaves(1, 20), (pairs2, _n2) in leaves(1, 10)){\n        let mut smt = new_smt(pairs.clone());\n        for (k, v) in pairs2.clone().into_iter() {\n            smt.update(k, v).expect(\"update\");\n        }\n        let mut smt2 = new_smt(pairs);\n        smt2.update_all(pairs2).expect(\"update all\");\n        assert_eq!(smt.root(), smt2.root());\n    }\n\n    #[test]\n    fn test_smt_random_insert_order((pairs, _n) in leaves(5, 50)){\n        let smt = new_smt(pairs.clone());\n        let root = *smt.root();\n\n        let mut pairs = pairs;\n        let mut rng = rand::thread_rng();\n        for _i in 0..5 {\n            // shuffle\n            pairs.shuffle(\u0026mut rng);\n\n            // insert to smt in random order\n            let smt2 = new_smt(pairs.clone());\n            assert_eq!(root, *smt2.root());\n\n            // check leaves\n            for (k, v) in \u0026pairs {\n                assert_eq!(\u0026smt2.get(k).unwrap(), v, \"key value must be consisted\");\n\n                let origin_proof = smt.merkle_proof(vec![*k]).unwrap();\n                let proof = smt2.merkle_proof(vec![*k]).unwrap();\n                assert_eq!(origin_proof, proof, \"merkle proof must be consisted\");\n\n                let calculated_root = proof.compute_root::\u003cBlake2bHasher\u003e(vec![(*k, *v)]).unwrap();\n                assert_eq!(root, calculated_root, \"root must be consisted\");\n            }\n        }\n    }\n\n    #[test]\n    fn test_smt_update_with_zero_values((pairs, _n) in leaves(5, 30)){\n        let mut rng = rand::thread_rng();\n        let len =  rng.gen_range(0..pairs.len());\n        let mut smt = new_smt(pairs[..len].to_vec());\n        let root = *smt.root();\n\n        // insert zero values\n        for (k, _v) in pairs[len..].iter() {\n            smt.update(*k, H256::zero()).unwrap();\n        }\n        // check root\n        let current_root = *smt.root();\n        assert_eq!(root, current_root);\n        // check inserted pairs\n        for (k, v) in pairs[..len].iter() {\n            let value = smt.get(k).unwrap();\n            assert_eq!(v, \u0026value);\n        }\n    }\n\n    #[test]\n    fn test_zero_value_should_delete_branch((pairs, _n) in leaves(5, 30)){\n        let mut smt = new_smt(pairs.clone());\n        for (k, _v) in pairs {\n            smt.update(k, H256::zero()).unwrap();\n        }\n        assert_eq!(0, smt.store().branches_map().len());\n    }\n\n    #[test]\n    fn test_smt_not_crash(\n        (leaves, _n) in leaves(0, 30),\n        leaves_bitmap in leaves_bitmap(30),\n        proof in merkle_proof(50)\n    ){\n        let proof = MerkleProof::new(leaves_bitmap, proof);\n        // test compute_root not crash\n        let _result = proof.clone().compute_root::\u003cBlake2bHasher\u003e(leaves.clone());\n        // test compile not crash\n        let _result = proof.compile(leaves.iter().map(|(k, _v)| *k).collect());\n    }\n\n    #[test]\n    fn test_try_crash_compiled_merkle_proof((leaves, _n) in leaves(0, 30)) {\n        // construct cases to crush compiled merkle proof\n        let case1 = [0x50, 0x48, 0x4C].to_vec();\n        let case2 = [0x48, 0x4C].to_vec();\n        let case3 = [0x4C, 0x50].to_vec();\n        let case4 = [0x4C, 0x48].to_vec();\n        let case5 = [0x50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                     0, 0, 0, 0].to_vec();\n        let case6 = [0x48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                     0, 0, 0, 0].to_vec();\n        let case7 = [0x4C, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                     0, 0, 0, 0].to_vec();\n\n        for case in [case1, case2, case3, case4, case5, case6, case7].iter() {\n            let proof = CompiledMerkleProof(case.to_vec());\n            // test compute root not crash\n            let _result = proof.compute_root::\u003cBlake2bHasher\u003e(leaves.clone());\n        }\n    }\n}\n\nfn parse_h256(s: \u0026str) -\u003e H256 {\n    let data = hex::decode(s).unwrap();\n    let mut inner = [0u8; 32];\n    inner.copy_from_slice(\u0026data);\n    H256::from(inner)\n}\n\n#[test]\nfn test_v0_2_broken_sample() {\n    let keys = vec![\n        \"0000000000000000000000000000000000000000000000000000000000000000\",\n        \"0000000000000000000000000000000000000000000000000000000000000002\",\n        \"0000000000000000000000000000000000000000000000000000000000000003\",\n        \"0000000000000000000000000000000000000000000000000000000000000004\",\n        \"0000000000000000000000000000000000000000000000000000000000000005\",\n        \"0000000000000000000000000000000000000000000000000000000000000006\",\n        \"000000000000000000000000000000000000000000000000000000000000000e\",\n        \"f652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f\",\n        \"f652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d40\",\n        \"5eff886ea0ce6ca488a3d6e336d6c0f75f46d19b42c06ce5ee98e42c96d256c7\",\n        \"6d5257204ebe7d88fd91ae87941cb2dd9d8062b64ae5a2bd2d28ec40b9fbf6df\",\n    ]\n    .into_iter()\n    .map(parse_h256);\n\n    let values = vec![\n        \"000000000000000000000000c8328aabcd9b9e8e64fbc566c4385c3bdeb219d7\",\n        \"000000000000000000000001c8328aabcd9b9e8e64fbc566c4385c3bdeb219d7\",\n        \"0000384000001c2000000e1000000708000002580000012c000000780000003c\",\n        \"000000000000000000093a80000546000002a300000151800000e10000007080\",\n        \"000000000000000000000000000000000000000000000000000000000000000f\",\n        \"0000000000000000000000000000000000000000000000000000000000000001\",\n        \"00000000000000000000000000000000000000000000000000071afd498d0000\",\n        \"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",\n        \"0000000000000000000000000000000000000000000000000000000000000000\",\n        \"0000000000000000000000000000000000000000000000000000000000000001\",\n        \"0000000000000000000000000000000000000000000000000000000000000000\",\n    ]\n    .into_iter()\n    .map(parse_h256);\n\n    let mut pairs = keys.zip(values).collect::\u003cVec\u003c_\u003e\u003e();\n    let smt = new_smt(pairs.clone());\n    let base_root = *smt.root();\n\n    // insert in random order\n    let mut rng = rand::thread_rng();\n    for _i in 0..10 {\n        pairs.shuffle(\u0026mut rng);\n        let smt = new_smt(pairs.clone());\n        let current_root = *smt.root();\n        assert_eq!(base_root, current_root);\n    }\n}\n\n#[test]\nfn test_v0_3_broken_sample() {\n    let k1 = [\n        0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ];\n    let v1 = [\n        108, 153, 9, 238, 15, 28, 173, 182, 146, 77, 52, 203, 162, 151, 125, 76, 55, 176, 192, 104,\n        170, 5, 193, 174, 137, 255, 169, 176, 132, 64, 199, 115,\n    ];\n    let k2 = [\n        1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ];\n    let v2 = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ];\n    let k3 = [\n        1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ];\n    let v3 = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ];\n\n    let mut smt = SMT::default();\n    // inserted keys shouldn't interfere with each other\n    assert_ne!(k1, k2);\n    assert_ne!(k2, k3);\n    assert_ne!(k1, k3);\n    smt.update(k1.into(), v1.into()).unwrap();\n    smt.update(k2.into(), v2.into()).unwrap();\n    smt.update(k3.into(), v3.into()).unwrap();\n    assert_eq!(smt.get(\u0026k1.into()).unwrap(), v1.into());\n}\n\n#[test]\nfn test_trie_broken_sample() {\n    let keys = vec![\n        \"f652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d40\",\n        \"5eff886ea0ce6ca488a3d6e336d6c0f75f46d19b42c06ce5ee98e42c96d256c7\",\n        \"6d5257204ebe7d88fd91ae87941cb2dd9d8062b64ae5a2bd2d28ec40b9fbf6df\",\n    ]\n    .into_iter()\n    .map(parse_h256);\n\n    let values = vec![\n        \"0000000000000000000000000000000000000000000000000000000000000001\",\n        \"0000000000000000000000000000000000000000000000000000000000000002\",\n        \"0000000000000000000000000000000000000000000000000000000000000003\",\n    ]\n    .into_iter()\n    .map(parse_h256);\n\n    let mut pairs = keys.zip(values).collect::\u003cVec\u003c_\u003e\u003e();\n    let smt = new_smt(pairs.clone());\n    let base_branches = smt.store().branches_map();\n    pairs.reverse();\n    let smt = new_smt(pairs.clone());\n    let current_branches = smt.store().branches_map();\n    assert_eq!(base_branches, current_branches);\n}\n\n#[test]\nfn test_trie_broken_sample_02() {\n    let key1: H256 = [\n        1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n    let key2: H256 = [\n        2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n    let key3: H256 = [\n        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n\n    let pairs = vec![\n        (key1, [1; 32].into()),\n        (key2, [2; 32].into()),\n        (key3, [0u8; 32].into()),\n    ];\n    let smt = new_smt(pairs);\n    let kv_state: [([u8; 32], [u8; 32]); 1] = [(\n        [\n            3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ],\n        [0; 32],\n    )];\n\n    for (k, v) in kv_state {\n        assert_eq!(smt.get(\u0026k.into()).unwrap(), v.into());\n    }\n\n    let keys: Vec\u003cH256\u003e = kv_state.iter().map(|kv| kv.0.into()).collect();\n\n    let proof = smt\n        .merkle_proof(keys.clone())\n        .unwrap()\n        .compile(keys)\n        .unwrap();\n\n    let root1 = proof\n        .compute_root::\u003cBlake2bHasher\u003e(\n            kv_state\n                .iter()\n                .map(|(k, v)| (k.clone().into(), v.clone().into()))\n                .collect(),\n        )\n        .unwrap();\n    assert_eq!(smt.root(), \u0026root1);\n}\n\n#[test]\nfn test_trie_broken_sample_03() {\n    let mut smt = SMT::default();\n    smt.update(\n        [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]\n        .into(),\n        [\n            231, 17, 197, 236, 8, 0, 141, 194, 15, 253, 234, 189, 224, 53, 255, 173, 117, 8, 221,\n            5, 34, 5, 198, 250, 99, 32, 229, 13, 222, 40, 203, 90,\n        ]\n        .into(),\n    )\n    .unwrap();\n    smt.update(\n        [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]\n        .into(),\n        [\n            231, 17, 197, 236, 8, 0, 141, 194, 15, 253, 234, 189, 224, 53, 255, 173, 117, 8, 221,\n            5, 34, 5, 198, 250, 99, 32, 229, 13, 222, 40, 203, 90,\n        ]\n        .into(),\n    )\n    .unwrap();\n    smt.update(\n        [\n            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]\n        .into(),\n        [\n            105, 112, 48, 175, 83, 217, 158, 108, 243, 136, 9, 21, 192, 91, 211, 190, 218, 240, 89,\n            241, 63, 137, 128, 133, 65, 169, 51, 33, 49, 123, 118, 132,\n        ]\n        .into(),\n    )\n    .unwrap();\n    smt.update(\n        [\n            2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]\n        .into(),\n        [\n            189, 150, 22, 8, 143, 248, 180, 169, 68, 195, 31, 28, 34, 180, 182, 223, 195, 37, 117,\n            197, 229, 144, 229, 64, 230, 250, 21, 205, 225, 32, 135, 195,\n        ]\n        .into(),\n    )\n    .unwrap();\n    smt.update(\n        [\n            3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]\n        .into(),\n        [\n            153, 75, 31, 235, 146, 228, 224, 228, 237, 250, 34, 227, 139, 8, 213, 118, 25, 114, 82,\n            242, 215, 172, 184, 100, 205, 85, 47, 116, 140, 238, 175, 190,\n        ]\n        .into(),\n    )\n    .unwrap();\n    smt.update(\n        [\n            4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]\n        .into(),\n        [\n            242, 174, 6, 108, 205, 74, 137, 57, 15, 248, 35, 35, 255, 58, 93, 74, 183, 47, 194, 40,\n            134, 3, 215, 100, 80, 51, 28, 251, 96, 19, 201, 170,\n        ]\n        .into(),\n    )\n    .unwrap();\n    smt.update(\n        [\n            5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]\n        .into(),\n        [\n            88, 83, 226, 107, 201, 255, 207, 189, 197, 145, 113, 95, 209, 238, 110, 9, 82, 215,\n            232, 183, 203, 220, 194, 167, 21, 189, 239, 238, 178, 149, 153, 44,\n        ]\n        .into(),\n    )\n    .unwrap();\n    smt.update(\n        [\n            6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]\n        .into(),\n        [\n            80, 177, 52, 81, 182, 121, 67, 120, 77, 19, 201, 42, 75, 136, 19, 238, 112, 23, 204,\n            103, 20, 157, 53, 235, 80, 70, 126, 79, 9, 35, 11, 158,\n        ]\n        .into(),\n    )\n    .unwrap();\n    let key7 = H256::from([\n        7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]);\n    let v7 = H256::from([\n        103, 245, 93, 107, 47, 213, 28, 173, 216, 92, 109, 17, 151, 57, 101, 4, 44, 145, 116, 215,\n        185, 218, 144, 244, 131, 160, 148, 58, 247, 226, 240, 55,\n    ]);\n    let proof = smt\n        .merkle_proof(vec![key7])\n        .unwrap()\n        .compile(vec![key7])\n        .unwrap();\n    // Compute root with different value than actually in smt.\n    let root = proof\n        .compute_root::\u003cBlake2bHasher\u003e(vec![(key7, v7)])\n        .unwrap();\n    // Compute root by updating smt.\n    smt.update(key7, v7).unwrap();\n    // Expect them to be the same.\n    assert_eq!(*smt.root(), root);\n}\n\n#[test]\nfn test_replay_to_pass_proof() {\n    let key1: H256 = [\n        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n    let key2: H256 = [\n        2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n    let key3: H256 = [\n        3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n    let key4: H256 = [\n        4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n\n    let existing: H256 = [\n        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n    let non_existing: H256 = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0,\n    ]\n    .into();\n    let other_value: H256 = [\n        0, 0, 0xff, 0, 0, 0, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0xff,\n    ]\n    .into();\n    let pairs = vec![\n        (key1, existing),\n        (key2, non_existing),\n        (key3, non_existing),\n        (key4, non_existing),\n    ];\n    let smt = new_smt(pairs);\n    let leaf_a_bl = vec![(key1, H256::zero())];\n    let leaf_c = vec![(key3, non_existing)];\n    let leaf_other = vec![(key3, other_value)];\n    let proofc = smt\n        .merkle_proof(leaf_c.clone().into_iter().map(|(k, _)| k).collect())\n        .expect(\"gen proof\");\n    let compiled_proof = proofc.clone().compile(vec![key3]).expect(\"compile proof\");\n\n    println!(\"verify ok case\");\n    assert!(proofc\n        .clone()\n        .verify::\u003cBlake2bHasher\u003e(smt.root(), leaf_c.clone())\n        .expect(\"verify\"));\n    println!(\"verify not ok case\");\n    assert!(!proofc\n        .clone()\n        .verify::\u003cBlake2bHasher\u003e(smt.root(), leaf_other)\n        .expect(\"verify\"));\n\n    println!(\"merkle proof, leaf is faked\");\n    assert!(!proofc\n        .verify::\u003cBlake2bHasher\u003e(smt.root(), leaf_a_bl.clone())\n        .expect(\"verify\"));\n\n    println!(\"compiled merkle proof, leaf is faked\");\n    assert!(!compiled_proof\n        .verify::\u003cBlake2bHasher\u003e(smt.root(), leaf_a_bl)\n        .expect(\"verify compiled proof\"));\n\n    test_sub_proof(\u0026compiled_proof, \u0026smt, \u0026leaf_c, 20);\n}\n\n#[test]\nfn test_sibling_leaf() {\n    fn gen_rand_h256() -\u003e H256 {\n        let mut rng = rand::thread_rng();\n        let rand_data: [u8; 32] = rng.gen();\n        H256::from(rand_data)\n    }\n    let rand_key = gen_rand_h256();\n    let mut sibling_key = rand_key;\n    if rand_key.is_right(0) {\n        sibling_key.clear_bit(0);\n    } else {\n        sibling_key.set_bit(0);\n    }\n    let pairs = vec![(rand_key, gen_rand_h256()), (sibling_key, gen_rand_h256())];\n    let keys = vec![rand_key, sibling_key];\n    let smt = new_smt(pairs.clone());\n    let proof = smt.merkle_proof(keys).expect(\"gen proof\");\n    assert!(proof\n        .verify::\u003cBlake2bHasher\u003e(smt.root(), pairs)\n        .expect(\"verify\"));\n}\n\n#[test]\nfn test_max_stack_size() {\n    fn gen_h256(height: u8) -\u003e H256 {\n        // The key path is first go right `256 - height` times then go left `height` times.\n        let mut key = H256::zero();\n        for h in height..=255 {\n            key.set_bit(h);\n        }\n        key\n    }\n    let mut pairs: Vec\u003c_\u003e = (0..=255)\n        .map(|height| (gen_h256(height), gen_h256(1)))\n        .collect();\n    // Most left key\n    pairs.push((H256::zero(), gen_h256(1)));\n    {\n        // A pair of sibling keys in between\n        let mut left_key = H256::zero();\n        for h in 12..56 {\n            left_key.set_bit(h);\n        }\n        let mut right_key = left_key;\n        right_key.set_bit(0);\n        pairs.push((left_key, gen_h256(1)));\n        pairs.push((right_key, gen_h256(1)));\n    }\n\n    let keys: Vec\u003c_\u003e = pairs.iter().map(|(key, _)| *key).collect();\n    let smt = new_smt(pairs.clone());\n    let proof = smt.merkle_proof(keys.clone()).expect(\"gen proof\");\n    let compiled_proof = proof.compile(keys).expect(\"compile proof\");\n\n    assert!(compiled_proof\n        .verify::\u003cBlake2bHasher\u003e(smt.root(), pairs.clone())\n        .expect(\"verify\"));\n\n    test_sub_proof(\u0026compiled_proof, \u0026smt, \u0026pairs, 20);\n}\n\n#[test]\nfn test_simple_non_exists_sub_proof() {\n    let pairs = vec![(\n        H256::from([\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]),\n        H256::from([\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0,\n        ]),\n    )];\n    let pairs2 = vec![(\n        H256::from([\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 1,\n        ]),\n        H256::from([\n            120, 94, 121, 42, 43, 185, 121, 215, 19, 188, 112, 111, 16, 124, 59, 43, 189, 203, 55,\n            192, 159, 233, 56, 217, 126, 150, 113, 232, 27, 66, 255, 10,\n        ]),\n    )];\n    let smt = new_smt(pairs.clone());\n    let exists_keys: Vec\u003c_\u003e = pairs.into_iter().map(|(k, _v)| k).collect();\n    let non_exists_keys: Vec\u003c_\u003e = pairs2.into_iter().map(|(k, _v)| k).collect();\n    let exists_keys_len = std::cmp::max(exists_keys.len() / 2, 1);\n    let non_exists_keys_len = std::cmp::max(non_exists_keys.len() / 2, 1);\n    let mut keys: Vec\u003c_\u003e = exists_keys\n        .into_iter()\n        .take(exists_keys_len)\n        .chain(non_exists_keys.into_iter().take(non_exists_keys_len))\n        .collect();\n    keys.dedup();\n    let proof = smt.merkle_proof(keys.clone()).expect(\"gen proof\");\n    let data: Vec\u003c(H256, H256)\u003e = keys\n        .iter()\n        .map(|k| (*k, smt.get(k).expect(\"get\")))\n        .collect();\n    let compiled_proof = proof.compile(keys.clone()).expect(\"compile proof\");\n    test_sub_proof(\u0026compiled_proof, \u0026smt, \u0026data, 20);\n}\n\nfn test_sub_proof(\n    compiled_proof: \u0026CompiledMerkleProof,\n    smt: \u0026SMT,\n    data: \u0026[(H256, H256)],\n    test_multi_round: usize,\n) {\n    let mut keys = data.iter().map(|(k, _v)| *k).collect::\u003cVec\u003c_\u003e\u003e();\n\n    // test sub proof with single leaf\n    for key in \u0026keys {\n        let single_compiled_proof = compiled_proof\n            .extract_proof::\u003cBlake2bHasher\u003e(data.iter().map(|(k, v)| (*k, *v, k == key)).collect())\n            .expect(\"compiled one proof\");\n        let expected_compiled_proof = smt\n            .merkle_proof(vec![*key])\n            .unwrap()\n            .compile(vec![*key])\n            .unwrap();\n        assert_eq!(expected_compiled_proof.0, single_compiled_proof.0);\n\n        let value = smt.get(key).unwrap();\n        assert!(single_compiled_proof\n            .verify::\u003cBlake2bHasher\u003e(smt.root(), vec![(*key, value)])\n            .expect(\"verify compiled one proof\"));\n    }\n\n    if data.len() \u003c 2 {\n        return;\n    }\n\n    // test sub proof with multiple leaves\n    let mut rng = rand::thread_rng();\n    for _ in 0..test_multi_round {\n        keys.shuffle(\u0026mut rng);\n        let selected_number = rng.gen_range(2..=keys.len());\n        let selected_pairs: HashMap\u003c_, _\u003e = keys\n            .iter()\n            .take(selected_number)\n            .map(|key| (*key, smt.get(key).unwrap()))\n            .collect();\n\n        let sub_proof = compiled_proof\n            .extract_proof::\u003cBlake2bHasher\u003e(\n                data.iter()\n                    .map(|(k, v)| (*k, *v, selected_pairs.contains_key(k)))\n                    .collect(),\n            )\n            .expect(\"compiled sub proof\");\n        let selected_keys = selected_pairs.keys().cloned().collect::\u003cVec\u003c_\u003e\u003e();\n        let expected_compiled_proof = smt\n            .merkle_proof(selected_keys.clone())\n            .unwrap()\n            .compile(selected_keys)\n            .unwrap();\n        assert_eq!(expected_compiled_proof.0, sub_proof.0);\n\n        assert!(sub_proof\n            .verify::\u003cBlake2bHasher\u003e(smt.root(), selected_pairs.into_iter().collect())\n            .expect(\"verify compiled sub proof\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","traits.rs"],"content":"use crate::{\n    error::Error,\n    tree::{BranchKey, BranchNode},\n    H256,\n};\n\n/// Trait for customize hash function\npub trait Hasher {\n    fn write_h256(\u0026mut self, h: \u0026H256);\n    fn write_byte(\u0026mut self, b: u8);\n    fn finish(self) -\u003e H256;\n}\n\n/// Trait for define value structures\npub trait Value {\n    fn to_h256(\u0026self) -\u003e H256;\n    fn zero() -\u003e Self;\n}\n\nimpl Value for H256 {\n    fn to_h256(\u0026self) -\u003e H256 {\n        *self\n    }\n    fn zero() -\u003e Self {\n        H256::zero()\n    }\n}\n\n/// Traits for customize backend storage\npub trait StoreReadOps\u003cV\u003e {\n    fn get_branch(\u0026self, branch_key: \u0026BranchKey) -\u003e Result\u003cOption\u003cBranchNode\u003e, Error\u003e;\n    fn get_leaf(\u0026self, leaf_key: \u0026H256) -\u003e Result\u003cOption\u003cV\u003e, Error\u003e;\n}\n\npub trait StoreWriteOps\u003cV\u003e {\n    fn insert_branch(\u0026mut self, node_key: BranchKey, branch: BranchNode) -\u003e Result\u003c(), Error\u003e;\n    fn insert_leaf(\u0026mut self, leaf_key: H256, leaf: V) -\u003e Result\u003c(), Error\u003e;\n    fn remove_branch(\u0026mut self, node_key: \u0026BranchKey) -\u003e Result\u003c(), Error\u003e;\n    fn remove_leaf(\u0026mut self, leaf_key: \u0026H256) -\u003e Result\u003c(), Error\u003e;\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","tree.rs"],"content":"use crate::{\n    collections::VecDeque,\n    error::{Error, Result},\n    merge::{merge, MergeValue},\n    merkle_proof::MerkleProof,\n    traits::{Hasher, StoreReadOps, StoreWriteOps, Value},\n    vec::Vec,\n    H256, MAX_STACK_SIZE,\n};\nuse codec::{Decode, Encode};\nuse core::{cmp::Ordering, marker::PhantomData};\n/// The branch key\n#[derive(Debug, Clone, Eq, PartialEq, Hash, Encode, Decode)]\npub struct BranchKey {\n    pub height: u8,\n    pub node_key: H256,\n}\n\nimpl BranchKey {\n    pub fn new(height: u8, node_key: H256) -\u003e BranchKey {\n        BranchKey { height, node_key }\n    }\n}\n\nimpl PartialOrd for BranchKey {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        Some(self.cmp(other))\n    }\n}\nimpl Ord for BranchKey {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n        match self.height.cmp(\u0026other.height) {\n            Ordering::Equal =\u003e self.node_key.cmp(\u0026other.node_key),\n            ordering =\u003e ordering,\n        }\n    }\n}\n\n/// A branch in the SMT\n#[derive(Debug, Eq, PartialEq, Clone, Encode, Decode)]\npub struct BranchNode {\n    pub left: MergeValue,\n    pub right: MergeValue,\n}\n\nimpl BranchNode {\n    /// Create a new empty branch\n    pub fn new_empty() -\u003e BranchNode {\n        BranchNode {\n            left: MergeValue::zero(),\n            right: MergeValue::zero(),\n        }\n    }\n\n    /// Determine whether a node did not store any value\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.left.is_zero() \u0026\u0026 self.right.is_zero()\n    }\n}\n\n/// Sparse merkle tree\n#[derive(Default, Debug)]\npub struct SparseMerkleTree\u003cH, V, S\u003e {\n    store: S,\n    root: H256,\n    phantom: PhantomData\u003c(H, V)\u003e,\n}\n\nimpl\u003cH, V, S\u003e SparseMerkleTree\u003cH, V, S\u003e {\n    /// Build a merkle tree from root and store\n    pub fn new(root: H256, store: S) -\u003e SparseMerkleTree\u003cH, V, S\u003e {\n        SparseMerkleTree {\n            root,\n            store,\n            phantom: PhantomData,\n        }\n    }\n\n    /// Merkle root\n    pub fn root(\u0026self) -\u003e \u0026H256 {\n        \u0026self.root\n    }\n\n    /// Check empty of the tree\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.root.is_zero()\n    }\n\n    /// Destroy current tree and retake store\n    pub fn take_store(self) -\u003e S {\n        self.store\n    }\n\n    /// Get backend store\n    pub fn store(\u0026self) -\u003e \u0026S {\n        \u0026self.store\n    }\n\n    /// Get mutable backend store\n    pub fn store_mut(\u0026mut self) -\u003e \u0026mut S {\n        \u0026mut self.store\n    }\n}\n\nimpl\u003cH: Hasher + Default, V, S: StoreReadOps\u003cV\u003e\u003e SparseMerkleTree\u003cH, V, S\u003e {\n    /// Build a merkle tree from store, the root will be calculated automatically\n    pub fn new_with_store(store: S) -\u003e Result\u003cSparseMerkleTree\u003cH, V, S\u003e\u003e {\n        let root_branch_key = BranchKey::new(core::u8::MAX, H256::zero());\n        store\n            .get_branch(\u0026root_branch_key)\n            .map(|branch_node| {\n                branch_node\n                    .map(|n| {\n                        merge::\u003cH\u003e(core::u8::MAX, \u0026H256::zero(), \u0026n.left, \u0026n.right).hash::\u003cH\u003e()\n                    })\n                    .unwrap_or_default()\n            })\n            .map(|root| SparseMerkleTree::new(root, store))\n    }\n}\n\nimpl\u003cH: Hasher + Default, V: Value, S: StoreReadOps\u003cV\u003e + StoreWriteOps\u003cV\u003e\u003e\n    SparseMerkleTree\u003cH, V, S\u003e\n{\n    /// Update a leaf, return new merkle root\n    /// set to zero value to delete a key\n    pub fn update(\u0026mut self, key: H256, value: V) -\u003e Result\u003c\u0026H256\u003e {\n        // compute and store new leaf\n        let node = MergeValue::from_h256(value.to_h256());\n        // notice when value is zero the leaf is deleted, so we do not need to store it\n        if !node.is_zero() {\n            self.store.insert_leaf(key, value)?;\n        } else {\n            self.store.remove_leaf(\u0026key)?;\n        }\n\n        // recompute the tree from bottom to top\n        let mut current_key = key;\n        let mut current_node = node;\n        for height in 0..=core::u8::MAX {\n            let parent_key = current_key.parent_path(height);\n            let parent_branch_key = BranchKey::new(height, parent_key);\n            let (left, right) =\n                if let Some(parent_branch) = self.store.get_branch(\u0026parent_branch_key)? {\n                    if current_key.is_right(height) {\n                        (parent_branch.left, current_node)\n                    } else {\n                        (current_node, parent_branch.right)\n                    }\n                } else if current_key.is_right(height) {\n                    (MergeValue::zero(), current_node)\n                } else {\n                    (current_node, MergeValue::zero())\n                };\n\n            if !left.is_zero() || !right.is_zero() {\n                // insert or update branch\n                self.store.insert_branch(\n                    parent_branch_key,\n                    BranchNode {\n                        left: left.clone(),\n                        right: right.clone(),\n                    },\n                )?;\n            } else {\n                // remove empty branch\n                self.store.remove_branch(\u0026parent_branch_key)?;\n            }\n            // prepare for next round\n            current_key = parent_key;\n            current_node = merge::\u003cH\u003e(height, \u0026parent_key, \u0026left, \u0026right);\n        }\n\n        self.root = current_node.hash::\u003cH\u003e();\n        Ok(\u0026self.root)\n    }\n\n    /// Update multiple leaves at once\n    pub fn update_all(\u0026mut self, mut leaves: Vec\u003c(H256, V)\u003e) -\u003e Result\u003c\u0026H256\u003e {\n        // Dedup(only keep the last of each key) and sort leaves\n        leaves.reverse();\n        leaves.sort_by_key(|(a, _)| *a);\n        leaves.dedup_by_key(|(a, _)| *a);\n\n        let mut nodes = leaves\n            .into_iter()\n            .map(|(k, v)| {\n                let value = MergeValue::from_h256(v.to_h256());\n                if !value.is_zero() {\n                    self.store.insert_leaf(k, v)\n                } else {\n                    self.store.remove_leaf(\u0026k)\n                }\n                .map(|_| (k, value, 0))\n            })\n            .collect::\u003cResult\u003cVecDeque\u003c(H256, MergeValue, u8)\u003e\u003e\u003e()?;\n\n        while let Some((current_key, current_merge_value, height)) = nodes.pop_front() {\n            let parent_key = current_key.parent_path(height);\n            let parent_branch_key = BranchKey::new(height, parent_key);\n\n            // Test for neighbors\n            let mut right = None;\n            if !current_key.is_right(height) \u0026\u0026 !nodes.is_empty() {\n                let (neighbor_key, _, neighbor_height) = nodes.front().expect(\"nodes is not empty\");\n                if neighbor_height.eq(\u0026height) {\n                    let mut right_key = current_key;\n                    right_key.set_bit(height);\n                    if neighbor_key.eq(\u0026right_key) {\n                        let (_, neighbor_value, _) = nodes.pop_front().expect(\"nodes is not empty\");\n                        right = Some(neighbor_value);\n                    }\n                }\n            }\n\n            let (left, right) = if let Some(right_merge_value) = right {\n                (current_merge_value, right_merge_value)\n            } else {\n                // In case neighbor is not available, fetch from store\n                if let Some(parent_branch) = self.store.get_branch(\u0026parent_branch_key)? {\n                    if current_key.is_right(height) {\n                        (parent_branch.left, current_merge_value)\n                    } else {\n                        (current_merge_value, parent_branch.right)\n                    }\n                } else if current_key.is_right(height) {\n                    (MergeValue::zero(), current_merge_value)\n                } else {\n                    (current_merge_value, MergeValue::zero())\n                }\n            };\n\n            if !left.is_zero() || !right.is_zero() {\n                self.store.insert_branch(\n                    parent_branch_key,\n                    BranchNode {\n                        left: left.clone(),\n                        right: right.clone(),\n                    },\n                )?;\n            } else {\n                self.store.remove_branch(\u0026parent_branch_key)?;\n            }\n            if height == core::u8::MAX {\n                self.root = merge::\u003cH\u003e(height, \u0026parent_key, \u0026left, \u0026right).hash::\u003cH\u003e();\n                break;\n            } else {\n                nodes.push_back((\n                    parent_key,\n                    merge::\u003cH\u003e(height, \u0026parent_key, \u0026left, \u0026right),\n                    height + 1,\n                ));\n            }\n        }\n\n        Ok(\u0026self.root)\n    }\n}\n\nimpl\u003cH: Hasher + Default, V: Value, S: StoreReadOps\u003cV\u003e\u003e SparseMerkleTree\u003cH, V, S\u003e {\n    /// Get value of a leaf\n    /// return zero value if leaf not exists\n    pub fn get(\u0026self, key: \u0026H256) -\u003e Result\u003cV\u003e {\n        if self.is_empty() {\n            return Ok(V::zero());\n        }\n        Ok(self.store.get_leaf(key)?.unwrap_or_else(V::zero))\n    }\n\n    /// Generate merkle proof\n    pub fn merkle_proof(\u0026self, mut keys: Vec\u003cH256\u003e) -\u003e Result\u003cMerkleProof\u003e {\n        if keys.is_empty() {\n            return Err(Error::EmptyKeys);\n        }\n\n        // sort keys\n        keys.sort_unstable();\n\n        // Collect leaf bitmaps\n        let mut leaves_bitmap: Vec\u003cH256\u003e = Default::default();\n        for current_key in \u0026keys {\n            let mut bitmap = H256::zero();\n            for height in 0..=core::u8::MAX {\n                let parent_key = current_key.parent_path(height);\n                let parent_branch_key = BranchKey::new(height, parent_key);\n                if let Some(parent_branch) = self.store.get_branch(\u0026parent_branch_key)? {\n                    let sibling = if current_key.is_right(height) {\n                        parent_branch.left\n                    } else {\n                        parent_branch.right\n                    };\n                    if !sibling.is_zero() {\n                        bitmap.set_bit(height);\n                    }\n                } else {\n                    // The key is not in the tree (support non-inclusion proof)\n                }\n            }\n            leaves_bitmap.push(bitmap);\n        }\n\n        let mut proof: Vec\u003cMergeValue\u003e = Default::default();\n        let mut stack_fork_height = [0u8; MAX_STACK_SIZE]; // store fork height\n        let mut stack_top = 0;\n        let mut leaf_index = 0;\n        while leaf_index \u003c keys.len() {\n            let leaf_key = keys[leaf_index];\n            let fork_height = if leaf_index + 1 \u003c keys.len() {\n                leaf_key.fork_height(\u0026keys[leaf_index + 1])\n            } else {\n                core::u8::MAX\n            };\n            for height in 0..=fork_height {\n                if height == fork_height \u0026\u0026 leaf_index + 1 \u003c keys.len() {\n                    // If it's not final round, we don't need to merge to root (height=255)\n                    break;\n                }\n                let parent_key = leaf_key.parent_path(height);\n                let is_right = leaf_key.is_right(height);\n\n                // has non-zero sibling\n                if stack_top \u003e 0 \u0026\u0026 stack_fork_height[stack_top - 1] == height {\n                    stack_top -= 1;\n                } else if leaves_bitmap[leaf_index].get_bit(height) {\n                    let parent_branch_key = BranchKey::new(height, parent_key);\n                    if let Some(parent_branch) = self.store.get_branch(\u0026parent_branch_key)? {\n                        let sibling = if is_right {\n                            parent_branch.left\n                        } else {\n                            parent_branch.right\n                        };\n                        if !sibling.is_zero() {\n                            proof.push(sibling);\n                        } else {\n                            unreachable!();\n                        }\n                    } else {\n                        // The key is not in the tree (support non-inclusion proof)\n                    }\n                }\n            }\n            debug_assert!(stack_top \u003c MAX_STACK_SIZE);\n            stack_fork_height[stack_top] = fork_height;\n            stack_top += 1;\n            leaf_index += 1;\n        }\n        assert_eq!(stack_top, 1);\n        Ok(MerkleProof::new(leaves_bitmap, proof))\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":58667}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":363}},{"line":80,"address":[],"length":0,"stats":{"Line":123}},{"line":81,"address":[],"length":0,"stats":{"Line":123}},{"line":85,"address":[],"length":0,"stats":{"Line":118}},{"line":86,"address":[],"length":0,"stats":{"Line":118}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":363}},{"line":108,"address":[],"length":0,"stats":{"Line":363}},{"line":109,"address":[],"length":0,"stats":{"Line":363}},{"line":110,"address":[],"length":0,"stats":{"Line":363}},{"line":111,"address":[],"length":0,"stats":{"Line":726}},{"line":112,"address":[],"length":0,"stats":{"Line":363}},{"line":113,"address":[],"length":0,"stats":{"Line":692}},{"line":114,"address":[],"length":0,"stats":{"Line":329}},{"line":116,"address":[],"length":0,"stats":{"Line":363}},{"line":118,"address":[],"length":0,"stats":{"Line":1089}},{"line":127,"address":[],"length":0,"stats":{"Line":113}},{"line":129,"address":[],"length":0,"stats":{"Line":113}},{"line":131,"address":[],"length":0,"stats":{"Line":113}},{"line":132,"address":[],"length":0,"stats":{"Line":109}},{"line":134,"address":[],"length":0,"stats":{"Line":4}},{"line":138,"address":[],"length":0,"stats":{"Line":113}},{"line":139,"address":[],"length":0,"stats":{"Line":113}},{"line":140,"address":[],"length":0,"stats":{"Line":57969}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":28928}},{"line":144,"address":[],"length":0,"stats":{"Line":1174}},{"line":145,"address":[],"length":0,"stats":{"Line":1174}},{"line":146,"address":[],"length":0,"stats":{"Line":593}},{"line":148,"address":[],"length":0,"stats":{"Line":581}},{"line":150,"address":[],"length":0,"stats":{"Line":27754}},{"line":151,"address":[],"length":0,"stats":{"Line":13880}},{"line":153,"address":[],"length":0,"stats":{"Line":13874}},{"line":156,"address":[],"length":0,"stats":{"Line":14730}},{"line":158,"address":[],"length":0,"stats":{"Line":27904}},{"line":159,"address":[],"length":0,"stats":{"Line":27904}},{"line":160,"address":[],"length":0,"stats":{"Line":27904}},{"line":161,"address":[],"length":0,"stats":{"Line":27904}},{"line":162,"address":[],"length":0,"stats":{"Line":27904}},{"line":167,"address":[],"length":0,"stats":{"Line":1024}},{"line":170,"address":[],"length":0,"stats":{"Line":28928}},{"line":171,"address":[],"length":0,"stats":{"Line":28928}},{"line":174,"address":[],"length":0,"stats":{"Line":113}},{"line":175,"address":[],"length":0,"stats":{"Line":113}},{"line":179,"address":[],"length":0,"stats":{"Line":3}},{"line":181,"address":[],"length":0,"stats":{"Line":3}},{"line":182,"address":[],"length":0,"stats":{"Line":6}},{"line":183,"address":[],"length":0,"stats":{"Line":6}},{"line":185,"address":[],"length":0,"stats":{"Line":6}},{"line":187,"address":[],"length":0,"stats":{"Line":6}},{"line":188,"address":[],"length":0,"stats":{"Line":3}},{"line":189,"address":[],"length":0,"stats":{"Line":3}},{"line":190,"address":[],"length":0,"stats":{"Line":3}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":9}},{"line":198,"address":[],"length":0,"stats":{"Line":1536}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":366}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":1536}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":1024}},{"line":221,"address":[],"length":0,"stats":{"Line":256}},{"line":222,"address":[],"length":0,"stats":{"Line":134}},{"line":224,"address":[],"length":0,"stats":{"Line":122}},{"line":226,"address":[],"length":0,"stats":{"Line":512}},{"line":227,"address":[],"length":0,"stats":{"Line":268}},{"line":229,"address":[],"length":0,"stats":{"Line":244}},{"line":233,"address":[],"length":0,"stats":{"Line":402}},{"line":234,"address":[],"length":0,"stats":{"Line":768}},{"line":235,"address":[],"length":0,"stats":{"Line":768}},{"line":236,"address":[],"length":0,"stats":{"Line":768}},{"line":237,"address":[],"length":0,"stats":{"Line":768}},{"line":238,"address":[],"length":0,"stats":{"Line":768}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":768}},{"line":245,"address":[],"length":0,"stats":{"Line":3}},{"line":246,"address":[],"length":0,"stats":{"Line":3}},{"line":248,"address":[],"length":0,"stats":{"Line":765}},{"line":249,"address":[],"length":0,"stats":{"Line":765}},{"line":250,"address":[],"length":0,"stats":{"Line":765}},{"line":251,"address":[],"length":0,"stats":{"Line":765}},{"line":256,"address":[],"length":0,"stats":{"Line":3}},{"line":263,"address":[],"length":0,"stats":{"Line":118}},{"line":264,"address":[],"length":0,"stats":{"Line":118}},{"line":265,"address":[],"length":0,"stats":{"Line":8}},{"line":267,"address":[],"length":0,"stats":{"Line":220}},{"line":271,"address":[],"length":0,"stats":{"Line":109}},{"line":272,"address":[],"length":0,"stats":{"Line":109}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":109}},{"line":280,"address":[],"length":0,"stats":{"Line":109}},{"line":281,"address":[],"length":0,"stats":{"Line":327}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":55917}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":26892}},{"line":287,"address":[],"length":0,"stats":{"Line":53784}},{"line":288,"address":[],"length":0,"stats":{"Line":13456}},{"line":290,"address":[],"length":0,"stats":{"Line":13436}},{"line":292,"address":[],"length":0,"stats":{"Line":27594}},{"line":293,"address":[],"length":0,"stats":{"Line":702}},{"line":299,"address":[],"length":0,"stats":{"Line":109}},{"line":302,"address":[],"length":0,"stats":{"Line":109}},{"line":303,"address":[],"length":0,"stats":{"Line":109}},{"line":304,"address":[],"length":0,"stats":{"Line":109}},{"line":305,"address":[],"length":0,"stats":{"Line":109}},{"line":347,"address":[],"length":0,"stats":{"Line":109}},{"line":348,"address":[],"length":0,"stats":{"Line":109}}],"covered":100,"coverable":136},{"path":["/","Users","weaver","Desktop","chainsupport","subsmt","sparse-merkle-tree","src","trie_tree.rs"],"content":"use crate::{\n    error::{Error, Result},\n    merge::{into_merge_value, merge, MergeValue},\n    merkle_proof::MerkleProof,\n    traits::{Hasher, StoreReadOps, StoreWriteOps, Value},\n    tree::{BranchKey, BranchNode},\n    vec::Vec,\n    H256, MAX_STACK_SIZE,\n};\nuse core::marker::PhantomData;\n\n/// Sparse merkle tree\n#[derive(Default, Debug)]\npub struct SparseMerkleTree\u003cH, V, S\u003e {\n    store: S,\n    root: H256,\n    phantom: PhantomData\u003c(H, V)\u003e,\n}\n\nimpl\u003cH, V, S\u003e SparseMerkleTree\u003cH, V, S\u003e {\n    /// Build a merkle tree from root and store\n    pub fn new(root: H256, store: S) -\u003e SparseMerkleTree\u003cH, V, S\u003e {\n        SparseMerkleTree {\n            root,\n            store,\n            phantom: PhantomData,\n        }\n    }\n\n    /// Merkle root\n    pub fn root(\u0026self) -\u003e \u0026H256 {\n        \u0026self.root\n    }\n\n    /// Check empty of the tree\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.root.is_zero()\n    }\n\n    /// Destroy current tree and retake store\n    pub fn take_store(self) -\u003e S {\n        self.store\n    }\n\n    /// Get backend store\n    pub fn store(\u0026self) -\u003e \u0026S {\n        \u0026self.store\n    }\n\n    /// Get mutable backend store\n    pub fn store_mut(\u0026mut self) -\u003e \u0026mut S {\n        \u0026mut self.store\n    }\n}\n\nimpl\u003cH: Hasher + Default, V, S: StoreReadOps\u003cV\u003e\u003e SparseMerkleTree\u003cH, V, S\u003e {\n    /// Build a merkle tree from store, the root will be calculated automatically\n    pub fn new_with_store(store: S) -\u003e Result\u003cSparseMerkleTree\u003cH, V, S\u003e\u003e {\n        let root_branch_key = BranchKey::new(core::u8::MAX, H256::zero());\n        store\n            .get_branch(\u0026root_branch_key)\n            .map(|branch_node| {\n                branch_node\n                    .map(|n| {\n                        merge::\u003cH\u003e(core::u8::MAX, \u0026H256::zero(), \u0026n.left, \u0026n.right).hash::\u003cH\u003e()\n                    })\n                    .unwrap_or_default()\n            })\n            .map(|root| SparseMerkleTree::new(root, store))\n    }\n}\n\nimpl\u003cH: Hasher + Default, V: Value, S: StoreReadOps\u003cV\u003e + StoreWriteOps\u003cV\u003e\u003e\n    SparseMerkleTree\u003cH, V, S\u003e\n{\n    /// Update a leaf, return new merkle root\n    /// set to zero value to delete a key\n    pub fn update(\u0026mut self, key: H256, value: V) -\u003e Result\u003c\u0026H256\u003e {\n        let value_h256 = value.to_h256();\n        let is_delete = value_h256.is_zero();\n        // notice when value is zero the leaf is deleted, so we do not need to store it\n        if is_delete {\n            self.store.remove_leaf(\u0026key)?;\n        } else {\n            self.store.insert_leaf(key, value)?;\n        }\n\n        let mut last_height = core::u8::MAX;\n        loop {\n            // walk from top to bottom\n            let node_key = key.parent_path(last_height);\n            let branch_key = BranchKey::new(last_height, node_key); // this represents a position in the tree\n            if let Some(branch) = self.store.get_branch(\u0026branch_key)? {\n                // if we we found a record in here\n                // we need to determine whether is it a shortcut\n                let (target, another) = if key.is_right(last_height) {\n                    (branch.right, branch.left)\n                } else {\n                    (branch.left, branch.right)\n                };\n\n                match target {\n                    MergeValue::ShortCut {\n                        key: this_key,\n                        value,\n                        height: h,\n                    } =\u003e {\n                        if this_key.eq(\u0026key) {\n                            // we update its value\n                            if is_delete \u0026\u0026 another.is_zero() {\n                                self.store.remove_branch(\u0026branch_key)?;\n                            } else {\n                                let target = MergeValue::shortcut_or_value(key, value_h256, h);\n                                let new_branch = if key.is_right(last_height) {\n                                    BranchNode {\n                                        left: another,\n                                        right: target,\n                                    }\n                                } else {\n                                    BranchNode {\n                                        left: target,\n                                        right: another,\n                                    }\n                                };\n\n                                // update this shortcut's value\n                                self.store.insert_branch(branch_key, new_branch)?;\n                            }\n                            break;\n                        } else if !is_delete {\n                            // we need to move this shortcut down\n\n                            // OPTIMIZATION: the shortcut must dropping to the level where [shortcut's new_height + 1] = [insert/delete key's shortcut height + 1]\n                            // check definition of H256.fork_height()\n                            last_height = this_key.fork_height(\u0026key);\n\n                            let (next_left, next_right) = if key.is_right(last_height) {\n                                (\n                                    MergeValue::shortcut_or_value(this_key, value, last_height),\n                                    MergeValue::shortcut_or_value(key, value_h256, last_height),\n                                )\n                            } else {\n                                (\n                                    MergeValue::shortcut_or_value(key, value_h256, last_height),\n                                    MergeValue::shortcut_or_value(this_key, value, last_height),\n                                )\n                            };\n\n                            let next_branch_key =\n                                BranchKey::new(last_height, this_key.parent_path(last_height));\n\n                            self.store.insert_branch(\n                                next_branch_key,\n                                BranchNode {\n                                    left: next_left,\n                                    right: next_right,\n                                },\n                            )?;\n                            break; // go next round\n                        } else {\n                            // zero insertion meets shortcut, skip\n                            break; // go next round\n                        }\n                    }\n                    _ =\u003e {\n                        if target.is_zero() || last_height == 0 {\n                            let insert_value =\n                                MergeValue::shortcut_or_value(key, value_h256, last_height);\n                            let (left, right) = if key.is_right(last_height) {\n                                (another, insert_value)\n                            } else {\n                                (insert_value, another)\n                            };\n                            self.store\n                                .insert_branch(branch_key, BranchNode { left, right })?;\n                            break;\n                        } else {\n                            // walk down\n                            last_height -= 1;\n                            continue;\n                        }\n                    }\n                }\n            } else if !is_delete {\n                let target_node = MergeValue::shortcut_or_value(key, value_h256, last_height);\n                let (left, right) = if key.is_right(last_height) {\n                    (MergeValue::zero(), target_node)\n                } else {\n                    (target_node, MergeValue::zero())\n                };\n                self.store\n                    .insert_branch(branch_key, BranchNode { left, right })?;\n                break; // stop walking\n            } else if last_height != 0 {\n                last_height -= 1;\n            } else {\n                // do nothing with a zero insertion\n                break;\n            }\n        }\n\n        for height in last_height..=core::u8::MAX {\n            // update tree hash from insert pos to top\n            let node_key = key.parent_path(height);\n            let branch_key = BranchKey::new(height, node_key);\n\n            let new_merge = if let Some(branch) = self.store.get_branch(\u0026branch_key)? {\n                merge::\u003cH\u003e(height, \u0026node_key, \u0026branch.left, \u0026branch.right)\n            } else {\n                MergeValue::zero()\n            };\n            if height == core::u8::MAX {\n                // updating root\n                self.root = new_merge.hash::\u003cH\u003e();\n            } else {\n                // updates parent branch\n                let parent_key = key.parent_path(height + 1);\n                let parent_branch_key = BranchKey::new(height + 1, parent_key);\n                if new_merge.is_shortcut() {\n                    // move up\n                    self.store.remove_branch(\u0026branch_key)?;\n                }\n                if let Some(parent_branch) = self.store.get_branch(\u0026parent_branch_key)? {\n                    let (left, right) = if key.is_right(height + 1) {\n                        (parent_branch.left, new_merge)\n                    } else {\n                        (new_merge, parent_branch.right)\n                    };\n                    if left.is_zero() \u0026\u0026 right.is_zero() {\n                        self.store.remove_branch(\u0026parent_branch_key)?;\n                    } else {\n                        let new_parent_branch = BranchNode { left, right };\n                        self.store\n                            .insert_branch(parent_branch_key, new_parent_branch)?;\n                    }\n                } else if !new_merge.is_zero() {\n                    let new_parent_branch = if key.is_right(height + 1) {\n                        BranchNode {\n                            left: MergeValue::zero(),\n                            right: new_merge,\n                        }\n                    } else {\n                        BranchNode {\n                            left: new_merge,\n                            right: MergeValue::zero(),\n                        }\n                    };\n                    self.store\n                        .insert_branch(parent_branch_key, new_parent_branch)?;\n                }\n            }\n        }\n\n        Ok(\u0026self.root)\n    }\n\n    /// Update multiple leaves at once\n    pub fn update_all(\u0026mut self, mut leaves: Vec\u003c(H256, V)\u003e) -\u003e Result\u003c\u0026H256\u003e {\n        // Dedup(only keep the last of each key) and sort leaves\n        leaves.reverse();\n        leaves.sort_by_key(|(a, _)| *a);\n        leaves.dedup_by_key(|(a, _)| *a);\n\n        for (key, value) in leaves {\n            self.update(key, value)?;\n        }\n\n        Ok(\u0026self.root)\n    }\n}\n\nimpl\u003cH: Hasher + Default, V: Value, S: StoreReadOps\u003cV\u003e\u003e SparseMerkleTree\u003cH, V, S\u003e {\n    /// Get value of a leaf\n    /// return zero value if leaf not exists\n    pub fn get(\u0026self, key: \u0026H256) -\u003e Result\u003cV\u003e {\n        if self.is_empty() {\n            return Ok(V::zero());\n        }\n        Ok(self.store.get_leaf(key)?.unwrap_or_else(V::zero))\n    }\n\n    /// Generate merkle proof\n    pub fn merkle_proof(\u0026self, mut keys: Vec\u003cH256\u003e) -\u003e Result\u003cMerkleProof\u003e {\n        if keys.is_empty() {\n            return Err(Error::EmptyKeys);\n        }\n\n        // sort keys\n        keys.sort_unstable();\n\n        // Collect leaf bitmaps\n        let mut leaves_bitmap: Vec\u003cH256\u003e = Default::default();\n        for current_key in \u0026keys {\n            let mut bitmap = H256::zero();\n            for height in (0..=core::u8::MAX).rev() {\n                let parent_key = current_key.parent_path(height);\n                let parent_branch_key = BranchKey::new(height, parent_key);\n                if let Some(parent_branch) = self.store.get_branch(\u0026parent_branch_key)? {\n                    let (sibling, target) = if current_key.is_right(height) {\n                        (parent_branch.left, parent_branch.right)\n                    } else {\n                        (parent_branch.right, parent_branch.left)\n                    };\n\n                    if !sibling.is_zero() {\n                        bitmap.set_bit(height);\n                    }\n                    if let MergeValue::ShortCut { key, .. } = target {\n                        if !key.eq(current_key) {\n                            let fork_height = key.fork_height(current_key);\n                            bitmap.set_bit(fork_height);\n                            break;\n                        }\n                    }\n                }\n            }\n            leaves_bitmap.push(bitmap);\n        }\n\n        let mut proof: Vec\u003cMergeValue\u003e = Default::default();\n        let mut stack_fork_height = [0u8; MAX_STACK_SIZE]; // store fork height\n        let mut stack_top = 0;\n        let mut leaf_index = 0;\n\n        while leaf_index \u003c keys.len() {\n            let leaf_key = keys[leaf_index];\n            let fork_height = if leaf_index + 1 \u003c keys.len() {\n                leaf_key.fork_height(\u0026keys[leaf_index + 1])\n            } else {\n                core::u8::MAX\n            };\n\n            let heights = (0..=fork_height)\n                .into_iter()\n                .filter(|height| {\n                    if stack_top \u003e 0 \u0026\u0026 stack_fork_height[stack_top - 1] == *height {\n                        stack_top -= 1;\n                        false\n                    } else {\n                        true\n                    }\n                })\n                .collect::\u003cVec\u003c_\u003e\u003e();\n\n            let mut proof_result = Vec::new();\n            for height in heights.iter().copied().rev() {\n                if height == fork_height \u0026\u0026 leaf_index + 1 \u003c keys.len() {\n                    // If it's not final round, we don't need to merge to root (height=255)\n                    continue;\n                }\n\n                if leaves_bitmap[leaf_index].get_bit(height) {\n                    let parent_key = leaf_key.parent_path(height);\n                    let is_right = leaf_key.is_right(height);\n                    let parent_branch_key = BranchKey::new(height, parent_key);\n                    if let Some(parent_branch) = self.store.get_branch(\u0026parent_branch_key)? {\n                        let (sibling, current) = if is_right {\n                            (parent_branch.left, parent_branch.right)\n                        } else {\n                            (parent_branch.right, parent_branch.left)\n                        };\n                        push_sibling::\u003cH\u003e(\u0026mut proof_result, sibling);\n                        if let MergeValue::ShortCut { key, value, .. } = current {\n                            if !key.eq(\u0026leaf_key) {\n                                // this means key does not exist\n                                let fork_height = key.fork_height(\u0026leaf_key);\n                                if leaves_bitmap[leaf_index].get_bit(fork_height)\n                                    \u0026\u0026 heights.contains(\u0026fork_height)\n                                {\n                                    proof_result.push(into_merge_value::\u003cH\u003e(\n                                        key,\n                                        value,\n                                        fork_height,\n                                    ))\n                                }\n                            }\n                            break;\n                        }\n                    } else {\n                        // Maybe we've skipped shortcut node, find from up to down\n                        for i in (height..=core::u8::MAX).rev() {\n                            let parent_key = leaf_key.parent_path(i);\n                            let is_right = leaf_key.is_right(i);\n                            let parent_branch_key = BranchKey::new(i, parent_key);\n                            if let Some(parent_branch) =\n                                self.store.get_branch(\u0026parent_branch_key)?\n                            {\n                                let current = if is_right {\n                                    parent_branch.right\n                                } else {\n                                    parent_branch.left\n                                };\n\n                                match current {\n                                    MergeValue::ShortCut { key, value, .. } =\u003e {\n                                        if !key.eq(\u0026leaf_key) {\n                                            let fork_at = key.fork_height(\u0026leaf_key);\n                                            if fork_at == height {\n                                                proof_result.push(into_merge_value::\u003cH\u003e(\n                                                    key, value, fork_at,\n                                                ));\n                                            }\n                                        }\n                                        break;\n                                    }\n                                    _ =\u003e {\n                                        continue;\n                                    }\n                                }\n                            }\n                        }\n                        break; // we should stop further looping\n                    }\n                }\n            }\n\n            proof_result.reverse();\n            proof.append(\u0026mut proof_result);\n            debug_assert!(stack_top \u003c MAX_STACK_SIZE);\n            stack_fork_height[stack_top] = fork_height;\n            stack_top += 1;\n            leaf_index += 1;\n        }\n        Ok(MerkleProof::new(leaves_bitmap, proof))\n    }\n}\n\n// Helper function for a merkle_path insertion\nfn push_sibling\u003cH: Hasher + Default\u003e(proof_result: \u0026mut Vec\u003cMergeValue\u003e, sibling: MergeValue) {\n    match sibling {\n        MergeValue::ShortCut { key, value, height } =\u003e {\n            proof_result.push(into_merge_value::\u003cH\u003e(key, value, height))\n        }\n        _ =\u003e proof_result.push(sibling),\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":212}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>